<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Python," />










<meta name="description" content="Python 数据模型特殊方法内置函数会调用特殊方法，一般无需直接调用特殊方法，除了__init__方法。">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python_注释笔记">
<meta property="og:url" content="http://adieUkid.github.io/2018/09/13/流畅的Python_注释笔记/index.html">
<meta property="og:site_name" content="Alan&#39;s Notes">
<meta property="og:description" content="Python 数据模型特殊方法内置函数会调用特殊方法，一般无需直接调用特殊方法，除了__init__方法。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/sequence.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/set.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/散列.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/闭包.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/collections.abc.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/iter.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/iterable.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/过滤生成器.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/映射生成器.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/合并生成器.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/扩展生成器.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/排列生成器.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/归约函数.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/EAFP和LBYL.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/协程.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/DES.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/asyncio的yield%20from.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/导入时和运行时.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/type和object.png">
<meta property="og:image" content="http://adieukid.github.io/images/python/fluent_python/ABCMeta和type.png">
<meta property="og:updated_time" content="2018-10-25T03:05:21.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="流畅的Python_注释笔记">
<meta name="twitter:description" content="Python 数据模型特殊方法内置函数会调用特殊方法，一般无需直接调用特殊方法，除了__init__方法。">
<meta name="twitter:image" content="http://adieukid.github.io/images/python/fluent_python/sequence.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://adieUkid.github.io/2018/09/13/流畅的Python_注释笔记/"/>





  <title>流畅的Python_注释笔记 | Alan's Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?94a8565d2829b2f9641fe2f93513cd52";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alan's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">笔记分享</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adieUkid.github.io/2018/09/13/流畅的Python_注释笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">流畅的Python_注释笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T17:50:36+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Python-数据模型"><a href="#Python-数据模型" class="headerlink" title="Python 数据模型"></a>Python 数据模型</h1><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>内置函数会调用特殊方法，一般无需直接调用特殊方法，除了<code>__init__</code>方法。</p>
<a id="more"></a>
<p><code>__len__</code>：调用len(obj)，解释器会自动调用 <code>obj.__len__()</code>。</p>
<p>对于Python内置的类型（list,str等），CPython还会抄近路提升计算速度，直接返回PyVarObject（内存中长度可变的内置对象的C语言结构体）里的ob_size属性</p>
<p><code>__repr__</code>：被repr()函数调用，或者直接在控制台输入，把一个对象用字符串的形式表达出来以便辨认。面向开发者使用</p>
<p><code>__str__</code>：被str()函数调用，或者用print函数打印时调用，返回的字符串对中断用户更友好。面向用户的</p>
<p>区别：如果一个对象没有<code>__str__</code>函数，Python又需要调用时，会用<code>__repr__</code>代替</p>
<p><code>__add__</code>：执行+运算</p>
<p><code>__mul__</code>：执行*运算</p>
<p>PS：中缀运算符的原则是，不改变操作对象，而是产生出一个新的值</p>
<p><code>__rmul__</code>：解决交换律问题</p>
<p><code>__bool__</code>：被bool()函数调用，应该返回bool类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(self.a <span class="keyword">or</span> self.b)</span><br></pre></td></tr></table></figure>
<h1 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h1><h2 id="内置序列"><a href="#内置序列" class="headerlink" title="内置序列"></a>内置序列</h2><p>按元素类型分类：</p>
<p>容器序列：list、tuple、collections.deque，可以存放不同类型的数据</p>
<p>扁平序列：str、bytes、bytearray、memoryview、array.array，只能容纳一种类型</p>
<p>按是否能被修改分类：</p>
<p>可变序列：list、bytearray、array.array、collections.deque、memoryview</p>
<p>不可变序列：tuple、str、bytes</p>
<h2 id="列表推导式、生成器表达式"><a href="#列表推导式、生成器表达式" class="headerlink" title="列表推导式、生成器表达式"></a>列表推导式、生成器表达式</h2><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>生成新的列表</p>
<p><code>str = &#39;测试字符串&#39;</code><br><code>arr = [ord(x) for x in str if ord(x) &gt; 30000]</code></p>
<p>与使用filter加map的比较</p>
<p><code>list(filter(lambda x: x &gt; 30000, map(ord, str)))</code></p>
<p>生成器表达式：生成列表以外的序列类型</p>
<p>逐个的产出元素，而不会在内存中留下一个列表，节省内存，提高效率。</p>
<p><code>str = &#39;测试字符串&#39;*1000000</code><br><code>arr = (ord(x) for x in str if ord(x) &gt; 30000)</code></p>
<p>上述操作花费0.2s，如果换成列表推到式，将大约花费2s。</p>
<p>如果声称其表达式是函数调用中的唯一参数，那么不再需要括号围起来，如 <code>tuple(x for x in arr)</code>。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>可以作为“不可变列表”，还可以用于没有字段名的纪录。</p>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>namedtuple，有名称和字段名的元组。</p>
<p>定义：<code>x = (&#39;Beijing&#39;, 2018)</code> 或省略括号 <code>x = &#39;Beijing&#39;, 2018</code></p>
<p>访问元素：<code>x[0]</code></p>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p><code>city, year, pop = (&#39;Tokyo&#39;, 2003, 32450)</code></p>
<p>等式左边是元组的省略括号的写法，等同于<code>(city,year,pop) = ...</code>。</p>
<p>元组拆包可以应用到任何可迭代对象上，唯一的要求是，接受元素的元组的空档数必须要和被迭代对象中的元素数量一致。</p>
<p>对于不关心的元素，可以用_占位符代替。对于多余的元素，可以用*来忽略。</p>
<p><code>str = &#39;测试字符串&#39;</code></p>
<p><code>a,b,_,*args = str</code></p>
<p>*前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置。</p>
<p>拆包时带<em>的变量类型被定义为list，如果</em>加在方法的形参上面，则变量被定义为tuple。</p>
<p><code>a, *b = &#39;Beijing&#39;, 2018, 1</code><br><code>print(type(b))      #list</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my</span><span class="params">(a,*b)</span>:</span></span><br><span class="line">    print(type(b))   <span class="comment">#tuple</span></span><br></pre></td></tr></table></figure>
<p>不使用中间变量交换两个变量的值</p>
<p><code>b,a=a,b</code></p>
<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><p><code>name, cc, pop, (lat, long) = (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667))</code><br><code>print(&#39;{:^15}|{:^9.4f}|{:^9.4f}&#39;.format(name, lat, long)) # :9个单位的空间，保留4位小数，^居中</code></p>
<h3 id="具名元组-1"><a href="#具名元组-1" class="headerlink" title="具名元组"></a>具名元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>) </span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, [<span class="string">'name'</span>,<span class="string">'country'</span>,<span class="string">'population'</span>,<span class="string">'coordinates'</span>]) </span><br><span class="line">tokyo = City(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br></pre></td></tr></table></figure>
<p>元素访问：</p>
<p>tokyo[0]，tokyo.name</p>
<p>属性和方法：</p>
<p>City._fields：返回包含这个类所有字段名称的元组<br>City._make()：通过接受一个可迭代对象来生成一个实例，和调用City()是一样的<br>City._asdict()：以 collections.OrderedDict 形式返回，方便遍历元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> tokyo._asdict().items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>
<p>元组与列表的方法区别：元组没有列表的增删改/清空等方法，包含查询和统计的方法。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>slice</p>
<p>切片和区间操作都不包含范围的最后一个元素，（左闭右开）。</p>
<p>优点：快速计算长度，后一个数减前一个数。快速分割元素不重叠，<code>mylist[:10]</code>和<code>mylist[10:]</code></p>
<p><code>s = &#39;bicycle&#39;</code><br><code>print(s[::3])   # start:stop:step</code></p>
<p>相当于<code>s[slice(None,None,3)]</code>，即<code>s.__getitem__(slice(None,None,3))</code>。</p>
<p>多维切片：二维的numpy.ndarray就可以用a[m:n, k:l]的方式来得到二维切片</p>
<p>省略：ellipsis，Ellipsis对象是ellipsis类的单一实例</p>
<p>给切片复制：切片可以放在复制语句的左边或作为del操作的对象，可以对序列进行嫁接，切除或就地修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line">l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line">l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span>  <span class="comment">#报错，如果把切片放在赋值左侧·1，右侧则必须是个可迭代对象</span></span><br></pre></td></tr></table></figure>
<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h2><p>浅表复制，序列中包含引用的话，仅仅是复制引用。</p>
<p>创建一个3*3的列表</p>
<p><code>arr = [[&#39;_&#39;]*3]*3</code></p>
<p>实际上创建了一个[‘<em>‘,’</em>‘,’_’]列表，然后复制了3次引用。改变其中一个列表的元素 <code>arr[1][2] = &#39;0&#39;</code>，将影响三个列表。</p>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row = [<span class="string">'_'</span>] * <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    arr.append(row)</span><br></pre></td></tr></table></figure>
<p>正确的做法：</p>
<p><code>arr = [[&#39;_&#39;] * 3 for i in range(3)]</code></p>
<h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><p><code>a += b</code></p>
<p>增量赋值运算符+=和*=的表现取决于他们第一个操作对象。背后的特殊方法时 <code>__iadd__</code> 和 <code>__imul__</code> ，如果a实现了 <code>__iadd__</code> ，则会调用这个方法。</p>
<p>对于可变序列（list,bytearray…）来说，a就会就地改动（in-place），好像调用了 <code>a.extend(b)</code> 一样。</p>
<p>如果a没有实现 <code>__iadd__</code>，这个表达式就变得跟 <code>a = a+b</code> 一样了。会计算 <code>a+b</code>，得出一个新对象，然后赋值给a。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">l=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(id(l))</span><br><span class="line">l*=<span class="number">2</span></span><br><span class="line">print(id(l))    <span class="comment"># 两次id相等，in-place，效率高</span></span><br><span class="line"></span><br><span class="line">t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(id(t))</span><br><span class="line">t*=<span class="number">2</span></span><br><span class="line">print(id(t))   <span class="comment"># 两次id不等，新的对象，效率低</span></span><br></pre></td></tr></table></figure>
<p>问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<p>结果：t变成（1,2,[30,40,50,60]），但仍会抛出TypeError异常</p>
<p>查看类似过程的字节码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(<span class="string">'s[a]+=b'</span>)</span><br></pre></td></tr></table></figure>
<p>步骤说明：</p>
<ol>
<li>将s[a]的值存入TOS（Top Of Stack）</li>
<li>TOS += b，TOS是一个list，可以执行</li>
<li>s[a] = TOS，s是不可变的，所以执行失败</li>
</ol>
<p>结论：</p>
<ol>
<li>不要把可变对象放在元组里</li>
<li>增量赋值不是一个原子操作</li>
</ol>
<h2 id="list-sort-和sorted"><a href="#list-sort-和sorted" class="headerlink" title="list.sort()和sorted()"></a>list.sort()和sorted()</h2><p>list.sort()，就地排序，返回None。</p>
<p>sorted，新建一个列表并返回。可接受任何形式的可迭代对象，如，字符串，不可变序列或生成器，最后都会返回一个列表。</p>
<p>list.sort()和sorted()的参数：</p>
<p>reverse：为True则降序排列</p>
<p>key：一个只有一个参数的函数，key=len，key=myfunc，默认值是恒等函数</p>
<p>包含key参数的内置函数还有，min()和max()等。</p>
<h2 id="bisect管理已排序的序列"><a href="#bisect管理已排序的序列" class="headerlink" title="bisect管理已排序的序列"></a>bisect管理已排序的序列</h2><p>bisect模块包含两个主要函数，bisect和insort，都利用二分查找来在有序序列中查找或插入元素。</p>
<p>bisect.bisect：bisect(haystack, needle)，在haystack(干草垛，必须升序)中找needle(针，待插入的元素)的位置</p>
<p>可选参数，lo和hi，控制搜索的范围。</p>
<p>bisect其实是bisect_right函数的别名，如果碰到相等的元素，bisect_right返回的插入位置是原序列中被插入元素相等的元素的之后的位置。</p>
<p>相应的还有bisect_left，对于这种情况则返回相等元素的原位置，即相等元素之前的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score)</span>:</span></span><br><span class="line">    breakpoints = [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line">    grades = <span class="string">'FDCBA'</span></span><br><span class="line">    i = bisect.bisect(breakpoints, score)</span><br><span class="line">    <span class="keyword">return</span> grades[i]</span><br><span class="line"></span><br><span class="line">print([grade(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">59</span>, <span class="number">66</span>, <span class="number">99</span>]])</span><br></pre></td></tr></table></figure>
<p>bisect.insort：insort(seq,item)把变量item插入到序列seq中，并能保持seq的升序顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    bisect.insort(l, random.randrange(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h2 id="列表不是首选时"><a href="#列表不是首选时" class="headerlink" title="列表不是首选时"></a>列表不是首选时</h2><p>如果要存放1000万个浮点数的话，数组（array）的效率要高得多。因为数组背后存的不是float对象，而是数字的机器翻译，也就是字节表述。就跟C语言中的数组一样。</p>
<p>如果要频繁的进行FIFO的操作，deque速度会更快。如果检查元素是否存在的频率很高，用set更合适。因为set专为检查元素是否存在做过优化。</p>
<p>数组：数组支持所有跟可变序列有关的操作，pop，insert，extend。还有从文件读和存入文件的更快的方法，frombytes，tofile</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用生成器表达式建立一个1000万个浮点数的数组。'd'是类型码，代表数组只能存放双精度浮点数</span></span><br><span class="line">fs = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>)))</span><br><span class="line">print(fs[<span class="number">-1</span>])</span><br><span class="line">fp = open(<span class="string">'floats.bin'</span>, <span class="string">'wb'</span>)</span><br><span class="line">fs.tofile(fp)   <span class="comment">#将1000万个浮点数以二进制格式写入一个二进制文件</span></span><br><span class="line">fp.close()</span><br><span class="line">fs2 = array(<span class="string">'d'</span>)</span><br><span class="line">fp = open(<span class="string">'floats.bin'</span>,<span class="string">'rb'</span>)</span><br><span class="line">fs2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">fp.close()</span><br><span class="line">print(fs2[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">print(fs == fs2)  <span class="comment">#两个数组的内容一模一样</span></span><br></pre></td></tr></table></figure>
<p>从Python3.4开始，数组类型不在支持诸如list.sort()这种就地排序，排序要用sorted函数新建一个数组。</p>
<p>内存视图：能让用户在不复制内容的情况下操作同一个数组的不同切片。memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">nums = array.array(<span class="string">'i'</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">memv = memoryview(nums)</span><br><span class="line">print(memv[<span class="number">0</span>])      <span class="comment">#2</span></span><br><span class="line">memv[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">print(nums[<span class="number">0</span>])      <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">memv_n = memv.cast(<span class="string">'B'</span>)</span><br><span class="line">memv_n[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">print(memv[<span class="number">0</span>])      <span class="comment">#9</span></span><br><span class="line">print(memv_n[<span class="number">0</span>])    <span class="comment">#9</span></span><br><span class="line">print(nums[<span class="number">0</span>])      <span class="comment">#9</span></span><br></pre></td></tr></table></figure>
<p>双向队列和其他形式的队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">dq = deque(range(<span class="number">10</span>), maxlen=<span class="number">10</span>)  <span class="comment"># maxlen可选参数，指定队列的最大长度，超出的元素将被舍弃</span></span><br><span class="line"></span><br><span class="line">dq.rotate(<span class="number">3</span>)  <span class="comment"># 旋转：接受一个参数n，当n&gt;0时，从队列最右边的n个元素移动到队列左边。当n&lt;0时，反之。</span></span><br><span class="line">dq.rotate(<span class="number">-4</span>)</span><br><span class="line"></span><br><span class="line">dq.append(<span class="number">10</span>)  <span class="comment"># 从队列尾部（右边）添加一个元素</span></span><br><span class="line">dq.append([<span class="number">10</span>, <span class="number">20</span>])  <span class="comment"># 从队列尾部添加一个列表元素</span></span><br><span class="line">dq.appendleft(<span class="number">10</span>)  <span class="comment"># 与append相反</span></span><br><span class="line">dq.appendleft([<span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">dq.extend([<span class="number">10</span>, <span class="number">20</span>])  <span class="comment"># 接受可迭代对象，将所有元素一个一个添加到队列右边</span></span><br><span class="line">dq.extendleft([<span class="number">10</span>, <span class="number">20</span>])  <span class="comment"># 与extend相反</span></span><br><span class="line"></span><br><span class="line">dq.pop()  <span class="comment"># 删除队列最右边的一个元素，并返回</span></span><br><span class="line">dq.popleft()</span><br></pre></td></tr></table></figure>
<p>append和popleft都是原子操作，deque可以在多线程程序中安全地当做FIFO的栈使用。</p>
<h1 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h1><h2 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h2><p>collections.abc模块中有Mapping和MutableMapping两个基类。</p>
<p>ABC：Abstract Base Class</p>
<p><img src="/images/python/fluent_python/sequence.png" alt="sequence"></p>
<p>非抽象映射类型一般不直接继承这些abc，他们的作用是作为形式化文档，为dict何其他映射类型定义形式接口。还可以通过isinstance来判断某个数据是否是映射类型。</p>
<p><code>my_dict = {}   # 或其他类型的Map</code></p>
<p><code>isinstance(my_dict, abc.Mapping)   # True</code></p>
<p>可散列类型：</p>
<p>如果一个对象是可散列的，那么在这个对象的声明周期中，它的散列值是不变的，而且这个对象要实现<strong>hash</strong>()方法。</p>
<p>另外可散列对象还有有<strong>qe</strong>()方法，这样才能和其他键值作比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。</p>
<p>原子不可变数据类型（str、butes和数值），frozenset，tuple（必须包含的所有元素都是可散列类型），都是可散列的。</p>
<p>可散列tuple：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">hash(t1)</span><br><span class="line">t2 = (<span class="number">1</span>, [])</span><br><span class="line">hash(t2)  <span class="comment"># TypeError: unhashable type: 'list'</span></span><br></pre></td></tr></table></figure>
<p>字典的构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;</span><br><span class="line">b = dict(&#123;<span class="string">'one'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">c = dict(one=<span class="number">1</span>)</span><br><span class="line">d = dict(zip([<span class="string">'one'</span>], [<span class="number">1</span>]))</span><br><span class="line">e = dict([(<span class="string">'one'</span>, <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">a == b == c == d == e  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'USA'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">codes = &#123;contry: code <span class="keyword">for</span> code, contry <span class="keyword">in</span> CODES <span class="keyword">if</span> code &gt; <span class="number">10</span>&#125;</span><br><span class="line">print(codes)</span><br></pre></td></tr></table></figure>
<h2 id="映射的常用方法"><a href="#映射的常用方法" class="headerlink" title="映射的常用方法"></a>映射的常用方法</h2><p>setdefault：</p>
<p><code>my_dict.setdefault(key, []).append(new_value)</code></p>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = my_dict.get(key, [])</span><br><span class="line">v.append(new_value)</span><br><span class="line">my_dict[key] = v</span><br></pre></td></tr></table></figure>
<p>defaultdict：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(list)</span><br><span class="line">d[key].append(new_value)</span><br></pre></td></tr></table></figure>
<p>把list的构造方法作为default_factory来创建一个defaultdict，只会在<strong>getitem</strong>里被调用，其他比如get方法，在找不到键时只会返回None。</p>
<p><code>__missing__</code>：</p>
<p>只被<code>__getitem__</code>调用，如defaultdict，在<code>__missing__</code>中实现了调用default_factory方法。</p>
<h2 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h2><p>collections.OrderedDict：添加键的时候会保持顺序</p>
<p>collections.ChainMap：可以容纳数个不同的映射对象，然后进行键查找时会把这些对象当成一个整体逐个查找。这个功能再给有嵌套作用域的语言做解释器的时候很有用，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">print(locals())    <span class="comment">#本地变量</span></span><br><span class="line">print(globals())  <span class="comment">#全局变量</span></span><br><span class="line">print(vars(builtins))</span><br><span class="line"></span><br><span class="line">collections.Counter：键-整数计数器，每次更新一个键的时候都会增加这个计数器。这个类型可以用来给可散列对象技术。</span><br><span class="line"></span><br><span class="line">ct = collections.Counter(<span class="string">'absdfxasdasdf'</span>)</span><br><span class="line">ct.update(<span class="string">'aaaadd'</span>)</span><br><span class="line">print(ct.most_common(<span class="number">2</span>))    <span class="comment"># 最常见的2个键和它们的计数</span></span><br></pre></td></tr></table></figure>
<p>UserDict：子类化，以UserDict为基类创造自定义映射类型，它并不是dict的子类，继承的是MutableMapping，有一个data属性，是一个dict实例。最终存储数据的地方。</p>
<p>不可变映射类型：返回一个映射的只读视图，但是时动态的，如果原映射有改动，可以通过视图观察到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;</span><br><span class="line">d_proxy = MappingProxyType(d)</span><br><span class="line">print(d_proxy[<span class="number">1</span>])</span><br><span class="line">d_proxy[<span class="number">1</span>] = <span class="string">'B'</span>    <span class="comment"># 报错</span></span><br><span class="line">d[<span class="number">1</span>] = <span class="string">'B'</span></span><br><span class="line">print(d_proxy[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>保证元素的唯一性，集合中的元素必须是可散列的，set本身是不可散列的，但是frozenset可以</p>
<p>中缀运算：a|b，返回合集。a&amp;b返回交集，a-b返回差集</p>
<p>计算重叠元素的个数</p>
<p><code>found = len(needles &amp; haystack)    #两侧都需要是集合类型</code></p>
<p>或</p>
<p><code>found = len(set(needles).intersection(haystack))    #如果一个对象还不是集合类型</code></p>
<p>直接使用set的交集计算比for遍历计算求和快的多</p>
<p>字面量：<code>s = {1}</code> 或 <code>s = set([1])</code></p>
<p>空集：s = set()，不能写{}（空字典）</p>
<p>直接写{1}的方式更快，因为Python会利用一个专门的BUILD_SET的字节码来创建集合。查看区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">dis(<span class="string">'&#123;1&#125;'</span>)</span><br><span class="line">dis(<span class="string">'set([1])'</span>)</span><br></pre></td></tr></table></figure>
<p>fronzenset只能通过构造方法创建。</p>
<p>集合推导：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line"></span><br><span class="line">print(&#123;chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">'SIGN'</span> <span class="keyword">in</span> name(chr(c), <span class="string">''</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>集合的的继承关系：</p>
<p><img src="/images/python/fluent_python/set.png" alt="set"></p>
<p>基本操作：</p>
<ul>
<li>+/-/&amp;/|</li>
<li>e in s，元素e是否属于s</li>
<li>s &lt;= z，s是否为z的子集</li>
<li>s &lt; z，s是否为z的真子集</li>
<li>s &gt;=z/s&gt;z</li>
</ul>
<h2 id="dict和set的背后原理"><a href="#dict和set的背后原理" class="headerlink" title="dict和set的背后原理"></a>dict和set的背后原理</h2><p>散列表其实是一个稀疏数组（总有空白元素的数组），散列表的单元通常叫做表元（bucket），在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。</p>
<p>因为Python会设法保证大概还有三分之一的表元是空的，所以快要达到这个阈值时，原有的散列表会被复制到更大的空间里面进行扩容。</p>
<h3 id="散列表算法"><a href="#散列表算法" class="headerlink" title="散列表算法"></a>散列表算法</h3><p>为了获取dict[search_key]背后的值，Python首先会调用hash(search_key)来计算search_key的散列值，取这个值最低的几位数字（具体几位看当前散列表的大小）当做偏移量，在散列表里查找表元。若找到的表元是空的，则抛出KeyError异常。若不是空的，则表元里会有一堆found_key:found_value，这时候进行校验search_key == found_key是否为真，如果相等，则返回found_value。</p>
<p>如果search_key和found_key不匹配的话，这种情况称为散列冲突。发生这种情况原因是，把随机元素映射到几位的数字上，而索引又依赖于这几位数字的一部分而已。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当成索引寻找表元，重复以上给欧成。</p>
<p>添加和更新操作几乎跟上面一样。</p>
<p><img src="/images/python/fluent_python/散列.png" alt="散列表"></p>
<h3 id="dict的实现及其限制"><a href="#dict的实现及其限制" class="headerlink" title="dict的实现及其限制"></a>dict的实现及其限制</h3><ul>
<li>键必须是可散列的</li>
</ul>
<p>支持hash()函数，并且通过 <code>__hash__()</code> 方法得到的散列值是不变的。</p>
<p>支持通过 <code>__eq__()</code> 方法来检测相对性。</p>
<p>若a == b为真，则hash(a) == hash(b) 也为真。</p>
<p>所有由用户自定义的对象默认都是可散列的，散列值由id()来计算获取。</p>
<ul>
<li>字典内存开销巨大</li>
</ul>
<p>为了保持散列表是稀疏的，将降低在空间上的效率。</p>
<p>如果要存放数量巨大的纪录，元组或具名元组构成的列表是比较好的选择。</p>
<ul>
<li>键查询很快</li>
</ul>
<p>dict是典型的空间换时间，内存开销大，但是查询速度快。</p>
<ul>
<li>键的次序取决于添加顺序</li>
</ul>
<p>添加新键又发生散列冲突时，新键可能会被安排存放到另一个位置。这将导致键的顺序乱掉。</p>
<ul>
<li>往字典里添加新键可能会改变已有键的顺序</li>
</ul>
<p>无论何时添加新键，Python解释器都可能做出字典寇蓉的决定。扩容导致把字典中已有的元素添加到更大的新表中，过程中如果发生散列冲突，将导致新标中键的次序变化。<br>因此不要同时对字典进行迭代和修改，最好分开两步进行。</p>
<h1 id="文本和字节序列"><a href="#文本和字节序列" class="headerlink" title="文本和字节序列"></a>文本和字节序列</h1><h2 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h2><p>Unicode字符标识和字节表述：</p>
<p>字符的标识，即码位。是0~1114111的数字，以4~6个十六进制数字表示。</p>
<p>字节表述取决于所用的编码，是在码位和字节序列之间转换时使用的算法。如UTF-8，字符在ASCII范围内用的编码成1个字节，一个汉字占3个字节。</p>
<h2 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h2><p>调用各自的构造方法，构建bytes或bytearray实例。</p>
<p>一个str对象和一个encoding关键字参数。</p>
<p>一个可迭代对象，提供0~255之间的数值。</p>
<p>一个实现了缓冲协议的对象（bytes，bytearray，memoryview，array.array），把源对象中的字节序列复制到新建的二进制序列中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cafe = bytes(<span class="string">'café'</span>, encoding=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">print(cafe)  <span class="comment"># b'caf\xc3\xa9'</span></span><br><span class="line">print(type(cafe))  <span class="comment"># bytes</span></span><br><span class="line">print(cafe[<span class="number">0</span>])  <span class="comment"># 99 0~255的整数</span></span><br><span class="line">print(cafe[:<span class="number">1</span>])  <span class="comment"># b'c'   一个字节的切片仍是bytes类型</span></span><br><span class="line"></span><br><span class="line">cafe_arr = bytearray(cafe)</span><br><span class="line">print(cafe_arr)  <span class="comment"># bytearray(b'caf\xc3\xa9')</span></span><br><span class="line">print(cafe_arr[<span class="number">-1</span>:])  <span class="comment"># bytearray(b'\xa9')</span></span><br></pre></td></tr></table></figure>
<p>各个字节的值可能使用下列三种不同的方式显示，</p>
<ol>
<li><p>可打印的ASCII范围内的字节（空格到~），使用ASCII字符本身。</p>
</li>
<li><p>制表符、换行符、回车符和\，使用转义序列\t、\n、\t和\。</p>
</li>
<li><p>其他字节，使用十六进制转义序列（\x00）</p>
</li>
</ol>
<h2 id="编码异常"><a href="#编码异常" class="headerlink" title="编码异常"></a>编码异常</h2><p>UnicodeEncodeError：编码时，编解码器没有定义某个字符时，就会抛出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">city = <span class="string">'São Paulo'</span></span><br><span class="line">city.encode(<span class="string">'utf_8'</span>)</span><br><span class="line">city.encode(<span class="string">'cp437'</span>)    <span class="comment">#抛出异常</span></span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'ignore'</span>)   <span class="comment">#忽略并删除无法编码的字符</span></span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'replace'</span>)   <span class="comment">#把无法编码的字符替换成'?'</span></span><br><span class="line">city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'xmlcharrefreplace'</span>)   <span class="comment">#把无法编码的字符替换成XML实体</span></span><br></pre></td></tr></table></figure>
<p>UnicodeDecodeError：解码时碰到无法转换的字节序列时会抛出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octets = <span class="string">b'Montr\xe9al'</span></span><br><span class="line">octets.decode(<span class="string">'cp1252'</span>)</span><br><span class="line">octets.decode(<span class="string">'utf_8'</span>)   <span class="comment">#抛出异常</span></span><br><span class="line">octets.decode(<span class="string">'utf_8'</span>, errors=<span class="string">'replace'</span>)   <span class="comment">#\xe9替换成“黑色菱形问号”（码位是U+FFFD），这是官方指定的 REPLACEMENT CHARACTER（替换字符），表示未知字符。</span></span><br></pre></td></tr></table></figure>
<h2 id="处理文本文件"><a href="#处理文本文件" class="headerlink" title="处理文本文件"></a>处理文本文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">open(<span class="string">'cafe.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf_8'</span>).write(<span class="string">'café'</span>)  <span class="comment"># 返回写入Unicode字符数，4</span></span><br><span class="line"><span class="comment"># 报告文件中有5个字节：caf是ASKII范围内的字符，占一个字节，最后一个特殊字符占两个字节</span></span><br><span class="line">os.stat(<span class="string">'cafe.txt'</span>).st_size   </span><br><span class="line"></span><br><span class="line">print(open(<span class="string">'cafe.txt'</span>, encoding=<span class="string">'utf8'</span>).read())</span><br><span class="line">fp4 = open(<span class="string">'cafe.txt'</span>, <span class="string">'rb'</span>)   <span class="comment"># 以二进制模式打开文件。常规代码只应该使用二进制模式打开二进制文件</span></span><br><span class="line">fp4.read()   <span class="comment"># b'caf\xc3\xa9'</span></span><br></pre></td></tr></table></figure>
<p>如果读取时不指定编码格式，那么Python会使用系统默认的编码，很有可能出现乱码。所以需要在多台设备或场合下运行的代码，打开读取文件时应始终明确传入encoding参数。</p>
<p>编码默认值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> locale</span><br><span class="line"></span><br><span class="line">expressions = <span class="string">"""</span></span><br><span class="line"><span class="string">    locale.getpreferredencoding()</span></span><br><span class="line"><span class="string">    type(my_file)</span></span><br><span class="line"><span class="string">    my_file.encoding</span></span><br><span class="line"><span class="string">    sys.stdout.isatty()</span></span><br><span class="line"><span class="string">    sys.stdout.encoding</span></span><br><span class="line"><span class="string">    sys.stdin.isatty()</span></span><br><span class="line"><span class="string">    sys.stdin.encoding</span></span><br><span class="line"><span class="string">    sys.stderr.isatty()</span></span><br><span class="line"><span class="string">    sys.stderr.encoding</span></span><br><span class="line"><span class="string">    sys.getdefaultencoding()</span></span><br><span class="line"><span class="string">    sys.getfilesystemencoding()</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_file = open(<span class="string">'dummy'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">for</span> expression <span class="keyword">in</span> expressions.split():</span><br><span class="line">    value = eval(expression)</span><br><span class="line">    print(expression.rjust(<span class="number">30</span>), <span class="string">'-&gt;'</span>, repr(value))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">locale.getpreferredencoding() -&gt; 'cp936'</span><br><span class="line">                type(my_file) -&gt; &lt;class '_io.TextIOWrapper'&gt;</span><br><span class="line">            my_file.encoding -&gt; 'cp936'</span><br><span class="line">        sys.stdout.isatty() -&gt; True</span><br><span class="line">        sys.stdout.encoding -&gt; 'utf-8'</span><br><span class="line">        sys.stdin.isatty() -&gt; True</span><br><span class="line">        sys.stdin.encoding -&gt; 'utf-8'</span><br><span class="line">        sys.stderr.isatty() -&gt; True</span><br><span class="line">        sys.stderr.encoding -&gt; 'utf-8'</span><br><span class="line">    sys.getdefaultencoding() -&gt; 'utf-8'</span><br><span class="line">sys.getfilesystemencoding() -&gt; 'utf-8'</span><br></pre></td></tr></table></figure>
<h1 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h1><h2 id="把函数视作对象"><a href="#把函数视作对象" class="headerlink" title="把函数视作对象"></a>把函数视作对象</h2><p>“一等对象”的定义为满足下述条件的程序实体：</p>
<ul>
<li>函数是一等对象。</li>
<li>在运行时创建。</li>
<li>可以赋值给变量，通过变量调用。</li>
<li>能作为参数传给函数。</li>
<li>能作为函数的返回结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''return n!'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">42</span>))</span><br><span class="line">print(factorial.__doc__)</span><br><span class="line">print(type(factorial))</span><br><span class="line"></span><br><span class="line">fact = factorial</span><br><span class="line">print(fact(<span class="number">5</span>))</span><br><span class="line">print(map(fact, range(<span class="number">10</span>)))</span><br><span class="line">print(list(map(fact, range(<span class="number">10</span>))))</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接受函数为参数或返回函数为结果的是函数是高阶函数，如map，sorted</p>
<ul>
<li>map，filter返回生成器，因此现在它们的直接替代品是生成器表达式。</li>
<li>functools.reduce，最常用于求和。</li>
<li>all(iterable)，如果iterable的每个元素都是真值，就返回True。</li>
<li>any(iterable)，如果iterable中有元素是真值，就返回True。</li>
</ul>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>因为句法限制，lambda函数的定义体不能赋值和使用while等语句，在Python中很少使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line">print(sorted(words, key=<span class="keyword">lambda</span> word: word[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可被调用运算符（即()）应用的，叫做可调用对象，可以使用callable()函数判断。</p>
<p>包括：</p>
<ul>
<li>用户定义的函数（def或lambda创建）</li>
<li>内置函数（C语言实现的函数，如len）</li>
<li>内置方法（C语言实现的方法，如dict.get）</li>
<li>方法（在类的定义体中定义的函数）</li>
<li>类（调用顺序为 <code>__new__</code>，<code>__init__</code> 初始化实例，然后返回给调用方）</li>
<li>类的实例（定义了 <code>__call__</code> 方法的类）</li>
<li>生成器函数（使用yield关键字的函数或方法，返回的是生成器对象）</li>
</ul>
<h2 id="用户定义的可调用类型"><a href="#用户定义的可调用类型" class="headerlink" title="用户定义的可调用类型"></a>用户定义的可调用类型</h2><p>实现了 <code>__call__</code> 的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bingo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._items = list(items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.pick()</span><br><span class="line"></span><br><span class="line">b = Bingo(range(<span class="number">3</span>))</span><br><span class="line">print(b())</span><br></pre></td></tr></table></figure>
<h2 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h2><p>dir函数可以探知对象的属性，计算出函数专有而一般对象没有的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">c = C()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(set(dir(func))-set(dir(c)))</span><br></pre></td></tr></table></figure>
<h2 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name=<span class="string">'p'</span>,  *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls:</span><br><span class="line">        attrs[<span class="string">'class'</span>] = cls</span><br><span class="line">    <span class="keyword">if</span> attrs:</span><br><span class="line">        attrs_str = <span class="string">''</span>.join(<span class="string">' &#123;&#125;="&#123;&#125;"'</span>.format(attr, value)</span><br><span class="line">                            <span class="keyword">for</span> attr, value <span class="keyword">in</span> attrs.items())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attrs_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> content:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(<span class="string">'&lt;&#123;&#125;&#123;&#125;&gt;&#123;&#125;&lt;/&#123;&#125;&gt;'</span>.format(name, attrs_str, c, name) <span class="keyword">for</span> c <span class="keyword">in</span> content)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125;&#123;&#125; /&gt;'</span>.format(name, attrs_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(tag(<span class="string">'br'</span>))</span><br><span class="line">print(tag(<span class="string">'p'</span>, <span class="string">'hello'</span>))</span><br><span class="line">print(tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>, id=<span class="string">'33'</span>, cls=<span class="string">'side'</span>))</span><br><span class="line">print(tag(content=<span class="string">'内容'</span>, name=<span class="string">'img'</span>))</span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>,</span><br><span class="line">     <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line">print(tag(**d))</span><br></pre></td></tr></table></figure>
<p>cls即仅限关键字的参数，因为未指定关键字的参数会被cls前面的*content捕获，并且cls有默认值可不指定，所以想要指定的话就必须指定关键字。</p>
<h2 id="获取关于参数的信息"><a href="#获取关于参数的信息" class="headerlink" title="获取关于参数的信息"></a>获取关于参数的信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name,  *content, cls=None, **attrs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(tag.__defaults__)  </span><br><span class="line"><span class="comment"># None,如果形参是name='xx',则是('xx',)。返回一个元组，保存的定位参数和关键字参数的默认值</span></span><br><span class="line">print(tag.__code__)  </span><br><span class="line"><span class="comment"># &lt;code object tag at ...&gt;，一个 code 对象引用， 自身也有很多属性</span></span><br><span class="line">print(tag.__code__.co_varnames)  <span class="comment"># ('name', 'cls', 'content', 'attrs') </span></span><br><span class="line">print(tag.__code__.co_argcount)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>更好更直观的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sig = signature(tag)</span><br><span class="line"></span><br><span class="line">print(sig)  <span class="comment"># (name='p', *content, cls=None, **attrs)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line">    print(param.kind, <span class="string">':'</span>, name, <span class="string">'='</span>, param.default)</span><br><span class="line">    <span class="comment"># POSITIONAL_OR_KEYWORD : name = &lt;class 'inspect._empty'&gt;。通过定位参数和关键字参数传入的形参</span></span><br><span class="line">    <span class="comment"># VAR_POSITIONAL : content = &lt;class 'inspect._empty'&gt;。定位参数元组</span></span><br><span class="line">    <span class="comment"># KEYWORD_ONLY : cls = None。仅限关键字参数</span></span><br><span class="line">    <span class="comment"># VAR_KEYWORD : attrs = &lt;class 'inspect._empty'&gt;。关键字参数字典。</span></span><br><span class="line"></span><br><span class="line">my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>,</span><br><span class="line">          <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line">bound_args = sig.bind(**my_tag)   <span class="comment"># 尝试绑定，验证参数，规则同调用</span></span><br><span class="line"><span class="comment"># &lt;BoundArguments (name=&#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;)&gt;</span></span><br><span class="line">print(bound_args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, value <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line">    print(name, <span class="string">'='</span>, value)</span><br><span class="line">    <span class="comment"># name = img</span></span><br><span class="line">    <span class="comment"># cls = framed</span></span><br><span class="line">    <span class="comment"># attrs = &#123;'title': 'Sunset Boulevard', 'src': 'sunset.jpg'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> my_tag[<span class="string">'name'</span>]</span><br><span class="line">bound_args = sig.bind(**my_tag)   <span class="comment">#抛出TypeError，缺少name参数。或提供name的默认值</span></span><br></pre></td></tr></table></figure>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(text: str, max_len: <span class="string">'int &gt; 0123'</span>=<span class="number">80</span>)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sig = signature(clip)</span><br><span class="line">print(sig.return_annotation)   <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> sig.parameters.values():</span><br><span class="line">    note = repr(param.annotation).ljust(<span class="number">30</span>)</span><br><span class="line">    print(note, <span class="string">':'</span>, param.name, <span class="string">'='</span>, param.default)</span><br><span class="line">    <span class="comment"># &lt;class 'str'&gt;                  : text = &lt;class 'inspect._empty'&gt;</span></span><br><span class="line">    <span class="comment"># 'int &gt; 0123'                   : max_len = 80</span></span><br></pre></td></tr></table></figure>
<h2 id="函数式编程的包"><a href="#函数式编程的包" class="headerlink" title="函数式编程的包"></a>函数式编程的包</h2><p>operator模块：多个算术运算符提供了对应的函数， 从而避免编写<code>lambda a, b: a*b</code>这种平凡的匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># return reduce(lambda curr, item: curr*item, range(1, n+1))</span></span><br><span class="line">    <span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">itemgetter，itemgetter(<span class="number">1</span>) 即 <span class="keyword">lambda</span> fields: fields[<span class="number">1</span>]</span><br><span class="line">attrgetter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter, attrgetter</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">metro_data = [</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_data, key=itemgetter(<span class="number">1</span>)):  <span class="comment"># 按某个字段排序</span></span><br><span class="line">    print(city)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line">    print(itemgetter(<span class="number">0</span>, <span class="number">1</span>)(city))</span><br><span class="line"></span><br><span class="line">LatLong = namedtuple(<span class="string">'LatLong'</span>, <span class="string">'lat long'</span>)</span><br><span class="line">Metropolis = namedtuple(<span class="string">'Metropolis'</span>, <span class="string">'name cc pop coord'</span>)</span><br><span class="line">metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long))</span><br><span class="line">               <span class="keyword">for</span> name, cc, pop, (lat, long) <span class="keyword">in</span> metro_data]</span><br><span class="line">print(metro_areas[<span class="number">0</span>])</span><br><span class="line">print(metro_areas[<span class="number">0</span>].coord.lat)</span><br><span class="line"></span><br><span class="line">name_lat = attrgetter(<span class="string">'name'</span>, <span class="string">'coord.lat'</span>)</span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas, key=attrgetter(<span class="string">'coord.lat'</span>)):</span><br><span class="line">    print(name_lat(city))</span><br></pre></td></tr></table></figure>
<p>methodcaller：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"></span><br><span class="line">s = <span class="string">'The time has come'</span></span><br><span class="line"></span><br><span class="line">upcase = methodcaller(<span class="string">'upper'</span>)</span><br><span class="line">hiphenate = methodcaller(<span class="string">'replace'</span>, <span class="string">' '</span>, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">print(upcase(s))</span><br><span class="line">print(hiphenate(s))</span><br><span class="line"></span><br><span class="line">使用functools.partial 冻结参数：</span><br><span class="line">即柯里化，基于一个函数创建一个新的可调用对象，固定指定某些参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">triple = partial(mul, <span class="number">3</span>)</span><br><span class="line">print(list(triple(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">picture = partial(tag, <span class="string">'img'</span>, cls=<span class="string">'pic-frame'</span>)</span><br><span class="line">picture(src=<span class="string">'some.jpg'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="使用一等函数实现设计模式"><a href="#使用一等函数实现设计模式" class="headerlink" title="使用一等函数实现设计模式"></a>使用一等函数实现设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="经典的策略模式"><a href="#经典的策略模式" class="headerlink" title="经典的策略模式"></a>经典的策略模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(c.total() <span class="keyword">for</span> c <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.total()-discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;Order total:&#123;:.2f&#125; due:&#123;:.2f&#125;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt; <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(item.total()*<span class="number">.1</span> <span class="keyword">for</span> item <span class="keyword">in</span> order.cart <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span> <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ann = Customer(<span class="string">'Ann Smith'</span>, <span class="number">1100</span>)</span><br><span class="line">cart = [LineItem(<span class="string">'banana'</span>, <span class="number">4</span>, <span class="number">.5</span>),</span><br><span class="line">        LineItem(<span class="string">'apple'</span>, <span class="number">10</span>, <span class="number">1.5</span>),</span><br><span class="line">        LineItem(<span class="string">'watermellon'</span>, <span class="number">5</span>, <span class="number">5.0</span>)]</span><br><span class="line">print(Order(ann, cart, FidelityPromo()))</span><br></pre></td></tr></table></figure>
<h3 id="函数实现“策略”模式"><a href="#函数实现“策略”模式" class="headerlink" title="函数实现“策略”模式"></a>函数实现“策略”模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt; <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(item.total()*<span class="number">.1</span> <span class="keyword">for</span> item <span class="keyword">in</span> order.cart <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.07</span> <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(p(order) <span class="keyword">for</span> p <span class="keyword">in</span> promos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Order(ann, cart, best_promo))</span><br></pre></td></tr></table></figure>
<h3 id="找出模块中的全部策略"><a href="#找出模块中的全部策略" class="headerlink" title="找出模块中的全部策略"></a>找出模块中的全部策略</h3><p>若想添加新的促销策略，要定义函数且加到promos列表中，下面尝试更灵活的方式。</p>
<p>globals：返回一个字典，表示当前的全局符号表</p>
<p>把策略方法封装到promotions模块中，使用inspect内省，取出</p>
<p>内省模块的全局命名空间， 构建 promos 列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals()</span><br><span class="line">          <span class="keyword">if</span> name.endswith(<span class="string">'_promo'</span>) <span class="keyword">and</span> name != <span class="string">'best_promo'</span>]</span><br></pre></td></tr></table></figure>
<p>内省单独的 promotions 模块， 构建 promos 列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式是回调机制的面向对象替代品，目的是解耦调用者和接收者。做法是在调用者和接收者之间放一个Command对象，让它实现execute接口，调用接受者自己的方法执行所需的操作，这样调用者无需了解接收者的接口，不同的接收者也可以适应不同的Command子类。</p>
<p>在 Python 中使用函数或可调用对象实现回调更自然，可以不用为调用者提供一个Command实例，而是给它一个函数，调用者不用调用command.execute()，直接调用command()即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, commands)</span>:</span></span><br><span class="line">        self.commands = commands</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">            command()</span><br></pre></td></tr></table></figure>
<h1 id="函数装饰器和闭包"><a href="#函数装饰器和闭包" class="headerlink" title="函数装饰器和闭包"></a>函数装饰器和闭包</h1><h2 id="装饰器基础"><a href="#装饰器基础" class="headerlink" title="装饰器基础"></a>装饰器基础</h2><p>装饰器是可调用对象，参数是被装饰的函数。可以把它替换掉也可以原样返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'running inner'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target'</span>)</span><br><span class="line"></span><br><span class="line">print(target)  <span class="comment"># &lt;function decorate.&lt;locals&gt;.inner at ...&gt;</span></span><br></pre></td></tr></table></figure>
<p>装饰器只是语法糖：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以转换为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">target = decorate(target()</span><br></pre></td></tr></table></figure>
<h2 id="装饰器的执行时机"><a href="#装饰器的执行时机" class="headerlink" title="装饰器的执行时机"></a>装饰器的执行时机</h2><p>装饰器在被装饰的函数定义之后立即执行，这通常是在导入时（即Python加载模块时）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reister</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running reister &#123;&#125;'</span>.format(func))</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@reister</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main'</span>)</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running reister &lt;function f1 at ...&gt;</span><br><span class="line">running main</span><br><span class="line">running f1</span><br></pre></td></tr></table></figure>
<p>装饰器在真实代码中的常用方式：</p>
<ul>
<li>装饰器通常定义在一个模块中，然后应用到其他模块中的函数上。</li>
<li>大多数装饰器会在内部定义一个函数，然后将其返回。也可能原样返回，比如很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处。比如上面的例子中，使用促销装饰器把所有促销注册起来，供best_promo使用。</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)   </span><br><span class="line">    b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>会报错local variable ‘b’ referenced before assignment，Python判断b是局部变量，运行时从本地环境中获取，但是还未定义，所以报错。通过dis查看操作b的字节码为LOAD_GLOBAL。</p>
<p>改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b   <span class="comment">#让解释器把b当成全局变量</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">print(b)    <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p>不再报错，读取和修改的都是全局变量。通过dis查看操作b的字节码为LOAD_FAST。<br>CPython VM是栈机器，LOAD和POP操作引用的是栈。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包指延伸了作用域的函数， 它能访问定义体之外定义的非全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"></span><br><span class="line">print(avg(<span class="number">10</span>))</span><br><span class="line">print(avg(<span class="number">22</span>))</span><br></pre></td></tr></table></figure>
<p>在 averager 中， series 是自由变量（free variable， 指未在本地作用域中绑定的变量）。</p>
<p><img src="/images/python/fluent_python/闭包.png" alt="闭包"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(avg.__code__.co_varnames)   <span class="comment"># 局部变量</span></span><br><span class="line">print(avg.__code__.co_freevars)   <span class="comment"># 自由变量</span></span><br><span class="line">print(avg.__closure__)   <span class="comment"># 一个元组 (&lt;cell at 0x0000028489CDA4C8: list object at ...&gt;,)</span></span><br><span class="line">print(avg.__closure__[<span class="number">0</span>].cell_contents   <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="nonlocal-声明"><a href="#nonlocal-声明" class="headerlink" title="nonlocal 声明"></a>nonlocal 声明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total   <span class="comment"># python3的关键字，python2中通过赋值给可变对象（如字典）的属性来实现。不加这一句下面将会报错，因为相当于声明了局部变量的count 。count = count + 1。在读取count时报错</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line">print(avg(<span class="number">1</span>))</span><br><span class="line">print(avg(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h2 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">','</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'</span>.format(elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(factorial.__name__)  <span class="comment"># clocked。factorial已经被替换为clocked函数，__name__属性被覆盖</span></span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">40</span>, <span class="string">'Calling snooze(.123)'</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">40</span>, <span class="string">'Calling factorial(6)'</span>)</span><br><span class="line">    factorial(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>使用functools.wraps装饰器解决<strong>name</strong>覆盖的问题：</p>
<p>functools.wraps 装饰器会把相关的属性从 func 复制到 clocked 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span>   <span class="comment"># 支持关键字参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'&#123;&#125;=&#123;&#125;'</span>.format(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line"></span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'</span>.format(elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
<h2 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h2><p>functools.lru_cache：</p>
<p>lru，即“Least Recently Used”。</p>
<p>它把耗时的函数的结果保存起来， 避免相同的参数重复计算。缓存不会无限制增长， 一段时间不用的缓存会被扔掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()   # ()调用，可传入配置参数</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p>极大的减少调用次数。</p>
<p><code>functools.lru_cache(maxsize=128, typed=False)</code></p>
<p>参数：</p>
<p>maxsize，指定存储多少个调用的结果，应该设为2的幂。</p>
<p>typed，True会把不同参数类型得到的结果区分开，比如1和1.0。</p>
<p>因为lru_cache使用字典存储结果，所以被修饰的函数，所有参数都必须是可散列的。</p>
<p>functools.singledispatch：</p>
<p>Python 不支持重载方法或函数， 所以我们不能使用不同的签名定义函数的变体， 也无法使用不同的方式处理不同的数据类型。 在Python 中， 一种常见的做法是把函数变成一个分派函数。singledispatch装饰器可以把整体方案拆分成多个模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span>   <span class="comment"># 函数名称无所谓</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(tuple)</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)  #可以叠放多个 register 装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure>
<h2 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>
<h2 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'running register(active=&#123;&#125;)-&gt;decorate(&#123;&#125;)'</span>.format(active, func))</span><br><span class="line">        registry.add(func) <span class="keyword">if</span> active <span class="keyword">else</span> registry.discard(func)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(registry)  <span class="comment"># 只有f2</span></span><br></pre></td></tr></table></figure>
<p>装饰器函数金字塔：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">()</span>:</span>    <span class="comment"># 装饰器工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>  <span class="comment"># 装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 包装被装饰的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)  <span class="comment"># 被包装的函数返回的真正结果</span></span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            <span class="comment"># pass</span></span><br><span class="line">            print(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span> _result  <span class="comment"># clocked会取代原函数，因此应该返回被装饰函数的返回值</span></span><br><span class="line">        <span class="keyword">return</span> clocked  <span class="comment"># 装饰器返回包装函数</span></span><br><span class="line">    <span class="keyword">return</span> decorate  <span class="comment"># 工厂返回一个装饰器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcname</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h1 id="对象引用、可变性和垃圾回收"><a href="#对象引用、可变性和垃圾回收" class="headerlink" title="对象引用、可变性和垃圾回收"></a>对象引用、可变性和垃圾回收</h1><h2 id="标识、相等性和别名"><a href="#标识、相等性和别名" class="headerlink" title="标识、相等性和别名"></a>标识、相等性和别名</h2><p>id()：</p>
<p>在 CPython 中， id() 返回对象的内存地址， 但是在其他 Python 解释器中可能是别的值。 关键是， ID 一定是唯一的数值标注， 而且在对象的生命周期中绝不会变。</p>
<p>==和is：</p>
<p>is运算符比==速度快，==是语法糖，等同于<code>a.__eq__(b)</code></p>
<h2 id="默认浅复制"><a href="#默认浅复制" class="headerlink" title="默认浅复制"></a>默认浅复制</h2><p>列表的内置构造函数或list[:]语句，做的都是浅复制（只复制最外层的容器，容器中的元素只复制引用）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">l2 = list(l1)</span><br><span class="line"></span><br><span class="line">l1.append(<span class="number">100</span>)   <span class="comment"># l1的容器添加一个元素</span></span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>) </span><br><span class="line">print(<span class="string">'l1:'</span>, l1)</span><br><span class="line">print(<span class="string">'l2:'</span>, l2)</span><br><span class="line"></span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>]</span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)   <span class="comment"># l2 创建了新的元组</span></span><br><span class="line">print(<span class="string">'l1:'</span>, l1)</span><br><span class="line">print(<span class="string">'l2:'</span>, l2)</span><br></pre></td></tr></table></figure>
<p>深复制和浅复制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line">copy.copy(list)   <span class="comment"># 浅复制</span></span><br><span class="line">copy.deepcopy(list)   <span class="comment"># 深复制</span></span><br></pre></td></tr></table></figure>
<h2 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h2><p>Python 唯一支持的参数传递模式是共享传参，指函数的各个形式参数获得实参中各个引用的副本。 也就是说， 函数内部的形参是实参的别名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a += b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">f(x, y)</span><br><span class="line">print(x, y)  <span class="comment"># x未改变</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">f(a, b)</span><br><span class="line">print(a, b)  <span class="comment"># a改变</span></span><br><span class="line"></span><br><span class="line">t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">f(t, u)</span><br><span class="line">print(t, u)  <span class="comment"># t未改变</span></span><br></pre></td></tr></table></figure>
<p>不要使用可变类型作为参数的默认值，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">    self.passengers = passengers</span><br></pre></td></tr></table></figure>
<p>默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象， 而且修改了它的值， 那么后续的函数调用都会受到影响。</p>
<p>默认值会储存在<code>class.__init__.__defaults__</code>的属性里（一个tuple）。</p>
<p>防御可变对象参数：</p>
<p>当参数是可变对象时，如果没有约定的情况下，最好创造一个可变参数的副本，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.passengers = list(passengers)</span><br></pre></td></tr></table></figure>
<p>这样就不会影响外部的对象了。</p>
<h2 id="del-和-垃圾回收"><a href="#del-和-垃圾回收" class="headerlink" title="del 和 垃圾回收"></a>del 和 垃圾回收</h2><p>del语句删除名称，而不是对象。仅当删除的变量保存的是对象的最后一个引用， 或者无法得到对象时，del 命令才可能导致对象被当作垃圾回收。</p>
<p>在 CPython 中， 垃圾回收使用的主要算法是引用计数。 实际上， 每个对象都会统计有多少引用指向自己。 当引用计数归零时， 对象立即就被销毁： CPython 会在对象上调用 <code>__del__</code> 方法（如果定义了），然后释放分配给对象的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Gone with the wind...'</span>)</span><br><span class="line"></span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = s1</span><br><span class="line"></span><br><span class="line">ender = weakref.finalize(s1, bye)</span><br><span class="line">print(ender.alive)  <span class="comment"># True</span></span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line">print(ender.alive)  <span class="comment"># True</span></span><br><span class="line">s2 = <span class="string">'spam'</span>         <span class="comment"># Gone..</span></span><br><span class="line">print(ender.alive)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用不会增加对象的引用数量，不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用而始终缓存对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)   <span class="comment"># 创建弱引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x0000021194B76598</span>; to <span class="string">'set'</span> at <span class="number">0x00000211969AF588</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()   <span class="comment"># 返回被引用的对象，但因为是控制台会话，所以&#123;0,1&#125;会绑定给_变量</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;   <span class="comment"># a_set 不再指代&#123;0,1&#125;集合，但是变量_仍然指代它</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="keyword">None</span>   <span class="comment"># 返回值False绑定给变量_，&#123;0,1&#125;没有强引用了</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="keyword">None</span>   <span class="comment"># &#123;0,1&#125;对象不存在了</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>weakref.ref类其实是低层接口，最好不要手动处理weakref.ref实例，而是使用weakref集合。</p>
<h1 id="符合Python风格的对象"><a href="#符合Python风格的对象" class="headerlink" title="符合Python风格的对象"></a>符合Python风格的对象</h1><h2 id="向量类"><a href="#向量类" class="headerlink" title="向量类"></a>向量类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span><span class="params">()</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)</span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> self.x</span><br><span class="line">        <span class="keyword">yield</span> self.y</span><br><span class="line">        <span class="comment"># return (i for i in (self.x, self.y))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;,&#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(str))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure>
<h2 id="classmethod与staticmethod"><a href="#classmethod与staticmethod" class="headerlink" title="classmethod与staticmethod"></a>classmethod与staticmethod</h2><p>classmethod：</p>
<p>定义操作类的方法，第一个参数是类本身，最常见的用途是定义备选构造函数</p>
<p>staticmethod：</p>
<p>静态方法就是普通函数，只是碰巧在类的定义体中，而不是在模块层定义的。完全可以不用使用它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">klassmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">statmeth</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Demo.klassmeth(<span class="number">1</span>))  <span class="comment"># (&lt;class '__main__.Demo'&gt;, 1)</span></span><br><span class="line">print(Demo.statmeth(<span class="number">1</span>))  <span class="comment"># (1,)</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><p>委托给相应的 <code>__format__(format_spec)</code> 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brl = <span class="number">1</span>/<span class="number">2.43</span></span><br><span class="line">print(brl)  <span class="comment"># 0.4115226337448559</span></span><br><span class="line">print(format(brl, <span class="string">'.4f'</span>))  <span class="comment"># 0.4115</span></span><br><span class="line">print(<span class="string">'1 BRL = &#123;rate:.2f&#125; USD'</span>.format(rate=brl))  <span class="comment"># 1 BRL = 0.41 USD</span></span><br></pre></td></tr></table></figure>
<p>rate是字段名，.4f是格式规范微语言。</p>
<p>整数使用的代码有 ‘bcdoxXn’， 浮点数使用的代码有’eEfFgGn%’， 字符串使用的代码有 ‘s’。</p>
<p>格式规范微语言文档（<a href="https://docs.python.org/3/library/string.html#formatspec）" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html#formatspec）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(format(<span class="number">42</span>, <span class="string">'b'</span>))  <span class="comment"># b二进制 o八进制 x十六进制</span></span><br><span class="line">print(format(<span class="number">2</span>/<span class="number">3</span>, <span class="string">'.1%'</span>))  <span class="comment"># 66.7%</span></span><br></pre></td></tr></table></figure>
<p>如果没有定义<code>__format__</code>方法，从object继承的方法会返回str(obj)。</p>
<p><code>print(format(v)) # (2.0, 3.0)</code></p>
<p>但是如果传入格式说明符，object.<strong>format</strong>方法会抛出TypeError。</p>
<p><code>print(format(v,&#39;.2f))  # TypeError</code></p>
<p>给Vector2d定义<code>__format__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">     compoments = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> self)</span><br><span class="line">     <span class="keyword">return</span> <span class="string">'(&#123;&#125;,&#123;&#125;)'</span>.format(*compoments)</span><br><span class="line"></span><br><span class="line">print(format(v, <span class="string">'.2f'</span>))  <span class="comment"># (2.00,3.00)</span></span><br></pre></td></tr></table></figure>
<p>自定义格式代码：</p>
<p>假设我们自定义的代码为p，用来显示极坐标中的向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, fmt_spec=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> fmt_spec.endswith(<span class="string">'p'</span>):</span><br><span class="line">        fmt_spec = fmt_spec[:<span class="number">-1</span>]</span><br><span class="line">        coords = (abs(self), self.angle())</span><br><span class="line">        outer_fmt = <span class="string">'&lt;&#123;&#125;,&#123;&#125;&gt;'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        coords = self</span><br><span class="line">        outer_fmt = <span class="string">'(&#123;&#125;,&#123;&#125;)'</span></span><br><span class="line">    compoments = (format(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">    <span class="keyword">return</span> outer_fmt.format(*compoments)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(format(v, <span class="string">'p'</span>))  <span class="comment"># &lt;3.605551275463989,0.982793723247329&gt;</span></span><br><span class="line"></span><br><span class="line">print(format(v, <span class="string">'.5fp'</span>))  <span class="comment"># &lt;3.60555,0.98279&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="可散列的Vector2d"><a href="#可散列的Vector2d" class="headerlink" title="可散列的Vector2d"></a>可散列的Vector2d</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># other code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = float(x)  <span class="comment"># 使用两个__把属性"标记"为私有的</span></span><br><span class="line">    self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">@property  # 把读值方法标记为特性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span>  <span class="comment"># 方法名即公开属性名</span></span><br><span class="line">    <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)  <span class="comment"># 最好使用位运算符异或(^)混合各分量的散列值</span></span><br></pre></td></tr></table></figure>
<p>让这些向量不可变是有原因的， 因为这样才能实现<strong>hash</strong> 方法。</p>
<h2 id="私有属性和“受保护”的属性"><a href="#私有属性和“受保护”的属性" class="headerlink" title="私有属性和“受保护”的属性"></a>私有属性和“受保护”的属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    self.__x = float(x)</span><br></pre></td></tr></table></figure>
<p>使用两个_作为前缀命名实例属性，Python会把属性名存入实例的<strong>dict</strong>属性中，而且会进行“名称改写”，如<strong>prop会被改写成_ClassName</strong>prop。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(v.__dict__)  <span class="comment"># &#123;'_Vector2d__x': 3.0, '_Vector2d__y': 4.0&#125;，__dict__为实例的可读属性的键值字典</span></span><br><span class="line">print(v.__dir__())  <span class="comment"># __dir__()方法返回实例和类的所有属性名和方法名的list</span></span><br></pre></td></tr></table></figure>
<p>也有人不喜欢这种不对称的名称，他们约定使用一个_前缀编写“受保护”的属性，如self._x。Python不会对这种属性名做特殊处理，这仅仅是程序员之间遵守的约定，他们不会在类外部访问这种属性。</p>
<h2 id="使用slots类属性节省空间"><a href="#使用slots类属性节省空间" class="headerlink" title="使用slots类属性节省空间"></a>使用<strong>slots</strong>类属性节省空间</h2><p>创建一个类属性，使用 <code>__slots__</code> 这个名字， 并把它的值设为一个字符串构成的可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br></pre></td></tr></table></figure>
<p>作用是告诉解释器，这个类中的所有实例属性都在这儿了！</p>
<p>Python会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的<strong>dict</strong>属性。当同时有数百万个实例活动时，能节省大量内存。</p>
<p>副作用是定义了<strong>slots</strong>属性之后，实例不能再有<strong>slots</strong> 中所列名称之外的其他属性。 但故意这样禁止用户新增属性是不对的。</p>
<p>如果定义了<strong>slots</strong>属性，且想让对象支持弱引用，则必须把<strong>weakref</strong>添加到<strong>slots</strong>中。</p>
<p>解释器会忽略继承的<strong>slots</strong>属性，所以每个子类都要定义<strong>slots</strong>属性。</p>
<h2 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span><span class="params">()</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">v = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(v.typecode)   <span class="comment"># d</span></span><br><span class="line">v.typecode = <span class="string">'f'</span></span><br><span class="line">print(v.typecode)   <span class="comment"># f</span></span><br></pre></td></tr></table></figure>
<p>类属性为实例属性提供默认值，但是并不代表实例拥有此实例，如果为类属性赋值，类属性不会受影响，实例会创建同名的属性覆盖掉类属性。想要修改类属性，需要直接在类上修改，<code>Vector2d.typecode = &#39;f&#39;</code>。</p>
<h1 id="序列的修改、散列和切片"><a href="#序列的修改、散列和切片" class="headerlink" title="序列的修改、散列和切片"></a>序列的修改、散列和切片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">'['</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) +</span><br><span class="line">                bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure>
<p>reprlib.repr() 函数获取 self._components 的有限长度表示形式（如 array(‘d’, [0.0, 1.0, 2.0, 3.0, 4.0, …])） 。</p>
<h2 id="协议和鸭子类型"><a href="#协议和鸭子类型" class="headerlink" title="协议和鸭子类型"></a>协议和鸭子类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self._components)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._components[index]</span><br></pre></td></tr></table></figure>
<p>协议是非正式的接口， 只在文档中定义， 在代码中不定义。 </p>
<p>例如， Python 的序列协议只需要 <code>__len__</code> 和 <code>__getitem__</code> 两个方法。 任何类（如 Spam）只要实现了这两个方法， 就能用在任何期待序列的地方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(v[<span class="number">1</span>:<span class="number">2</span>])   <span class="comment">#   array('d', [2.0])</span></span><br></pre></td></tr></table></figure>
<h2 id="可切片的序列"><a href="#可切片的序列" class="headerlink" title="可切片的序列"></a>可切片的序列</h2><h3 id="切片原理"><a href="#切片原理" class="headerlink" title="切片原理"></a>切片原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">s = MySeq()</span><br><span class="line">print(s[<span class="number">1</span>])  <span class="comment"># 1</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">2</span>])  <span class="comment"># slice(1, 2, None)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>])  <span class="comment"># slice(1, 2, 3)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># (slice(1, 2, 3), 4)。多维切片，__getitem__收到的是元组</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">5</span>])  <span class="comment"># (slice(1, 2, 3), slice(4, 5, None))</span></span><br></pre></td></tr></table></figure>
<p>slice.indices方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(slice(<span class="keyword">None</span>, <span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># slice(None, 10, 2)</span></span><br><span class="line">print(slice(<span class="keyword">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>))  <span class="comment"># (0, 5, 2)</span></span><br><span class="line">print(slice(<span class="number">-3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>).indices(<span class="number">5</span>))  <span class="comment"># (2, 5, 1)</span></span><br></pre></td></tr></table></figure>
<p>indices方法提供了内置序列实现的复杂“整顿”逻辑，用于优雅地处理索引缺失、负数、长度过长等情况。如果自定义的<strong>getitem</strong>最终不是依靠的底层序列，那么可以使用这个方法节省大量时间。</p>
<h3 id="自定义切片的getitem"><a href="#自定义切片的getitem" class="headerlink" title="自定义切片的getitem"></a>自定义切片的<strong>getitem</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    cls = type(self)</span><br><span class="line">    <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">        <span class="keyword">return</span> cls(self._components[index])   <span class="comment">#   返回当前类型的切片，而不是委托给数组返回一个数组的切片</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">        <span class="keyword">return</span> self._components[index]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg = <span class="string">'&#123;cls.__name__&#125; indices must be integers'</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</span><br><span class="line"></span><br><span class="line">s = Vector(range(<span class="number">100</span>))</span><br><span class="line">print(type(s[<span class="number">1</span>]))  <span class="comment"># Vector</span></span><br><span class="line">print(type(s[<span class="number">1</span>:<span class="number">10</span>]))  <span class="comment"># Vector</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">10</span>, <span class="number">2</span>])  <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure>
<h2 id="动态存取属性"><a href="#动态存取属性" class="headerlink" title="动态存取属性"></a>动态存取属性</h2><p>使用x、y、z、t来取代v[0]，v[1]，v[2]，v[3]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    cls = type(self)</span><br><span class="line">    <span class="keyword">if</span> len(name) == <span class="number">1</span>:</span><br><span class="line">        pos = cls.shortcut_names.find(name)</span><br><span class="line">        <span class="keyword">if</span> len(self._components) &gt; pos &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self._components[pos]</span><br><span class="line">    <span class="comment"># .__name__会从cls中取值，!r以文本形式''</span></span><br><span class="line">    msg = <span class="string">'&#123;.__name__!r&#125; objects has no attribute &#123;!r&#125;'</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br></pre></td></tr></table></figure>
<p>为了防止直接向v.x赋值而创建一个新的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    cls = type(self)</span><br><span class="line">    <span class="keyword">if</span> len(name)=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_names:</span><br><span class="line">            error = <span class="string">'readonly attribute &#123;attr_name!r&#125;'</span></span><br><span class="line">        <span class="keyword">elif</span> name.islower():</span><br><span class="line">            error = <span class="string">"can't set attribute 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> error:</span><br><span class="line">            msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">    super().__setattr__(name, value)  <span class="comment"># 在超类上调用 __setattr__ 方法， 提供标准行为</span></span><br></pre></td></tr></table></figure>
<h2 id="散列和快速等值测试"><a href="#散列和快速等值测试" class="headerlink" title="散列和快速等值测试"></a>散列和快速等值测试</h2><p>规约函数reduce,sum,any,all把序列或有限可迭代对象编程一个聚合结果。reduce函数的参数，第一个函数是接受两个参数的函数，第二个参数是一个可迭代的对象，第三个参数是初始值。</p>
<p>reduce(fn,lst)：</p>
<p><code>fn(lst[0],lst[1]) -&gt; r1</code><br><code>fn(r1,lst[2]) -&gt; r2</code><br><code>fn(r2,lst[3]) -&gt; r3</code><br><code>...</code></p>
<p>实现阶乘的三种方式：</p>
<p>1. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    n ^= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2. </p>
<p><code>functools.reduce(lambda a, b: a ^ b, range(6))</code></p>
<p>3.  </p>
<p><code>functools.reduce(operator.xor, range(6))</code></p>
<p>把Vector变成可散列的对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    hashes = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)</span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.xor, hashes, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>修改 <code>__eq__</code> 方法：</p>
<ul>
<li><p>使用zip函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other):</span><br><span class="line">        <span class="keyword">if</span> a != b:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用all函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>出色的zip函数：</p>
<p>zip函数能并行迭代两个或多个可迭代对象，它返回的元组可以拆包成变量，分别对应各个并行输入中的一个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"></span><br><span class="line">print(zip(range(<span class="number">3</span>), <span class="string">'ABC'</span>))  <span class="comment"># &lt;zip object at ...&gt;</span></span><br><span class="line">print(list(zip(range(<span class="number">3</span>), <span class="string">'ABC'</span>)))  <span class="comment"># [(0, 'A'), (1, 'B'), (2, 'C')]</span></span><br><span class="line"><span class="comment"># [(0, 'A', 1), (1, 'B', 2), (2, 'C', 3), (-1, -1, 4)]</span></span><br><span class="line">print(list(zip_longest(range(<span class="number">3</span>), <span class="string">'ABC'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], fillvalue=<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>
<p>itertools.chain函数：合并两个序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">t1 = (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">r1 = itertools.chain(l1,t1)</span><br><span class="line">print(r1)   <span class="comment">#&lt;itertools.chain object at ...&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="接口：从协议到抽象基类"><a href="#接口：从协议到抽象基类" class="headerlink" title="接口：从协议到抽象基类"></a>接口：从协议到抽象基类</h1><h2 id="接口和协议"><a href="#接口和协议" class="headerlink" title="接口和协议"></a>接口和协议</h2><p>协议：非正式的接口，不能像正式接口那样施加限制，是Python实现多态的方式。一个类可依只实现部分接口，这是允许的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>)[pos]</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">f[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f: print(i)</span><br></pre></td></tr></table></figure>
<p>Foo类没有继承abc.Sequence，只实现了序列协议的一个方法：<code>__getitem__</code>，没有<code>__iter__</code>方法，但是仍然会后备使用<code>__getitem__</code>来进行迭代。没有实现<code>__contains__</code>方法，但是也能使用in运算。</p>
<h2 id="使用猴子补丁在运行时实现协议"><a href="#使用猴子补丁在运行时实现协议" class="headerlink" title="使用猴子补丁在运行时实现协议"></a>使用猴子补丁在运行时实现协议</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> french_deck <span class="keyword">import</span> FrenchDeck</span><br><span class="line"></span><br><span class="line">f = FrenchDeck()</span><br><span class="line"><span class="comment"># 就地打乱, TypeError: 'FrenchDeck' object does not support item assignment</span></span><br><span class="line">random.shuffle(f)</span><br></pre></td></tr></table></figure>
<p>我们可以动态修正这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(self, position, card)</span>:</span></span><br><span class="line">    self._cards[position] = card</span><br><span class="line"></span><br><span class="line">FrenchDeck.__setitem__ = set_card</span><br><span class="line">random.shuffle(f)</span><br></pre></td></tr></table></figure>
<p>猴子补丁： 在运行时修改类或模块， 而不改动源码。 猴子补丁很强大， 但是打补丁的代码与要打补丁的程序耦合十分紧密， 而且往往要处理隐藏和没有文档的部分</p>
<h2 id="标准库中的抽象基类"><a href="#标准库中的抽象基类" class="headerlink" title="标准库中的抽象基类"></a>标准库中的抽象基类</h2><h3 id="collections-abc模块中的抽象基类"><a href="#collections-abc模块中的抽象基类" class="headerlink" title="collections.abc模块中的抽象基类"></a>collections.abc模块中的抽象基类</h3><p>collections.abc：</p>
<p><img src="/images/python/fluent_python/collections.abc.png" alt="collections.abc"></p>
<p>Iterable、 Container 和 Sized：</p>
<p>各个集合应该继承这三个抽象基类， 或者至少实现兼容的协议。 Iterable 通过 <code>__iter__</code> 方法支持迭代， Container 通过<code>__contains__</code> 方法支持 in 运算符， Sized 通过 <code>__len__</code> 方法支持len() 函数。</p>
<p>Sequence、 Mapping 和 Set：</p>
<p>这三个是主要的不可变集合类型， 而且各自都有可变的子类。</p>
<p>MappingView：</p>
<p>映射方法 .items()、 .keys() 和 .values() 返回的对象分别是 ItemsView、 KeysView 和 ValuesView 的实例。 前两个类还继承了 Set 类</p>
<p>Callable 和 Hashable：</p>
<p>没有Callable 或 Hashable 的子类。 这两个抽象基类的主要作用是为内置函数 isinstance 提供支持， 以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用， 可以使用内置的 callable() 函数； 但是没有类似的 hashable() 函数， 因此测试对象是否可散列， 最好使用 isinstance(my_obj, Hashable)。</p>
<h3 id="抽象基类的数字塔"><a href="#抽象基类的数字塔" class="headerlink" title="抽象基类的数字塔"></a>抽象基类的数字塔</h3><p>numbers包定义的抽象基类是线性的层次结构，依次往下是，Number、Complex、Real、Rational、Integral。</p>
<p>检查是否为整数，isinstance(x,numbers.Integral)。</p>
<h2 id="定义使用一个抽象基类"><a href="#定义使用一个抽象基类" class="headerlink" title="定义使用一个抽象基类"></a>定义使用一个抽象基类</h2><p>定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span> <span class="comment">#自己定义的抽象基类要继承 abc.ABC。</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        <span class="string">"""从可迭代对象中添加元素。 """</span> <span class="comment">#抽象方法使用 @abstractmethod 装饰器标记， 而且定义体中通常只有文档字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""随机删除元素， 然后将其返回。</span></span><br><span class="line"><span class="string">        如果实例为空， 这个方法应该抛出`LookupError`。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>   <span class="comment">#抽象基类可以包含具体方法</span></span><br><span class="line">        <span class="string">"""如果至少有一个元素， 返回`True`， 否则返回`False`。 """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.inspect())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个有序元组， 由当前元素构成。 """</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)    <span class="comment">#抽象基类中的具体方法可以依赖抽象基类中的其他具体方法、 抽象方法或特性</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure>
<p>错误的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fake</span><span class="params">(Tombola)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f = Fake()  <span class="comment"># TypeError: Can't instantiate abstract class Fake with abstract methods load, pick</span></span><br></pre></td></tr></table></figure>
<p>正确的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  random</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._randomizer = random.SystemRandom()</span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._items.extend(items)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pick()</span><br></pre></td></tr></table></figure>
<p>虚拟子类：</p>
<p>在抽象基类上调用register方法，issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。Python也不会做检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tombola.register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self:</span><br><span class="line">            position = randrange(len(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</span><br><span class="line">    </span><br><span class="line">    load = list.extend</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self))</span><br></pre></td></tr></table></figure>
<p>虚拟子类检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tombola <span class="keyword">import</span> Tombola</span><br><span class="line"><span class="keyword">from</span> tombolist <span class="keyword">import</span> TomboList</span><br><span class="line"></span><br><span class="line">print(issubclass(TomboList, Tombola))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">t = TomboList(range(<span class="number">100</span>))</span><br><span class="line">print(isinstance(t, Tombola))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p><code>__mro__</code>属性：方法解析顺序，按顺序列出类及其超类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line">print(TomboList.__mro__)</span><br><span class="line">print(Tombola)  <span class="comment"># &lt;class 'tombola.Tombola'&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Tombolist.__mro__</code> 中没有 Tombola， 因此 Tombolist 没有从Tombola 中继承任何方法。</p>
<p>继承内省属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __subclasses__()，这个方法返回类的直接子类列表， 不含虚拟子类。</span></span><br><span class="line">print(Tombola.__subclasses__())  <span class="comment"># [&lt;class 'bingo.BingoCage'&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _abc_registry，只有抽象基类有这个数据属性， 其值是一个 WeakSet 对象， 即抽象类注册的虚拟子类的弱引用。</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> Tombola._abc_registry])  <span class="comment"># [&lt;class 'tombolist.TomboList'&gt;]</span></span><br></pre></td></tr></table></figure>
<h2 id="使用register"><a href="#使用register" class="headerlink" title="使用register"></a>使用register</h2><p>Tombola.register可以当做类装饰器使用，也可以当做函数调用Tombola.register(TomboList)。<br>这种做法更常见，可用于注册其他地方定义的类，例如，在collections.abc模块的源码中，<br><code>Sequence.register(tuple)</code><br><code>Sequence.register(str)</code><br><code>Sequence.register(range)</code><br><code>Sequence.register(memoryview)</code></p>
<p><code>__subclasshook__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Struggle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"></span><br><span class="line">print(issubclass(Struggle, abc.Sized))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(Struggle(), abc.Sized))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>没有注册和继承，抽象基类也能把一个类识别为虚拟子类，因为abc.Sized实现了一个特殊的类方法，名为<code>__subclasshook__</code>。源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__len__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):  <span class="comment"># C及其超类__dict__属性里是否有__len__属性</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>
<h1 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h1><h2 id="子类化内置类型很麻烦"><a href="#子类化内置类型很麻烦" class="headerlink" title="子类化内置类型很麻烦"></a>子类化内置类型很麻烦</h2><p>直接子类化内置类型（如 dict、 list 或 str） 容易出错，因为内置类型的方法通常会忽略用户覆盖的方法（这种问题只发生在C语言实现的内置类型内部的方法委托上，而且只影响直接继承内置类型的用户自定义类）。 </p>
<p>不要子类化内置类型， 用户自己定义的类应该继承 collections 模块（<a href="http://docs.python.org/3/library/collections.html）" target="_blank" rel="noopener">http://docs.python.org/3/library/collections.html）</a> 中的类， 例如UserDict、 UserList 和 UserString， 这些类做了特殊设计， 因此易于扩展。</p>
<h2 id="多重继承和方法解析顺序"><a href="#多重继承和方法解析顺序" class="headerlink" title="多重继承和方法解析顺序"></a>多重继承和方法解析顺序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'ping:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'pong:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'PONG:'</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span>   <span class="comment"># 声明中超类的顺序影响方法解析顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()print(<span class="string">'post-ping:'</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)</span><br></pre></td></tr></table></figure>
<p>Python能区分子类调用的是哪个父类的方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order， MRO）。类都有一个名为<code>__mro__</code>的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D.__mro__   <span class="comment"># (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></span><br></pre></td></tr></table></figure>
<p>也可以在子类中绕过方法解析顺序，直接调用某个超类的方法，比如，A.ping(self)，而不是super().ping()。</p>
<h1 id="正确重载运算符"><a href="#正确重载运算符" class="headerlink" title="正确重载运算符"></a>正确重载运算符</h1><p>略</p>
<h1 id="可迭代的对象、迭代器和生成器"><a href="#可迭代的对象、迭代器和生成器" class="headerlink" title="可迭代的对象、迭代器和生成器"></a>可迭代的对象、迭代器和生成器</h1><h2 id="单词序列"><a href="#单词序列" class="headerlink" title="单词序列"></a>单词序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.words)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Sentence(&#123;&#125;)'</span>.format(reprlib.repr(self.text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sentence <span class="keyword">import</span> Sentence</span><br><span class="line"></span><br><span class="line">s = Sentence(<span class="string">'"The time has come," the Walrus said,'</span>)</span><br><span class="line"></span><br><span class="line">print(s)  <span class="comment"># Sentence('"The time ha... Walrus said,')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> s:</span><br><span class="line">    print(word)  <span class="comment"># 可以迭代</span></span><br><span class="line"></span><br><span class="line">print(list(s))</span><br></pre></td></tr></table></figure>
<p>可以迭代的原因：</p>
<p><img src="/images/python/fluent_python/iter.png" alt="iter"></p>
<p>从 Python 3.4 开始， 检查对象 x 能否迭代， 最准确的方法是：调用 iter(x) 函数(或直接进行迭代)， 如果不可迭代， 再处理 TypeError 异常。 这比使用 isinstance(x, abc.Iterable) 更准确， 因为 iter(x)函数会考虑到遗留的 <code>__getitem__</code> 方法， 而 abc.Iterable 类则不考虑。</p>
<h2 id="可迭代的对象与迭代器的对比"><a href="#可迭代的对象与迭代器的对比" class="headerlink" title="可迭代的对象与迭代器的对比"></a>可迭代的对象与迭代器的对比</h2><p>使用 iter 内置函数可以获取迭代器的对象。 如果对象实现了能返回迭代器的 <code>__iter__</code> 方法， 那么对象就是可迭代的。</p>
<p>可迭代的对象和迭代器之间的关系： Python 从可迭代的对象中获取迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'ABC'</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<p>字符串’ABC’是可迭代的对象，背后运行的是迭代器。</p>
<p>不使用for语句的话，就需要使用while和iter组合迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'ABC'</span></span><br><span class="line"></span><br><span class="line">it = iter(s)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))</span><br><span class="line">        <span class="comment">#或 print(it.__next__())</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:  <span class="comment"># 如果没有下一个元素，抛出StopIteration</span></span><br><span class="line">        <span class="keyword">del</span> it   <span class="comment"># 释放引用，废弃迭代器对象</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>标准的迭代器接口有两个方法：</p>
<p><code>__next__</code>，返回下一个可用元素或无元素时抛出StopIteration异常。</p>
<p><code>__iter__</code>，返回self，以便在应该使用可迭代对象的地方使用迭代器，例如在for循环中。</p>
<p>collections.abc.Iterator抽象基类中定义了<code>__next__</code>抽象方法。且这个抽象基类继承自collections.abc.Iterable类，这个类中定义了<code>__iter__</code>抽象方法。</p>
<p><img src="/images/python/fluent_python/iterable.png" alt="iterable"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i1 = id(s.__iter__())   <span class="comment"># 返回字符串的迭代器</span></span><br><span class="line">i2 = id(s.__iter__().__iter__())   <span class="comment"># 迭代器返回自身</span></span><br><span class="line">print(i1 == i2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>Python中的迭代器是一种协议，而不是某种特定的类型。所以判断一个对象x(或类)是否为迭代器最好的方式是调用isinstance(x, abc.Iterator)(或issubclass)，得益于<code>Iterator.__subclasshook__</code> 方法， 即使对象 x 所属的类不是Iterator 类的真实子类或虚拟子类， 也能这样检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(issubclass(X, collections.abc.Iterator)) <span class="comment">#True，因为实现了__iter__和__next__协议</span></span><br><span class="line">print(isinstance(X(), collections.abc.Iterable)) <span class="comment">#True，因为事先了__iter__协议</span></span><br></pre></td></tr></table></figure>
<p>迭代器的定义：</p>
<p>迭代器是这样的对象： 实现了无参数的 <code>__next__</code> 方法， 返回序列中的下一个元素； 如果没有元素了， 那么抛出 StopIteration 异常。Python 中的迭代器还实现了 <code>__iter__</code> 方法， 因此迭代器也可以迭代。</p>
<h2 id="典型的迭代器"><a href="#典型的迭代器" class="headerlink" title="典型的迭代器"></a>典型的迭代器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<p>为了“支持多种遍历”， 必须能从同一个可迭代的实例中获取多个独立的迭代器， 而且各个迭代器要能维护自身的内部状态， 因此这一模式正确的实现方式是， 每次调用 iter(my_iterable) 都新建一个独立的迭代器。 这就是为什么这个示例需要定义SentenceIterator 类。</p>
<p>可迭代的对象一定不能是自身的迭代器。 也就是说， 可迭代的对象必须实现 <code>__iter__</code> 方法， 但不能实现 <code>__next__</code> 方法。另一方面， 迭代器应该一直可以迭。 迭代器的 <code>__iter__</code> 方法应该返回自身。</p>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>实现相同功能， 但却符合 Python 习惯的方式是， 用生成器函数代替SentenceIterator 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word   <span class="comment"># 产出当前的word</span></span><br><span class="line">        <span class="keyword">return</span>   <span class="comment">#  可以不写，会触发生成器对象抛出 StopIteration 异常</span></span><br></pre></td></tr></table></figure>
<p>生成器函数：只要 Python 函数的定义体中有 yield 关键字， 该函数就是生成器函数。 调用生成器函数时， 会返回一个生成器对象。 也就是说， 生成器函数是生成器工厂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">g = gen_123()  <span class="comment"># 通过生成器函数创建一个新的生成器</span></span><br><span class="line">print(g)  <span class="comment"># &lt;generator object gen_123 at ...&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:  <span class="comment"># 迭代生成器时，执行函数到定义体中的下一个yield语句暂停住，返回产出的值</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'A'</span></span><br><span class="line">    print(<span class="string">'continue'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'B'</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen_AB():</span><br><span class="line">    print(<span class="string">'for:'</span>,i)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line"><span class="keyword">for</span>: A</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span>: B  <span class="comment"># 执行了两次for循环中的语句</span></span><br><span class="line">end   <span class="comment"># 生成器前进到了生成器函数的末尾，但是没有产出返回值(yield关键字)，生成器对象抛出 StopIteration 异常。 for机制会捕获异常， 因此循环终止时没有报错。</span></span><br></pre></td></tr></table></figure>
<h2 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># finditer函数构建一个迭代器,包含self.text中匹配RE_WORD的单词,产出MatchObject实例。</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># match.group()方法从MatchObject实例中提取匹配正则表达式的具体文本。</span></span><br></pre></td></tr></table></figure>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式可以理解为列表推导的惰性版本： 不会迫切地构建列表，而是返回一个生成器， 按需惰性生成元素。 如果说列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br></pre></td></tr></table></figure>
<p>这里不再是生成器函数了(没有yield)，而是使用生成器表达式构建生成器，然后将其返回。</p>
<p>生成器表达式是语法糖： 完全可以替换成生成器函数。</p>
<h2 id="何时使用生成器表达式"><a href="#何时使用生成器表达式" class="headerlink" title="何时使用生成器表达式"></a>何时使用生成器表达式</h2><p>如果生成器表达式要分成多行写，就使用生成器函数，更灵活，提高可读性，可重用，且可以作为协程使用。</p>
<p>如果函数或构造函数只有一个参数，传入的生成器表达式不用自带一对括号了，只要有一对函数的括号就行了。</p>
<h2 id="等差数列生成器"><a href="#等差数列生成器" class="headerlink" title="等差数列生成器"></a>等差数列生成器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(begin + step)(begin)  <span class="comment"># 转换类型</span></span><br><span class="line">    forever = end <span class="keyword">is</span> <span class="keyword">None</span>  <span class="comment"># 无穷</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; end:</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        result = begin + step * index   <span class="comment"># 没有不断的累加step的值，为了降低处理浮点数时累积效应致错的风险</span></span><br><span class="line"></span><br><span class="line">i = aritprog_gen(<span class="number">0</span>, <span class="number">1.5</span>)</span><br><span class="line">print(next(i))</span><br><span class="line">print(next(i))</span><br><span class="line"><span class="meta">... </span>  <span class="comment"># 可以无穷迭代</span></span><br></pre></td></tr></table></figure>
<p>itertools模块生成等差数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen = itertools.count(<span class="number">0</span>, <span class="number">1.5</span>)</span><br><span class="line">print(next(gen))</span><br><span class="line">print(next(gen))</span><br></pre></td></tr></table></figure>
<p>itertools.count函数生成无穷等差数列，作用与上面的函数相同。</p>
<p>itertools.takewhile函数会生成一个使用另一个生成器的生成器， 在指定的条件计算结果为 False 时停止。 因此， 可以把这两个函数结合在一起使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">5</span>, itertools.count(<span class="number">0</span>, <span class="number">1.5</span>))   <span class="comment"># n是每次返回的产出值</span></span><br><span class="line">[print(g) <span class="keyword">for</span> g <span class="keyword">in</span> gen]</span><br></pre></td></tr></table></figure>
<p>重写aritprog_gen函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aritprog_gen</span><span class="params">(begin, step, end=None)</span>:</span></span><br><span class="line">    result = type(begin + step)(begin)</span><br><span class="line">    gen = itertools.count(begin, step)</span><br><span class="line">    <span class="keyword">while</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; end, gen)</span><br><span class="line">    <span class="keyword">return</span> gen</span><br></pre></td></tr></table></figure>
<h2 id="标准库中的生成器函数"><a href="#标准库中的生成器函数" class="headerlink" title="标准库中的生成器函数"></a>标准库中的生成器函数</h2><p>用于“过滤”的生成器函数：</p>
<p><img src="/images/python/fluent_python/过滤生成器.png" alt="过滤生成器"></p>
<p>代码演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Aardvark'</span></span><br><span class="line">print(list(filter(vowel, s)))  <span class="comment"># ['A', 'a', 'a']</span></span><br><span class="line">print(list(itertools.filterfalse(vowel, s)))  <span class="comment"># ['r', 'd', 'v', 'r', 'k']</span></span><br><span class="line"></span><br><span class="line">print(list(itertools.dropwhile(vowel, s)))  <span class="comment"># ['r', 'd', 'v', 'a', 'r', 'k']</span></span><br><span class="line">print(list(itertools.takewhile(vowel, s)))  <span class="comment"># ['A', 'a']</span></span><br><span class="line"></span><br><span class="line">print(list(itertools.compress(s, (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))))  <span class="comment"># ['A', 'r', 'd', 'a']</span></span><br><span class="line">print(list(itertools.islice(s, <span class="number">4</span>)))  <span class="comment"># ['A', 'a', 'r', 'd']</span></span><br><span class="line">print(list(itertools.islice(s, <span class="number">4</span>, <span class="number">7</span>)))  <span class="comment"># ['v', 'a', 'r']</span></span><br><span class="line">print(list(itertools.islice(s, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>)))  <span class="comment"># ['a', 'd', 'a']</span></span><br></pre></td></tr></table></figure>
<p>takewhile和filter的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> e &lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">i = itertools.takewhile(condition, itertools.count(<span class="number">0</span>, <span class="number">2</span>))   <span class="comment"># [0, 2, 4]  达成条件则停止迭代</span></span><br><span class="line">i2 = filter(condition, itertools.count(<span class="number">0</span>, <span class="number">1.5</span>))  <span class="comment"># 会卡死，应用到可迭代对象的所有元素，决定是否返回</span></span><br></pre></td></tr></table></figure>
<p>用于”映射”的生成器函数：</p>
<p><img src="/images/python/fluent_python/映射生成器.png" alt="映射生成器"></p>
<p>代码演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">sample = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">print(list(itertools.accumulate(sample)))  <span class="comment"># [5, 9, 11, 18, 18, 21]，求和</span></span><br><span class="line">print(list(itertools.accumulate(sample, min)))  <span class="comment"># [5, 4, 2, 2, 0, 0]，求最小值</span></span><br><span class="line">print(list(itertools.accumulate(sample, max)))  <span class="comment"># [5, 5, 5, 7, 7, 7]，求最大值</span></span><br><span class="line"><span class="comment"># [1, 2, 6, 24, 120]，计算1-5的阶乘</span></span><br><span class="line">print(list(itertools.accumulate(range(<span class="number">1</span>, <span class="number">6</span>), operator.mul)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [(1, 'a'), (2, 'b'), (3, 'c')]，从start(1)开始给每个元素编号</span></span><br><span class="line">print(list(enumerate(<span class="string">'abc'</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="comment"># [0, 1, 4, 9, 16, 25] 映射求积，到短的迭代对象耗尽位置</span></span><br><span class="line">print(list(map(operator.mul, range(<span class="number">6</span>), range(<span class="number">7</span>))))</span><br><span class="line"><span class="comment"># ['a', 'bb', 'ccc'] 对一对元素求积</span></span><br><span class="line">print(list(itertools.starmap(operator.mul, zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)))))</span><br><span class="line"><span class="comment"># ['a', 'bb', 'ccc'] 同上</span></span><br><span class="line">print(list(itertools.starmap(operator.mul, enumerate(<span class="string">'abc'</span>, <span class="number">1</span>))))</span><br><span class="line"><span class="comment"># [5.0, 4.5, 3.6666666666666665, 4.5, 3.6, 3.5]，求阶段平均值</span></span><br><span class="line">print(list(itertools.starmap(<span class="keyword">lambda</span> a, b: b/a,</span><br><span class="line">                             enumerate(itertools.accumulate(sample), <span class="number">1</span>))))</span><br></pre></td></tr></table></figure>
<p>用于“合并”的生成器函数：</p>
<p><img src="/images/python/fluent_python/合并生成器.png" alt="合并生成器"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(list(itertools.chain(<span class="string">'ABC'</span>, range(<span class="number">2</span>))))  <span class="comment"># ['A', 'B', 'C', 0, 1]</span></span><br><span class="line"><span class="comment"># [0, 'A', 1, 'B', 2, 'C']</span></span><br><span class="line">print(list(itertools.chain.from_iterable(enumerate(<span class="string">'ABC'</span>))))</span><br><span class="line">print(list(zip(<span class="string">'ABC'</span>, range(<span class="number">5</span>))))  <span class="comment"># [('A', 0), ('B', 1), ('C', 2)]</span></span><br><span class="line"><span class="comment"># [('A', 0), ('B', 1), ('C', 2), ('?', 3), ('?', 4)]</span></span><br><span class="line">print(list(itertools.zip_longest(<span class="string">'ABC'</span>, range(<span class="number">5</span>), fillvalue=<span class="string">'?'</span>)))</span><br><span class="line"></span><br><span class="line">itertools.product生成器是计算笛卡尔积的惰性方式</span><br><span class="line"></span><br><span class="line">print(list(itertools.product(<span class="string">'AB'</span>)))  <span class="comment"># [('A',), ('B',)]</span></span><br><span class="line"><span class="comment"># [('A', 0), ('A', 1), ('B', 0), ('B', 1)]</span></span><br><span class="line">print(list(itertools.product(<span class="string">'AB'</span>, range(<span class="number">2</span>))))</span><br><span class="line"><span class="comment"># [('A', 'A'), ('A', 'B'), ('B', 'A'), ('B', 'B')]</span></span><br><span class="line">print(list(itertools.product(<span class="string">'AB'</span>, repeat=<span class="number">2</span>)))</span><br><span class="line">print(list(itertools.product(<span class="string">'AB'</span>, range(<span class="number">2</span>), repeat=<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>把输入的各个元素扩展成多个输出元素的生成器函数：</p>
<p><img src="/images/python/fluent_python/扩展生成器.png" alt="扩展生成器"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ct = itertools.count(<span class="number">5</span>)</span><br><span class="line">ns = next(ct), next(ct), next(ct)</span><br><span class="line">print(ns)  <span class="comment"># (5, 6, 7)。不能使用ct构建列表，因为ct是无穷的</span></span><br><span class="line">print(list(itertools.islice(itertools.count(), <span class="number">4</span>)))  <span class="comment"># [0, 1, 2, 3]，指定大于4的数将会抛出异常</span></span><br><span class="line">cy = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line">print(next(cy))  <span class="comment"># A</span></span><br><span class="line">print(list(itertools.islice(cy, <span class="number">5</span>)))  <span class="comment"># ['B', 'C', 'A', 'B', 'C']</span></span><br><span class="line">rp = itertools.repeat(<span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">print(next(rp), next(rp), next(rp))  <span class="comment"># 7 7 7</span></span><br><span class="line"><span class="comment"># [0.0, 1.5, 3.0, 4.5, 6.0]</span></span><br><span class="line">print(list(map(operator.mul, range(<span class="number">5</span>), itertools.repeat(<span class="number">1.5</span>))))</span><br></pre></td></tr></table></figure>
<p>扩展生成器中的“组合学”生成器函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [('A', 'B'), ('A', 'C'), ('B', 'C')]</span></span><br><span class="line">print(list(itertools.combinations(<span class="string">'ABC'</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]</span></span><br><span class="line">print(list(itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]</span></span><br><span class="line">print(list(itertools.permutations(<span class="string">'ABC'</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>用于重新排列元素的生成器函数：</p>
<p><img src="/images/python/fluent_python/排列生成器.png" alt="排列生成器"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(list(itertools.groupby(<span class="string">'AAABB'</span>)))</span><br><span class="line"><span class="comment"># [('A', &lt;itertools._grouper object at ...&gt;), ('B', &lt;itertools._grouper object at ...&gt;)]</span></span><br><span class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">'AAABB'</span>):</span><br><span class="line">    print(key, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line"><span class="comment"># A -&gt; ['A', 'A', 'A']</span></span><br><span class="line"><span class="comment"># B -&gt; ['B', 'B']</span></span><br><span class="line">animals = <span class="string">'rat duck bat eagle shark bear'</span>.split()</span><br><span class="line">animals.sort(key=len)  <span class="comment"># 为了使用groupby函数,输入要有序</span></span><br><span class="line"><span class="keyword">for</span> length, group <span class="keyword">in</span> itertools.groupby(reversed(animals), len):</span><br><span class="line">    print(length, <span class="string">'-&gt;'</span>, list(group))</span><br><span class="line"><span class="comment"># 5 -&gt; ['shark', 'eagle']</span></span><br><span class="line"><span class="comment"># 4 -&gt; ['bear', 'duck']</span></span><br><span class="line"><span class="comment"># 3 -&gt; ['bat', 'rat']</span></span><br><span class="line"></span><br><span class="line">g1, g2 = itertools.tee(<span class="string">'ABC'</span>)</span><br><span class="line">print(next(g1))  <span class="comment"># A</span></span><br><span class="line">print(list(g2))  <span class="comment"># ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>用于在生成器函数中方便的产出另一个生成器生成的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">print(list(chain(<span class="string">'ABC'</span>,range(<span class="number">3</span>))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain2</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line"></span><br><span class="line">print(list(chain2(<span class="string">'ABC'</span>,range(<span class="number">3</span>))))</span><br></pre></td></tr></table></figure>
<h2 id="可迭代的归约函数"><a href="#可迭代的归约函数" class="headerlink" title="可迭代的归约函数"></a>可迭代的归约函数</h2><p><img src="/images/python/fluent_python/归约函数.png" alt="归约函数"></p>
<p>这里的每个内置函数都可以用functools.reduce实现，内置是为了方便使用。此外，对all和any函数来说，有一项重要的优化措施是 reduce 函数做不到的： 这两个函数会短路。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(all([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># True</span></span><br><span class="line">print(all([<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>]))  <span class="comment"># False</span></span><br><span class="line">print(all([]))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">print(any([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># True</span></span><br><span class="line">print(any([<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>]))  <span class="comment"># True</span></span><br><span class="line">print(any([]))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">g = (n <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">0.0</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(any(g))  <span class="comment"># True，一旦确定结果就立即停止使用迭代器</span></span><br><span class="line">print(next(g))  <span class="comment"># 8，剩余的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="深入分析iter函数"><a href="#深入分析iter函数" class="headerlink" title="深入分析iter函数"></a>深入分析iter函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d6</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">d6_iter = iter(d6, <span class="number">1</span>)  <span class="comment"># 不断调用第一个参数（没有参数的可调用对象），产出各个值</span></span><br><span class="line">print(d6_iter)  <span class="comment"># &lt;callable_iterator object at ...&gt;</span></span><br><span class="line"><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line">    print(roll)  <span class="comment"># 当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出(打印)哨符</span></span><br></pre></td></tr></table></figure>
<h1 id="上下文管理器和else块"><a href="#上下文管理器和else块" class="headerlink" title="上下文管理器和else块"></a>上下文管理器和else块</h1><h2 id="if之外的else块"><a href="#if之外的else块" class="headerlink" title="if之外的else块"></a>if之外的else块</h2><p>先做这个，再做那个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'else'</span>)  <span class="comment"># "如果中断了就不做了"。仅当for循环运行完毕时(即for循环没有被break语句中止)才运行else块。</span></span><br></pre></td></tr></table></figure>
<p>while：</p>
<p>仅当while循环因为条件为假值而退出时（即while循环没有被break语句中止）才运行else块。</p>
<p>try：</p>
<p>仅当 try 块中没有异常抛出时才运行else块。官方文档还指出：“else 子句抛出的异常不会由前面的 except 子句处理。”</p>
<p>EAFP风格：</p>
<p><img src="/images/python/fluent_python/EAFP和LBYL.png" alt="EAFP和LBYL"></p>
<h2 id="上下文管理器和with块"><a href="#上下文管理器和with块" class="headerlink" title="上下文管理器和with块"></a>上下文管理器和with块</h2><p>with 语句的目的是简化 try/finally 模式。 这种模式用于保证一段代码运行完毕后执行某项操作， 即便那段代码由于异常、 return 语句或sys.exit() 调用而中止， 也会执行指定的操作。</p>
<p>上下文管理器协议包含 <code>__enter__</code> 和 <code>__exit__</code> 两个方法。 with 语句开始运行时， 会在上下文管理器对象上调用 <code>__enter__</code> 方法。 with 语句运行结束后， 会在上下文管理器对象上调用 <code>__exit__</code> 方法， 以此扮演 finally 子句的角色。</p>
<p>上下文管理器举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.origin_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># 猴子补丁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'JABBERWOCKY'</span> <span class="comment"># __enter__方法一般返回上下文管理器自己，也可返回别的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.origin_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        exc_type：异常类（例如ZeroDivisionError）</span></span><br><span class="line"><span class="string">        exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> sys  <span class="comment"># 重复导入模块不会消耗很多资源，因为Python会缓存导入的模块</span></span><br><span class="line">        sys.stdout.write = self.origin_write</span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:</span><br><span class="line">            print(<span class="string">'Please DO NOT divide by zero'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> g:</span><br><span class="line">    print(<span class="string">'Hallo'</span>)  <span class="comment"># ollaH，打印出的内容是反向的</span></span><br><span class="line">    print(g)  <span class="comment"># YKCOWREBBAJ，g就是</span></span><br><span class="line"></span><br><span class="line">print(g)  <span class="comment"># JABBERWOCKY，已经调用__exit__方法恢复打印方法</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-contextmanager"><a href="#使用-contextmanager" class="headerlink" title="使用@contextmanager"></a>使用@contextmanager</h2><p>contextlib.contextmanager 装饰器会把函数包装成实现 <code>__enter__</code> 和 <code>__exit__</code> 方法的类：yield 语句前面的所有代码在 with 块开始时（即解释器调用 <code>__enter__</code> 方法时） 执行， yield 语句后面的代码在with 块结束时（即调用 <code>__exit__</code> 方法时） 执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])  <span class="comment"># 在闭包中可以访问original_write</span></span><br><span class="line"></span><br><span class="line">    sys.stdout = reverse_write</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'JABBERWOCKY'</span></span><br><span class="line">    sys.stdout.write = original_write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> looking_glass</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> g:</span><br><span class="line">    print(<span class="string">'abc'</span>)  <span class="comment"># cba</span></span><br><span class="line">    print(g)  <span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'abc'</span>)  <span class="comment"># abc</span></span><br><span class="line">print(g)  <span class="comment"># JABBERWOCKY</span></span><br></pre></td></tr></table></figure>
<p>上述示例有一个严重的错误：如果在with块中抛出了异常，Python 解释器会将其捕获，然后在 looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会中止，永远无法恢复成原来的sys.stdout.write方法。修复代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'JABBERWOCKY'</span> <span class="comment">#要把yield语句放在try/finally语句中（或者放在with语句中），因为我们永远不知道上下文管理器的用户会在with块中做什么</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:   <span class="comment">#假设的异常</span></span><br><span class="line">        msg = <span class="string">'Please DO NOT divide by zero!'</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            print(msg)</span><br></pre></td></tr></table></figure>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><h2 id="用作协程的生成器的基本行为"><a href="#用作协程的生成器的基本行为" class="headerlink" title="用作协程的生成器的基本行为"></a>用作协程的生成器的基本行为</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt;coroutine started'</span>)</span><br><span class="line">    x = <span class="keyword">yield</span> <span class="comment"># 右边没有表达式，产出None</span></span><br><span class="line">    print(<span class="string">'-&gt;coroutine received:'</span>, x)</span><br><span class="line"></span><br><span class="line">c = simple_coroutine()</span><br><span class="line">print(c) <span class="comment"># &lt;generator object simple_coroutine at ...&gt;</span></span><br><span class="line">print(next(c))  <span class="comment"># -&gt;coroutine started       None</span></span><br><span class="line">c.send(<span class="string">'12'</span>)  <span class="comment"># -&gt;coroutine received: 12     抛出StopIteration</span></span><br></pre></td></tr></table></figure>
<p>协程的四种状态，可以用inspect.getgeneratorstate(…)函数确定：</p>
<ol>
<li>‘GEN_CREATED’，等待开始执行</li>
<li>‘GEN_RUNNING’，解释器正在执行</li>
<li>‘GEN_SUSPENDED’，在yield表达式处暂停</li>
<li>‘GEN_CLOSED’，执行结束</li>
</ol>
<p>仅当协程处于暂停时才能调用send方法，因此刚创建的协程必须先用next(coro)激活，也可用coro.send(None)，这一步成为“预激”（即让协程向前执行到第一个yield表达式）。</p>
<h2 id="使用协程计算移动平均值"><a href="#使用协程计算移动平均值" class="headerlink" title="使用协程计算移动平均值"></a>使用协程计算移动平均值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line">a = averager()</span><br><span class="line">next(a)</span><br><span class="line">print(a.send(<span class="number">10</span>))</span><br><span class="line">print(a.send(<span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<h2 id="预激协程的装饰器"><a href="#预激协程的装饰器" class="headerlink" title="预激协程的装饰器"></a>预激协程的装饰器</h2><p>自定义一个装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        next(gen)</span><br><span class="line">        <span class="keyword">return</span> gen</span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutil <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="终止协程和异常处理"><a href="#终止协程和异常处理" class="headerlink" title="终止协程和异常处理"></a>终止协程和异常处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handing</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'coroutine started'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="keyword">yield</span></span><br><span class="line">            <span class="keyword">except</span> DemoException:  <span class="comment"># 特别处理此异常</span></span><br><span class="line">                print(<span class="string">'DemoException handled,Continuning...'</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果没有异常，执行打印</span></span><br><span class="line">                print(<span class="string">'coroutine received:&#123;!r&#125;'</span>.format(x))</span><br><span class="line">    <span class="keyword">finally</span>:  <span class="comment"># 未处理的其他异常，协程结束，执行清理等</span></span><br><span class="line">        print(<span class="string">'coroutine ending'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = demo_exc_handing()</span><br><span class="line">next(d)  <span class="comment"># coroutine started</span></span><br><span class="line">d.send(<span class="string">'abc'</span>)</span><br><span class="line">d.send(<span class="number">2.00</span>)</span><br><span class="line">d.throw(DemoException)  <span class="comment"># DemoException handled，Continuning...</span></span><br><span class="line">d.throw(ZeroDivisionError)  <span class="comment"># 先coroutine ending，后抛出ZeroDivisionError</span></span><br></pre></td></tr></table></figure>
<p><code>generator.throw(exc_type[, exc_value[, traceback]])</code> :</p>
<p>致使生成器在暂停的 yield 表达式处抛出指定的异常。</p>
<p>如果生成器处理了抛出的异常，代码会继续执行到下一个yield表达式，而产出的值会成为调用generator.throw方法得到的返回值。</p>
<p>如果生成器没有处理抛出的异常，协程会停止，即状态变成’GEN_CLOSED’，异常会向上冒泡，传到调用方的上下文中。</p>
<p><code>generator.close()</code>：</p>
<p>致使生成器在暂停的yield表达式处抛出GeneratorExit异常。</p>
<p>如果生成器没有处理这个异常，或者抛出了StopIteration异常（通常是指运行到结尾），调用方不会报错。 </p>
<p>如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。</p>
<p>生成器抛出的其他异常会向上冒泡， 传给调用方。</p>
<h2 id="让协程返回值"><a href="#让协程返回值" class="headerlink" title="让协程返回值"></a>让协程返回值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 为了返回值，协程必须停止，因此加一个条件</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(count, average)</span><br><span class="line"></span><br><span class="line">a = averager()</span><br><span class="line">next(a)</span><br><span class="line">print(a.send(<span class="number">10</span>))  <span class="comment"># None，没有产出值</span></span><br><span class="line">print(a.send(<span class="number">13</span>))</span><br><span class="line">print(a.send(<span class="keyword">None</span>))  <span class="comment"># StopIteration: Result(count=2, average=11.5)</span></span><br></pre></td></tr></table></figure>
<p>异常对象的 value 属性保存着返回的值。</p>
<p>注意，return表达式的值会偷偷传给调用方，赋值给StopIteration异常的一个属性。 这样做有点不合常理。</p>
<p>更合理的获取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    print(e.value)  <span class="comment"># Result(count=2, average=11.5)</span></span><br></pre></td></tr></table></figure>
<h2 id="使用yield-from"><a href="#使用yield-from" class="headerlink" title="使用yield from"></a>使用yield from</h2><p>yield from x 表达式对 x 对象所做的第一件事是， 调用 iter(x)， 从中获取迭代器。 因此， x 可以是任何可迭代的对象。</p>
<p>yield from 的主要功能是打开双向通道， 把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值， 还可以直接传入异常， 而不用在位于中间的协程中添加大量处理异常的样板代码。 有了这个结构， 协程可以把职责委托给子生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_corountine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(list(gen()))</span><br><span class="line">print(list(gen_corountine()))</span><br></pre></td></tr></table></figure>
<p>术语说明：</p>
<ul>
<li>委派生成器：包含 yield from <iterable> 表达式的生成器函数</iterable></li>
<li>子生成器：从 yield from 表达式中 <iterable> 部分获取的生成器</iterable></li>
<li>调用方：指代调用委派生成器的客户端代码。 即“客户端”</li>
</ul>
<p>结构示意图：</p>
<p><img src="/images/python/fluent_python/协程.png" alt="协程"></p>
<p>代码演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""子生成器"""</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 子生成器的退出条件</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># 结束时抛出StopIteration异常，把返回值赋到value属性上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(result, key)</span>:</span></span><br><span class="line">    <span class="string">"""委派生成器"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  <span class="comment"># 继续迭代，避免group实例执行迭代结束时抛出StopIteration异常</span></span><br><span class="line">        <span class="comment"># grouper会在yield from表达式处暂停，发送的每个值都会经由yield from处理，通过管道传给averager实例，等待averager实例执行完毕。</span></span><br><span class="line">        <span class="comment"># 抑制子生成器抛出的StopIteration异常，接收averager实例的返回值（从StopIteration异常的value属性中获取）</span></span><br><span class="line">        result[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)</span><br><span class="line">        next(group)  <span class="comment"># 预激委派生成器，使委派生成器自身在yield from处暂停，接着委派生成器预激子生成器执行到第一个yeild语句处</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            <span class="comment"># 传入的值最终到达averager函数中term = yield那一行，grouper并不知道传入的值是什么</span></span><br><span class="line">            group.send(value)</span><br><span class="line">        <span class="comment"># 重要！结束averager函数执行，将返回值付给grouper的result变量。</span></span><br><span class="line">        <span class="comment"># 如果没有这一句，在下一次循环时，新创建的grouper实例将会覆盖到group变量上，前一个实例（以及它创建的尚未终止的averager子生成器实例）被垃圾回收程序回收</span></span><br><span class="line">        group.send(<span class="keyword">None</span>)</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'girls;kg'</span>: [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>: [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>: [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>: [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure>
<p>yield from链：</p>
<p>一个委派生成器使用yield from调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield表达式的简单生成器（或任何可迭代的对象）结束；任何yield from链条都必须由客户驱动，在最外层委派生成器上调用next(…)函数或.send(…)方法。可以隐式调用，例如使用for循环。</p>
<h2 id="yield-from-的意义"><a href="#yield-from-的意义" class="headerlink" title="yield from 的意义"></a>yield from 的意义</h2><p>yield from的特性：</p>
<ol>
<li>子生成器产出的值都直接传给委派生成器的调用方（即客户端代码） </li>
<li>使用 send() 方法发给委派生成器的值都直接传给子生成器。 如果发送的值是 None， 那么会调用子生成器的 <code>__next__()</code> 方法。 如果发送的值不是 None， 那么会调用子生成器的 send() 方法。 如果调用的方法抛出 StopIteration 异常， 那么委派生成器恢复运行。 任何其他异常都会向上冒泡， 传给委派生成器。</li>
<li>生成器退出时， 生成器（或子生成器） 中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。</li>
<li>yield from 表达式的值是子生成器终止时传给 StopIteration异常的第一个参数。</li>
<li>传入委派生成器的异常， 除了 GeneratorExit 之外都传给子生成器的 throw() 方法。 如果调用 throw() 方法时抛出StopIteration 异常， 委派生成器恢复运行。 StopIteration 之外的异常会向上冒泡， 传给委派生成器</li>
<li>如果把 GeneratorExit 异常传入委派生成器， 或者在委派生成器上调用 close() 方法， 那么在子生成器上调用 close() 方法， 如果它有的话。 如果调用 close() 方法导致异常抛出， 那么异常会向上冒泡， 传给委派生成器； 否则， 委派生成器抛出GeneratorExit 异常</li>
</ol>
<p>yeidl from结构的伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EXPR = <span class="string">'AB'</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_demo</span><span class="params">()</span>:</span></span><br><span class="line">    _i = iter(EXPR)  <span class="comment"># EXPR可以是任何可迭代对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _y = next(_i)  <span class="comment"># 预激，保存第一次产出的结果</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        _r = e.value  <span class="comment"># 最简单情况下的返回值（RESULT）</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:  <span class="comment"># 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _s = <span class="keyword">yield</span> _y  <span class="comment"># 产出上次子生成器的产出值，等待调用方发送值，保存在_s中</span></span><br><span class="line">            <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:  <span class="comment"># 用于关闭子生成器和委派生成器自己</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _m = _i.close</span><br><span class="line">                <span class="keyword">except</span> AttributeError:  <span class="comment"># 子生成器可能没有close方法（比如字符串），静默失败</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _m()</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:  <span class="comment"># 处理调用方通过.throw(...)方法传入的异常</span></span><br><span class="line">                _x = sys.exc_info()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _m = _i.throw()</span><br><span class="line">                <span class="keyword">except</span> AttributeError:  <span class="comment"># 子生成器可能没有throw方法，委派生成器抛出异常</span></span><br><span class="line">                    <span class="keyword">raise</span> _e</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 有throw方法，调用</span></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="comment"># 子生成器可能会处理掉出入的异常（然后继续循环），也可能抛出StopIteration异常，也可能抛出其他类型的异常</span></span><br><span class="line">                        _y = _m(*_x)</span><br><span class="line">                    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:  <span class="comment"># 处理StopIteration异常，获取返回值。如果是其他异常直接冒泡</span></span><br><span class="line">                        _r = _e.value</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                        _y = next(_i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        _y = _i.send(_s)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _r</span><br></pre></td></tr></table></figure>
<h2 id="离散事件仿真"><a href="#离散事件仿真" class="headerlink" title="离散事件仿真"></a>离散事件仿真</h2><p>离散事件仿真（DES），定义：</p>
<p><img src="/images/python/fluent_python/DES.png" alt="DES"></p>
<p>出租车队运营仿真，代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">Event = namedtuple(<span class="string">'Event'</span>, <span class="string">'time proc action'</span>)</span><br><span class="line"><span class="comment"># time 是事件发生的仿真时间</span></span><br><span class="line"><span class="comment"># proc 是出租车进程实例的编号</span></span><br><span class="line"><span class="comment"># action 描述活动的字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxi_process</span><span class="params">(ident, trips, start_time=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    每辆出租车调用一次taxi_process函数，创建一个生成器对象，表示各辆出租车的运营过程。 </span></span><br><span class="line"><span class="string">    ident是出租车的编号，trips是出租车回家之前的行程数量，start_time是出租车离开车库的时间。</span></span><br><span class="line"><span class="string">    每次改变状态时传入一个time，把控制权让给仿真器，每次结束时返回一个Event对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time = <span class="keyword">yield</span> Event(start_time, ident, <span class="string">'leave garage'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trips):  <span class="comment"># 每次行程运行一次</span></span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'pick up passenger'</span>)</span><br><span class="line">        time = <span class="keyword">yield</span> Event(time, ident, <span class="string">'drop off passenger'</span>)</span><br><span class="line">    <span class="keyword">yield</span> Event(time, ident, <span class="string">'going home'</span>)</span><br><span class="line">    <span class="comment"># 一个出租车进程结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simulator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, procs_map)</span>:</span></span><br><span class="line">        self.events = PriorityQueue()  <span class="comment"># 优先队列，可以按照指定优先顺序（item[0]，即time）取值</span></span><br><span class="line">        self.procs = dict(procs_map)  <span class="comment"># 副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, end_time)</span>:</span></span><br><span class="line">        <span class="comment"># 预激、排定各辆出租车的第一个事件</span></span><br><span class="line">        <span class="keyword">for</span> _, proc <span class="keyword">in</span> sorted(self.procs.items()):</span><br><span class="line">            first_event = next(proc)</span><br><span class="line">            self.events.put(first_event)</span><br><span class="line"></span><br><span class="line">        sim_time = <span class="number">0</span>  <span class="comment"># sim_time（仿真钟）归零</span></span><br><span class="line">        <span class="keyword">while</span> sim_time &lt; end_time:</span><br><span class="line">            <span class="keyword">if</span> self.events.empty():</span><br><span class="line">                print(<span class="string">'*** end of events ***'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            current_event = self.events.get()  <span class="comment"># 获取优先队列中time属性最小的Event对象</span></span><br><span class="line">            <span class="comment"># 每次循环时仿真钟不会以固定的量推进，是根据各个事件持续的时间推进</span></span><br><span class="line">            sim_time, proc_id, previous_action = current_event</span><br><span class="line">            print(<span class="string">'taxi'</span>, proc_id, proc_id*<span class="string">'   '</span>, current_event)</span><br><span class="line">            active_proc = self.procs[proc_id]</span><br><span class="line">            next_time = sim_time + <span class="number">2</span>  <span class="comment"># compute_duration(previous_action)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                next_event = active_proc.send(next_time)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">del</span> self.procs[proc_id]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.events.put(next_event)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环由于仿真事件到而退出，显示待完成的事件数量</span></span><br><span class="line">            msg = <span class="string">'*** end of simulation time: &#123;&#125; events pending ***'</span></span><br><span class="line">            print(msg.format(self.events.qsize()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">taxis = &#123;i: taxi_process(i, (i+<span class="number">1</span>)*<span class="number">2</span>, i*<span class="number">5</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)&#125;</span><br><span class="line">sim = Simulator(taxis)</span><br><span class="line">sim.run(<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>事件：</p>
<p>驱动型框架（如 Tornado 和 asyncio） 的运作方式： 在单个线程中使用一个主循环驱动协程执行并发活动。 使用协程做面向事件编程时， 协程会不断把控制权让步给主循环， 激活并向前运行其他协程， 从而执行各个并发活动。 </p>
<h1 id="使用期物处理并发"><a href="#使用期物处理并发" class="headerlink" title="使用期物处理并发"></a>使用期物处理并发</h1><h2 id="网络下载的三种风格"><a href="#网络下载的三种风格" class="headerlink" title="网络下载的三种风格"></a>网络下载的三种风格</h2><h3 id="依序下载的脚本"><a href="#依序下载的脚本" class="headerlink" title="依序下载的脚本"></a>依序下载的脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 不在标准库，一个空行隔开</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">'CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR'</span>).split()</span><br><span class="line">BASE_URL = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line">DEST_DIR = <span class="string">'downloads/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(DEST_DIR):</span><br><span class="line">        os.makedirs(DEST_DIR)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)  <span class="comment"># 阻塞性I/O操作</span></span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">' '</span>)</span><br><span class="line">    sys.stdout.flush()  <span class="comment"># 刷新sys.stdout，这样能在一行消息中看到进度。在Python在正常情况下，遇到换行才会刷新stdout缓冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">        image = get_flag(cc)</span><br><span class="line">        show(cc)</span><br><span class="line">        save_flag(image, cc.lower()+<span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time()-t0</span><br><span class="line">    msg = <span class="string">'\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s'</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure>
<h3 id="使用concurrent-futures模块下载"><a href="#使用concurrent-futures模块下载" class="headerlink" title="使用concurrent.futures模块下载"></a>使用concurrent.futures模块下载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main</span><br><span class="line"></span><br><span class="line">MAX_WORKERS = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower()+<span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    wokers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(wokers) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># download_one函数会在多个线程中并发调用；map方法返回一个生成器，因此可以迭代，获取各个函数返回的值</span></span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))</span><br><span class="line">    <span class="keyword">return</span> len(list(res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure>
<h3 id="期物在哪里"><a href="#期物在哪里" class="headerlink" title="期物在哪里"></a>期物在哪里</h3><p>标准库中有两个名为 Future 的类： concurrent.futures.Future 和 asyncio.Future。 这两个类的作用相同： 两个 Future 类的实例都表示可能已经完成或者尚未完成的延迟计算。 这与 Twisted 引擎中的 Deferred 类、 Tornado 框架中的Future 类， 以及多个 JavaScript 库中的 Promise 对象类似。</p>
<p>使用as_completed函数改写download_many函数，来理解期物：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> cc_list:</span><br><span class="line">            <span class="comment"># submit方法排定可调用对象的执行时间，返回一个期物，表示这个待执行（或正执行）的操作</span></span><br><span class="line">            future = executor.submit(download_one, cc)</span><br><span class="line">            to_do.append(future)</span><br><span class="line">            msg = <span class="string">'Scheduled for &#123;&#125;:&#123;&#125;'</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># as_completed 函数在期物运行结束后产出期物</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):</span><br><span class="line">            res = future.result()  <span class="comment"># 获取该期物（已结束，不会阻塞）的结果</span></span><br><span class="line">            msg = <span class="string">'&#123;&#125; result:&#123;!r&#125;'</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印：</span></span><br><span class="line"><span class="comment"># Scheduled for CN:&lt;Future at 0x232955c9860 state=running&gt;</span></span><br><span class="line"><span class="comment"># Scheduled for IN:&lt;Future at 0x232955c9f28 state=running&gt;</span></span><br><span class="line"><span class="comment"># Scheduled for US:&lt;Future at 0x232955d9550 state=running&gt;  有三个工作线程，前三个期物的状态是running</span></span><br><span class="line"><span class="comment"># Scheduled for ID:&lt;Future at 0x232955d9a90 state=pending&gt;</span></span><br><span class="line"><span class="comment"># Scheduled for BR:&lt;Future at 0x232955d9b38 state=pending&gt;  后两个是pending，等待有线程可用</span></span><br><span class="line"><span class="comment"># IN &lt;Future at 0x232955c9f28 state=finished returned str&gt; result:'IN'  第一个IN是download_one的子线程打印的，第二个'IN'是主线程获得返回后打印的</span></span><br><span class="line"><span class="comment"># CN &lt;Future at 0x232955c9860 state=finished returned str&gt; result:'CN'</span></span><br><span class="line"><span class="comment"># ID &lt;Future at 0x232955d9a90 state=finished returned str&gt; result:'ID'</span></span><br><span class="line"><span class="comment"># BR US &lt;Future at 0x232955d9b38 state=finished returned str&gt; result:'BR'  子线程都先把download_one的show执行了，然后返回结果。主线程遍历打印了结果</span></span><br><span class="line"><span class="comment"># &lt;Future at 0x232955d9550 state=finished returned str&gt; result:'US'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 flags downloaded in 0.88s</span></span><br></pre></td></tr></table></figure>
<p>严格来说， 我们目前测试的并发脚本都不能并行下载。 使用concurrent.futures 库实现的两个示例受 GIL（Global InterpreterLock， 全局解释器锁） 的限制， 而 flags_asyncio.py 脚本在单个线程中运行。（GIL几乎对 I/O 密集型处理无害）。</p>
<h2 id="阻塞性I-O和GIL"><a href="#阻塞性I-O和GIL" class="headerlink" title="阻塞性I/O和GIL"></a>阻塞性I/O和GIL</h2><p>Python 线程受 GIL的限制， 任何时候都只允许运行一个线程，但 flags_threadpool.py 脚本的下载速度仍比 flags.py 脚本快 5倍。flags_asyncio.py 脚本和 flags.py 脚本都在单个线程中运行， 前者仍比后者快 5 倍。</p>
<p>Python 标准库中的所有阻塞型 I/O 函数都会释放 GIL， 允许其他线程运行。 time.sleep() 函数也会释放 GIL。 因此， 尽管有GIL， Python 线程还是能在 I/O 密集型应用中发挥作用。</p>
<p>CPython 解释器本身就不是线程安全的， 因此有全局解释器锁（GIL） ，一次只允许使用一个线程执行 Python 字节码。 因此， 一个 Python 进程通常不能同时使用多个 CPU 核心。这是 CPython 解释器的局限， 与 Python 语言本身无关。 Jython 和 IronPython 没有这种限制。不过， 目前最快的 Python 解释器 PyPy 也有 GIL。</p>
<h2 id="使用concurrent-futures模块启动进程"><a href="#使用concurrent-futures模块启动进程" class="headerlink" title="使用concurrent.futures模块启动进程"></a>使用concurrent.futures模块启动进程</h2><p>在CPU密集型作业中使用concurrent.futures模块轻松绕开GIL，ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的Executor 接口， 因此使用ProcessPoolExecutor能特别轻松地把基于线程的方案转成基于进程的方案。而在下载国旗的示例或其他I/O密集型作业使用ProcessPoolExecutor类得不到任何好处。</p>
<h2 id="实验Executor-map方法"><a href="#实验Executor-map方法" class="headerlink" title="实验Executor.map方法"></a>实验Executor.map方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, strftime</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(strftime(<span class="string">'[%H:%M:%S]'</span>), end=<span class="string">'  '</span>)</span><br><span class="line">    print(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loiter</span><span class="params">(n)</span>:</span></span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;):start'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n, n))</span><br><span class="line">    sleep(n)</span><br><span class="line">    msg = <span class="string">'&#123;&#125;loiter(&#123;&#125;):done'</span></span><br><span class="line">    display(msg.format(<span class="string">'\t'</span>*n, n))</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    display(<span class="string">'Starting'</span>)</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> <span class="keyword">exec</span>:</span><br><span class="line">        results = <span class="keyword">exec</span>.map(loiter, range(<span class="number">5</span>))</span><br><span class="line">        display(<span class="string">'results'</span>, results)</span><br><span class="line">        display(<span class="string">'Waiting for individual results:'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, result <span class="keyword">in</span> enumerate(results):</span><br><span class="line">            display(<span class="string">'&#123;&#125;result &#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'\t'</span>*i, i, result))</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印：</span></span><br><span class="line"><span class="comment"># [18:55:54]  Starting</span></span><br><span class="line"><span class="comment"># [18:55:54]  loiter(0):doint nothing for 0s</span></span><br><span class="line"><span class="comment"># [18:55:54]  loiter(0):done    #sleep 函数总会释放 GIL，这一句可能在loiter(1)之前，也可能在后</span></span><br><span class="line"><span class="comment"># [18:55:54]   loiter(1):doint nothing for 1s</span></span><br><span class="line"><span class="comment"># [18:55:54]    loiter(2):doint nothing for 2s  #因为线程池中有三个职程，可以并发运行三个函数</span></span><br><span class="line"><span class="comment"># [18:55:54]  results &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at ...&gt; #目前不会阻塞</span></span><br><span class="line"><span class="comment"># [18:55:54]  Waiting for individual results:</span></span><br><span class="line"><span class="comment"># [18:55:54]  result 0:0</span></span><br><span class="line"><span class="comment"># [18:55:54]     loiter(3):doint nothing for 3s  #第一个线程可以启动第四个线程，运行loiter(3)。</span></span><br><span class="line"><span class="comment"># [18:55:55]   loiter(1):done</span></span><br><span class="line"><span class="comment"># [18:55:55]      loiter(4):doint nothing for 4s</span></span><br><span class="line"><span class="comment"># [18:55:55]  result 1:10</span></span><br><span class="line"><span class="comment"># [18:55:56]    loiter(2):done</span></span><br><span class="line"><span class="comment"># [18:55:56]  result 2:20</span></span><br><span class="line"><span class="comment"># [18:55:57]     loiter(3):done</span></span><br><span class="line"><span class="comment"># [18:55:57]  result 3:30</span></span><br><span class="line"><span class="comment"># [18:55:59]      loiter(4):done</span></span><br><span class="line"><span class="comment"># [18:55:59]  result 4:40</span></span><br></pre></td></tr></table></figure>
<p>map的特性：这个函数返回结果的顺序与调用开始的顺序一致，如果后调用的函数早完成则会处于阻塞状态。只能处理参数不同的同一个可调用对象。</p>
<p>executor.submit和futures.as_completed组合更灵活，不管提交顺序，只要有结果就获取。</p>
<p>futures.as_completed能处理的期物集合可以来自多个Executor实例。</p>
<h3 id="线程和多进程的替代方案"><a href="#线程和多进程的替代方案" class="headerlink" title="线程和多进程的替代方案"></a>线程和多进程的替代方案</h3><p>如果futures.ThreadPoolExecutor 类对某个作业来说不够灵活， 可能要使用 threading 模块中的组件（如 Thread、 Lock、 Semaphore 等）自行制定方案， 比如说使用 queue 模块创建线程安全的队列， 在线程之间传递数据。 futures.ThreadPoolExecutor 类已经封装了这些组件。</p>
<p>对 CPU 密集型工作来说， 要启动多个进程， 规避 GIL。 创建多个进程最简单的方式是， 使用 futures.ProcessPoolExecutor 类。 不过和前面一样， 如果使用场景较复杂， 需要更高级的工具。 multiprocessing 模块的 API 与threading 模块相仿， 不过作业交给多个进程处理。</p>
<h1 id="使用asyncio包处理并发"><a href="#使用asyncio包处理并发" class="headerlink" title="使用asyncio包处理并发"></a>使用asyncio包处理并发</h1><h2 id="线程与协程的对比"><a href="#线程与协程的对比" class="headerlink" title="线程与协程的对比"></a>线程与协程的对比</h2><p>spinner_thread.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span><span class="params">()</span>:</span></span><br><span class="line">    go = <span class="keyword">True</span>  <span class="comment"># 从外部控制线程关闭</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg, signal)</span>:</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">        status = char+<span class="string">' '</span>+msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span>*len(status))  <span class="comment"># 使用退格符（\x08）把光标移回来</span></span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> signal.go:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    write(<span class="string">' '</span>*len(status)+<span class="string">'\x08'</span>*len(status))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 假装I/O。调用sleep函数会阻塞主线程，一定要这么做，以便释放GIL，创建子线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    signal = Signal()</span><br><span class="line">    spinner = threading.Thread(target=spin,</span><br><span class="line">                               args=(<span class="string">'thinking!'</span>, signal))</span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    spinner.start()</span><br><span class="line">    result = slow_function()</span><br><span class="line">    signal.go = <span class="keyword">False</span></span><br><span class="line">    spinner.join()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    result = supervisor()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>spinner_asyncio.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine  # 强烈建议打算交给asyncio处理的协程要使用@asyncio.coroutine装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg)</span>:</span></span><br><span class="line">    write, flush = sys.stdout.write, sys.stdout.flush</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">        status = char + <span class="string">' '</span>+msg</span><br><span class="line">        write(status)</span><br><span class="line">        flush()</span><br><span class="line">        write(<span class="string">'\x08'</span>*len(status))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">.1</span>)  <span class="comment"># 这样的休眠不会阻塞事件循环</span></span><br><span class="line">            <span class="comment"># time.sleep(.1)  # 将会无限循环执行，调用方也不能中止子协程的执行</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    write(<span class="string">' '</span>*len(status)+<span class="string">'\x08'</span>*len(status))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 表达式把控制权交给主事件循环（loop），在休眠结束后恢复这个协程。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 排定spin协程的运行时间（顺序），使用一个Task对象包装spin协程，并立即返回</span></span><br><span class="line">    spinner = asyncio.ensure_future(spin(<span class="string">'thinking!'</span>))</span><br><span class="line">    <span class="comment"># spinner object: &lt;Task pending coro=&lt;spin() running at .\index.py:7&gt;&gt;</span></span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function()  <span class="comment"># 主循环在此处等待3秒，先去处理其他排定的协程</span></span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 获取事件循环的引用</span></span><br><span class="line">    result = loop.run_until_complete(supervisor())  <span class="comment"># 驱动supervisor协程，让它运行完毕；这个协程的返回值是这次调用的返回值。</span></span><br><span class="line">    loop.close()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>以上两种supervisor实现之间的主要区别：</p>
<ol>
<li>asyncio.Task对象差不多与threading.Thread对象等效。</li>
<li>Task对象用于驱动协程，Thread对象用于调用可调用对象。</li>
<li>Task对象不由自己动手实例化，而是通过把协程传给asyncio.ensure_future(..)函数或loop.create_task(…)方法获取。</li>
<li>获取的Task对象已经排定了运行时间。Thread实例则必须调用start方法。</li>
<li>没有API能从外部终止线程。可以使用Task.cancel()，在协程内部抛出CancelledError异常，协程可以在暂停的yield处捕获这个异常，处理终止请求。</li>
<li>supervisor协程必须在main函数中由loop.run_until_complete方法执行。</li>
</ol>
<p>协程和线程的同步区别：</p>
<p>对协程来说， 无需保留锁， 在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻只有一个协程运行。 想交出控制权时， 可以使用 yield 或 yield from 把控制权交还调度程序。</p>
<h3 id="asyncio-Future和concurrent-futures-Future区别"><a href="#asyncio-Future和concurrent-futures-Future区别" class="headerlink" title="asyncio.Future和concurrent.futures.Future区别"></a>asyncio.Future和concurrent.futures.Future区别</h3><p>期物只是调度执行某物的结果。 在asyncio 包中，BaseEventLoop.create_task(…)方法接收一个协程， 排定它的运行时间，然后返回一个asyncio.Task实例——也是asyncio.Future类的实例，因为Task是Future的子类，用于包装协程。这与调用Executor.submit(…)方法创建concurrent.futures.Future实例是一个道理。</p>
<p>与concurrent.futures.Future类似，asyncio.Future类也提供了.done()、.add_done_callback(…)和.result() 等方法。</p>
<p>因为asyncio.Future类的目的是与yield from一起使用，所以通常不需要使用以下方法：</p>
<ol>
<li>无需调用my_future.add_done_callback(…)，因为可以直接把想在期物运行结束后执行的操作放在协程中 yield from my_future 表达式的后面。 这是协程的一大优势： 协程是可以暂停和恢复的函数。</li>
<li>无需调用my_future.result()，因为 yield from 从期物中产出的值就是结果（例如，result = yield from my_future）。</li>
</ol>
<h2 id="使用asyncio和aiohttp包下载"><a href="#使用asyncio和aiohttp包下载" class="headerlink" title="使用asyncio和aiohttp包下载"></a>使用asyncio和aiohttp包下载</h2><p>从Python3.4起，asyncio包只支持TCP和UDP。如果想使用HTTP，可以使用aiohttp包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> BASE_URL, save_flag, show, main</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.ClientSession().get(url)  <span class="comment"># 非阻塞I/O操作</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower()+<span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    wait_coro = asyncio.wait(to_do)  <span class="comment"># wait 是一个协程，等传给它的所有协程运行完毕后结束</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure>
<p>asyncio.wait 会分别把各个协程包装进一个 Task 对象。 最终的结果是， wait 处理的所有对象都通过某种方式变成 Future 类的实例。 wait 是协程函数， 因此返回的是一个协程或生成器对象。</p>
<p>在asyncio包的API中使用yield from时：</p>
<p><img src="/images/python/fluent_python/asyncio的yield from.png" alt="asyncio的yield from"></p>
<h2 id="避免阻塞型调用"><a href="#避免阻塞型调用" class="headerlink" title="避免阻塞型调用"></a>避免阻塞型调用</h2><p>有两种方法能避免阻塞型调用中止整个应用程序的进程：</p>
<ol>
<li>在单独的线程中运行各个阻塞型操作</li>
<li>把每个阻塞型操作转换成非阻塞的异步调用使用</li>
</ol>
<p>多个线程是可以的， 但是各个操作系统线程（Python 使用的是这种线程） 消耗的内存达兆字节（具体的量取决于操作系统种类） 。 如果要处理几千个连接， 而每个连接都使用一个线程的话， 我们负担不起。</p>
<p>asyncio 的基础设施获得第一个响应后， 事件循环把响应发给等待结果的 get_flag 协程。 得到响应后， get<em>flag 向前执行到下一个 yieldfrom 表达式处， 调用 resp.read() 方法， 然后把控制权还给主循环。其他响应会陆续返回（因为请求几乎同时发出） 。 所有 get</em> flag 协程都获得结果后， 委派生成器 download_one 恢复， 保存图像文件。</p>
<h2 id="改进asyncio下载脚本"><a href="#改进asyncio下载脚本" class="headerlink" title="改进asyncio下载脚本"></a>改进asyncio下载脚本</h2><p>把一个协程列表传给 asyncio.wait 函数， 经由loop.run_until_complete 方法驱动， 全部协程运行完毕后， 这个函数会返回所有下载结果。 可是， 为了更新进度条， 各个协程运行结束后就要立即获取结果。 为了集成进度条， 我们使用 as_completed 生成器函数；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags2_common <span class="keyword">import</span> main, HTTPStatus, Result, save_flag</span><br><span class="line"></span><br><span class="line">DEFAULT_CONCUR_REQ = <span class="number">5</span></span><br><span class="line">MAX_CONCUR_REQ = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, country_code)</span>:</span></span><br><span class="line">        self.country_code = country_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.ClientSession().get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">        image = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    <span class="keyword">elif</span> resp.status == <span class="number">404</span>:</span><br><span class="line">        <span class="keyword">raise</span> web.HTTPNotFound()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> aiohttp.HttpProcessingError(</span><br><span class="line">            code=resp.status, message=resp.reason,</span><br><span class="line">            headers=resp.headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="comment"># semaphore 参数是 asyncio.Semaphore 类的实例。 Semaphore 类是同步装置， 用于限制并发请求数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, semaphore, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 使用 with 表达式或手动在 semaphore 对象上调用 release 方法(递增)或 acquire 方法(递减)来操作内部计数器</span></span><br><span class="line">        <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">            <span class="comment"># 退出这个 with 语句后， semaphore 计数器的值会递减， 解除阻塞可能在等待同一个 semaphore 对象的其他协程实例</span></span><br><span class="line">            image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> web.HTTPNotFound:</span><br><span class="line">        status = HTTPStatus.not_found</span><br><span class="line">        msg = <span class="string">'not found'</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="keyword">raise</span> FetchError(cc) <span class="keyword">from</span> exc   <span class="comment"># raise X from Y 句法链接原来的异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 1, save_flag(image, cc.lower() + '.gif') # 直接调用 save_flag 访问本地文件系统会阻塞客户代码与 asyncio 事件循环共用的唯一线程</span></span><br><span class="line">        <span class="comment"># 2, asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，我们可以调用 run_in_executor 方法， 把可调用的对象发给它执行</span></span><br><span class="line">        <span class="comment"># 第一个参数是 Executor 实例； 如果设为None， 使用事件循环的默认 ThreadPoolExecutor 实例</span></span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        loop.run_in_executur(<span class="keyword">None</span>, save_flag, image, cc.lower()+<span class="string">'.gif'</span>)</span><br><span class="line"></span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">and</span> msg:</span><br><span class="line">        print(cc, msg)</span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader_coro</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span>  <span class="comment"># 不直接调用，使用事件循环驱动</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="comment"># 最多允许激活 concur_req 个使用这个计数器的协程，锁</span></span><br><span class="line">    semaphore = asyncio.Semaphore(concur_req)</span><br><span class="line">    to_do = [download_one(cc, base_url, semaphore, verbose)</span><br><span class="line">             <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]  <span class="comment"># 循环调用 download_one 协程， 创建一个协程对象列表。</span></span><br><span class="line">    to_do_iter = asyncio.as_completed(to_do)  <span class="comment"># 获取一个迭代器， 这个迭代器会在期物运行结束后返回期物</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">        to_do_iter = tqdm.tqdm(to_do_iter, total=len(</span><br><span class="line">            cc_list))  <span class="comment"># 传给 tqdm 函数， 显示进度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> to_do_iter:  <span class="comment"># 迭代运行结束并返回结果的期物</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = <span class="keyword">yield</span> <span class="keyword">from</span> future  <span class="comment"># 获取该期物的结果（此时已结束，不会阻塞）的最简单的方式，而不是使用future.result()</span></span><br><span class="line">        <span class="keyword">except</span> FetchError <span class="keyword">as</span> exc:</span><br><span class="line">            country_code = exc.country_code</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 尝试从原来的异常（__cause__） 中获取错误消息</span></span><br><span class="line">                error_msg = exc.__cause__.args[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                error_msg = exc.__cause__.__class__.__name__</span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                msg = <span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">                print(msg.format(country_code, error_msg))</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            status = res.status</span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coro = downloader_coro(cc_list, base_url, verbose, concur_req)</span><br><span class="line">    <span class="comment"># download_many 函数只是实例化 downloader_coro 协程， 然后通过 run_until_complete 方法把它传给事件循环。</span></span><br><span class="line">    counts = loop.run_until_complete(coro)</span><br><span class="line">    loop.close()</span><br><span class="line">    <span class="keyword">return</span> counts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)</span><br></pre></td></tr></table></figure>
<h2 id="从回调到期物和协程"><a href="#从回调到期物和协程" class="headerlink" title="从回调到期物和协程"></a>从回调到期物和协程</h2><p>Python中的回调地狱：链式回调</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call1(request1, stage1)</span><br></pre></td></tr></table></figure>
<p>使用协程和yield from 结构做异步编程，无需回调：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span></span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1)</span><br><span class="line">    <span class="comment"># 第一步</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2)</span><br><span class="line">    <span class="comment"># 第二步</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3)</span><br><span class="line">    <span class="comment"># 第三步</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">loop.create_task(three_stages(request1)) <span class="comment"># 必须显式调度执行</span></span><br></pre></td></tr></table></figure>
<p>使用yield from 异步编程，每次下载发起多次请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_get</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.ClientSession().get(url)</span><br><span class="line">    <span class="keyword">if</span> resp.status == <span class="number">200</span>:</span><br><span class="line">        ctype = resp.headers.get(<span class="string">'Content-Type'</span>, <span class="string">''</span>).lower()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'json'</span> <span class="keyword">in</span> ctype <span class="keyword">or</span> url.endswith(<span class="string">'json'</span>):</span><br><span class="line">            data = <span class="keyword">yield</span> <span class="keyword">from</span> resp.json()  <span class="comment"># 如果内容类型包含'json'，解析为一个字典</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()  <span class="comment"># 读取原始字节</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> resp.status == <span class="number">404</span>:</span><br><span class="line">        <span class="keyword">raise</span> web.HTTPNotFound()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> aiohttp.HttpProcessingError(</span><br><span class="line">            code=resp.status, message=resp.reason,</span><br><span class="line">            headers=resp.headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contry</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/metadata.json'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    metadata = <span class="keyword">yield</span> <span class="keyword">from</span> http_get(url)</span><br><span class="line">    <span class="keyword">return</span> metadata[<span class="string">'country'</span>]  <span class="comment"># 获取字典中的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> http_get(url))  <span class="comment"># 这里必须在外层加上括号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, semaphore, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">            image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(base_url, cc)</span><br><span class="line">        <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">            country = <span class="keyword">yield</span> <span class="keyword">from</span> get_contry(base_url, cc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> web.HTTPNotFound:</span><br><span class="line">        status = HTTPStatus.not_found</span><br><span class="line">        msg = <span class="string">'not found'</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="keyword">raise</span> FetchError(cc) <span class="keyword">from</span> exc   <span class="comment"># raise X from Y 句法链接原来的异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        country = country.replace(<span class="string">' '</span>, <span class="string">'_'</span>)</span><br><span class="line">        filename = <span class="string">'&#123;&#125;-&#123;&#125;.gif'</span>.format(country, cc)</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        loop.run_in_executur(<span class="keyword">None</span>, save_flag, image, filename)</span><br><span class="line">        </span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">and</span> msg:</span><br><span class="line">        print(cc, msg)</span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br></pre></td></tr></table></figure>
<h2 id="使用asyncio包编写服务器"><a href="#使用asyncio包编写服务器" class="headerlink" title="使用asyncio包编写服务器"></a>使用asyncio包编写服务器</h2><h3 id="使用asyncio包编写TCP服务器"><a href="#使用asyncio包编写TCP服务器" class="headerlink" title="使用asyncio包编写TCP服务器"></a>使用asyncio包编写TCP服务器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> charfinder <span class="keyword">import</span> UnicodeNameIndex</span><br><span class="line"></span><br><span class="line">CRLF = <span class="string">b'\r\n'</span></span><br><span class="line">PROMPT = <span class="string">b'?&gt; '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 UnicodeNameIndex 类时， 它会使用 charfinder_index.pickle文件（如果没有则构建）</span></span><br><span class="line">index = UnicodeNameIndex()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="comment"># 这个协程要传给start_server，接收的两个参数是，asyncio.StreamReader和asyncio.StreamWriter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_queries</span><span class="params">(reader, writer)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  <span class="comment"># 循环处理会话， 直到从客户端收到控制字符</span></span><br><span class="line">        <span class="comment"># 发送提示符，StreamWriter.write 方法不是协程，只是普通的函数，不能使用yield from</span></span><br><span class="line">        writer.write(PROMPT)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()  <span class="comment"># 刷新 writer 缓冲，因为它是协程，必须使用 yield from</span></span><br><span class="line">        data = <span class="keyword">yield</span> <span class="keyword">from</span> reader.readline()  <span class="comment"># 协程，返回bytes对象</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            query = data.decode().strip()</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            query = <span class="string">'\x00'</span>  <span class="comment"># Telnet 客户端发送控制字符时，可能会抛出 UnicodeDecodeError异常；简单起见，假装发送的是空字符。</span></span><br><span class="line">        client = writer.get_extra_info(<span class="string">'peername'</span>)  <span class="comment"># 返回与套接字连接的远程地址</span></span><br><span class="line">        print(<span class="string">'Received from &#123;&#125;:&#123;!r&#125;!'</span>.format(client, query))</span><br><span class="line">        <span class="keyword">if</span> query:</span><br><span class="line">            <span class="keyword">if</span> ord(query[:<span class="number">1</span>]) &lt; <span class="number">32</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 收到控制字符或者空字符， 退出循环</span></span><br><span class="line">            <span class="comment"># 产出包含 Unicode 码位、真正的字符和字符名称的字符串</span></span><br><span class="line">            lines = list(index.find_description_strs(query))</span><br><span class="line">            <span class="keyword">if</span> lines:</span><br><span class="line">                <span class="comment"># 把 lines 转换成 bytes 对象，并在每一行末尾添加回车符和换行符</span></span><br><span class="line">                <span class="comment"># writer.writelines(line.encode()+CRLF for line in lines)</span></span><br><span class="line">                writer.writelines(line.encode(<span class="string">'utf8'</span>)+CRLF <span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">'卧室的'</span>)</span><br><span class="line">            writer.write(index.status(query, len(lines)).encode()+CRLF)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()  <span class="comment"># 刷新输出缓冲</span></span><br><span class="line">            print(<span class="string">'Sent &#123;&#125; results'</span>.format(len(lines)))</span><br><span class="line">    print(<span class="string">'Close the client socket'</span>)</span><br><span class="line">    writer.close()  <span class="comment"># 关闭StreamWriter流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(address=<span class="string">'127.0.0.1'</span>, port=<span class="number">2323</span>)</span>:</span></span><br><span class="line">    port = int(port)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># asyncio.start_server 协程运行结束后， 返回的协程对象返回一个 asyncio.Server 实例， 即一个 TCP 套接字服务器</span></span><br><span class="line">    server_coro = asyncio.start_server(</span><br><span class="line">        handle_queries, address, port, loop=loop)</span><br><span class="line">    <span class="comment"># 驱动 server_coro 协程， 启动服务器（server）</span></span><br><span class="line">    server = loop.run_until_complete(server_coro)</span><br><span class="line">    host = server.sockets[<span class="number">0</span>].getsockname()  <span class="comment"># 获取这个服务器的第一个套接字的地址和端口</span></span><br><span class="line">    print(<span class="string">'Serving on &#123;&#125;. Hit CTRL-C to stop.'</span>.format(host))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_forever()  <span class="comment"># main 函数在这里阻塞，直到在服务器的控制台中按CTRL-C 键才会关闭</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:  <span class="comment"># 按CTRL-C</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Server shutting down.'</span>)</span><br><span class="line">    server.close()</span><br><span class="line">    <span class="comment"># server.wait_closed() 方法返回一个期物，调用loop.run_until_complete运行期物</span></span><br><span class="line">    loop.run_until_complete(server.wait_closed())</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 处理可选的命令行参数的简便方式：展开 sys.argv[1:]，传给main函数</span></span><br><span class="line">    main(*sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>handle_queries 协程的名称是复数， 因为它启动交互式会话后能处理各个客户端发来的多次请求。<br>代码中所有的 I/O 操作都使用 bytes 格式。 因此， 我们要解码从网络中收到的字符串， 还要编码发出的字符串。Python 3 默认使用的编码是 UTF-8， 这里就隐式使用了这个编码。<br>run_until_complete 方法的参数是一个协程（start_server方法返回的结果）或一个 Future 对象（server.wait_closed 方法返回的结果）,如果传给 run_until_complete 方法的参数是协程， 会把协程包装在 Task 对象中。<br>调用 loop.run_forever() 时阻塞。控制权流动到事件循环中， 而且一直待在那里。不过偶尔会回到 handle_queries 协程， 这个协程需要等待网络发送或接收数据时， 控制权又交还事件循环。<br>在事件循环运行期间， 只要有新客户端连接服务器就会启动一个handle_queries 协程实例。</p>
<h3 id="使用aiohttp包编写Web服务器"><a href="#使用aiohttp包编写Web服务器" class="headerlink" title="使用aiohttp包编写Web服务器"></a>使用aiohttp包编写Web服务器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> charfinder <span class="keyword">import</span> UnicodeNameIndex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TEMPLATE_NAME = <span class="string">'http_charfinder.html'</span></span><br><span class="line">SAMPLE_WORDS = (<span class="string">'bismillah chess cat circled Malayalam digit'</span></span><br><span class="line">                <span class="string">' Roman face Ethiopic black mark symbol dot'</span></span><br><span class="line">                <span class="string">' operator Braille hexagram'</span>).split()</span><br><span class="line"></span><br><span class="line">ROW_TPL = <span class="string">'&lt;tr&gt;&lt;td&gt;&#123;code_str&#125;&lt;/td&gt;&lt;th&gt;&#123;char&#125;&lt;/th&gt;&lt;td&gt;&#123;name&#125;&lt;/td&gt;&lt;/tr&gt;'</span></span><br><span class="line">LINK_TPL = <span class="string">'&lt;a href="/?query=&#123;0&#125;" title="find &amp;quot;&#123;0&#125;&amp;quot;"&gt;&#123;0&#125;&lt;/a&gt;'</span></span><br><span class="line">LINKS_HTML = <span class="string">', '</span>.join(LINK_TPL.format(word) <span class="keyword">for</span> word <span class="keyword">in</span></span><br><span class="line">                       sorted(SAMPLE_WORDS, key=str.upper))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = UnicodeNameIndex()</span><br><span class="line"></span><br><span class="line">template = <span class="string">''</span></span><br><span class="line"><span class="keyword">with</span> open(TEMPLATE_NAME) <span class="keyword">as</span> tpl:</span><br><span class="line">    template = tpl.read()</span><br><span class="line">template = template.replace(<span class="string">'&#123;links&#125;'</span>, LINKS_HTML)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span>  <span class="comment"># 每次请求执行一遍</span></span><br><span class="line">    query = request.query.get(<span class="string">'query'</span>).strip()</span><br><span class="line">    print(<span class="string">'Query:&#123;!r&#125;'</span>.format(query))</span><br><span class="line">    <span class="keyword">if</span> query:</span><br><span class="line">        descriptions = list(index.find_descriptions(query))</span><br><span class="line">        res = <span class="string">'\n'</span>.join(ROW_TPL.format(**descr._asdict())</span><br><span class="line">                        <span class="keyword">for</span> descr <span class="keyword">in</span> descriptions)</span><br><span class="line">        msg = index.status(query, len(descriptions))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        descriptions = []</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        msg = <span class="string">'Enter words describing characters'</span></span><br><span class="line"></span><br><span class="line">    html = template.format(query=query, result=res, message=msg)</span><br><span class="line">    print(<span class="string">'Sending &#123;&#125; results'</span>.format(len(descriptions)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> web.Response(content_type=<span class="string">'text/html'</span>, charset=<span class="string">'utf-8'</span>, text=html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop, address, port)</span>:</span>  <span class="comment"># init 协程产出一个服务器， 交给事件循环驱动</span></span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, home)</span><br><span class="line">    <span class="comment"># 返回一个 aiohttp.web.RequestHandler实例，在 app 对象上设置路由处理 HTTP 请求</span></span><br><span class="line">    handler = app.make_handler()</span><br><span class="line">    <span class="comment"># 创建服务器， 以 handler 为协议处理程序， 并把服务器绑定在指定的地址和端口上</span></span><br><span class="line">    server = <span class="keyword">yield</span> <span class="keyword">from</span> loop.create_server(handler, address, port)</span><br><span class="line">    <span class="keyword">return</span> server.sockets[<span class="number">0</span>].getsockname()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(address=<span class="string">'127.0.0.1'</span>, port=<span class="number">8111</span>)</span>:</span></span><br><span class="line">    port = int(port)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    host = loop.run_until_complete(</span><br><span class="line">        init(loop, address, port))  <span class="comment"># 执行init方法，启动服务器，获取服务器的地址和端口</span></span><br><span class="line">    print(<span class="string">'Serving on &#123;&#125;. Hit CTRL-C to stop.'</span>.format(host))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_forever()  <span class="comment"># 控制权在事件循环手上时， main 函数会在这里阻塞</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'Server shutting down.'</span>)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(*sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方法：</p>
<ol>
<li><p>yield from</p>
</li>
<li><p>传给 asyncio 包中某个参数为协程或期物的函数，例如 run_until_complete。</p>
</li>
</ol>
<h1 id="动态属性和特性"><a href="#动态属性和特性" class="headerlink" title="动态属性和特性"></a>动态属性和特性</h1><h2 id="使用动态属性转换数据"><a href="#使用动态属性转换数据" class="headerlink" title="使用动态属性转换数据"></a>使用动态属性转换数据</h2><h3 id="使用动态属性访问JSON类数据"><a href="#使用动态属性访问JSON类数据" class="headerlink" title="使用动态属性访问JSON类数据"></a>使用动态属性访问JSON类数据</h3><p>下载和加载，osconfeed.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">'http://www.oreilly.com/pub/sc/osconfeed'</span></span><br><span class="line">JSON = <span class="string">'data/osconfeed.json'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):</span><br><span class="line">        msg = <span class="string">'downloading &#123;&#125; to &#123;&#125;'</span>.format(URL, JSON)</span><br><span class="line">        warnings.warn(msg)</span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">'wb'</span>) <span class="keyword">as</span> local:  <span class="comment"># 同时进行下载和保存</span></span><br><span class="line">            local.write(remote.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(JSON, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)</span><br></pre></td></tr></table></figure></p>
<p>动态访问属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""一个只读接口，使用属性表示法访问JSON类对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):  <span class="comment"># 判断键是否为Python关键词，特殊处理</span></span><br><span class="line">                key += <span class="string">'_'</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">            <span class="comment"># 如果 name 是实例属性 __data 的属性，返回那个属性，如 keys</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则从 self.__data 中获取 name 键对应的元素， 返回调用FrozenJSON.build() 方法得到的结果。</span></span><br><span class="line">            <span class="keyword">return</span> FrozenJSON.build(self.__data[name])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  <span class="comment"># 备选构造函数</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure></p>
<p>动态访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="keyword">from</span> fronzen_json <span class="keyword">import</span> FrozenJSON</span><br><span class="line"></span><br><span class="line">raw_feed = load()</span><br><span class="line"></span><br><span class="line">print(raw_feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'name'</span>])</span><br><span class="line"></span><br><span class="line">feed = FrozenJSON(raw_feed)</span><br><span class="line"></span><br><span class="line">print(feed.Schedule.events[<span class="number">40</span>].name)  <span class="comment">#动态访问属性</span></span><br></pre></td></tr></table></figure>
<h3 id="使用new方法灵活创建对象"><a href="#使用new方法灵活创建对象" class="headerlink" title="使用new方法灵活创建对象"></a>使用<strong>new</strong>方法灵活创建对象</h3><p><code>__new__</code>： 这是个类方法（使用特殊方式处理， 因此不必使用 @classmethod 装饰器） ， 必须返回一个实例（自身类或其他类的实例，返回其他类的实例解释器不会调用 <code>__init__</code> 方法）。 返回的实例会作为第一个参数（即 self） 传给 <code>__init__</code> 方法。</p>
<p> 所以 <code>__init__</code> 方法其实是“初始化方法”。 真正的构造方法是 <code>__new__</code>。我们几乎不需要自己编写 <code>__new__</code> 方法， 因为从 object 类继承的实现已经足够了。</p>
<p>Python构件对象的过程的伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建对象的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_maker</span><span class="params">(the_class, some_arg)</span>:</span></span><br><span class="line">    new_object = the_class.__new__(some_arg)</span><br><span class="line">    <span class="keyword">if</span> isinstance(new_object, the_class):</span><br><span class="line">        the_class.__init__(new_object, some_arg)</span><br><span class="line">    <span class="keyword">return</span> new_object</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下述两个语句的作用基本等效</span></span><br><span class="line">x = Foo(<span class="string">'bar'</span>)</span><br><span class="line">x = object_maker(Foo, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>__new__</code> 方法取代build方法，构建可能是也可能不是FrozenJSON实例的新对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span>    <span class="comment">#__new__构建的“原始”对象，在__init__里进行初始化</span></span><br><span class="line">    self.__data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items():</span><br><span class="line">        <span class="keyword">if</span> keyword.iskeyword(key):</span><br><span class="line">            key += <span class="string">'_'</span></span><br><span class="line">        self.__data[key] = value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(self.__data, name):</span><br><span class="line">        <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> FrozenJSON(self.__data[name])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span>  <span class="comment"># cls是类本身</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">        <span class="comment"># 默认的行为是委托给超类（这里是object）的 __new__ 方法来构建“原始”对象。背后真正的构建操作由解释器调用 C 语言实现的 object.__new__ 方法执行</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">        <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> arg</span><br></pre></td></tr></table></figure>
<h3 id="shelve模块"><a href="#shelve模块" class="headerlink" title="shelve模块"></a>shelve模块</h3><p>略</p>
<h2 id="使用特性验证属性"><a href="#使用特性验证属性" class="headerlink" title="使用特性验证属性"></a>使用特性验证属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, desc, weight, price)</span>:</span></span><br><span class="line">        self.desc = desc</span><br><span class="line">        self.weight = weight  <span class="comment"># 这里赋值已经使用了特性的设值方法</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight*self.price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span>  <span class="comment"># 读值方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @weight.setter  # 这个装饰器把读值方法和设值方法绑定在一起</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 设值方法</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="特性全解析"><a href="#特性全解析" class="headerlink" title="特性全解析"></a>特性全解析</h2><h3 id="特性会覆盖实例属性"><a href="#特性会覆盖实例属性" class="headerlink" title="特性会覆盖实例属性"></a>特性会覆盖实例属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span><span class="params">()</span>:</span></span><br><span class="line">    data = <span class="string">'class data'</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''prop doc'''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'prop value'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Class()</span><br><span class="line">print(dir(obj))  <span class="comment"># 查询所有属性名列表，包括从父类继承的，返回__dir__()的结果</span></span><br><span class="line">print(vars(obj))  <span class="comment"># &#123;&#125;，实例的属性名值对，返回__dict__属性的值</span></span><br><span class="line">print(obj.data)  <span class="comment"># class data，获取的是Class.data的值</span></span><br><span class="line">obj.data = <span class="string">'bar'</span>  <span class="comment"># 创建一个实例属性，覆盖了类属性</span></span><br><span class="line">print(vars(obj))  <span class="comment"># &#123;'data': 'bar'&#125;</span></span><br><span class="line">print(Class.data)   <span class="comment"># class data，类属性没有改变</span></span><br><span class="line"></span><br><span class="line">print(Class.prop)  <span class="comment"># &lt;property object at ...&gt;，特性相当于类属性，获取的是特性对象本身，不会运行特性的读值方法</span></span><br><span class="line">print(obj.prop)  <span class="comment"># prop value，实例调用，执行了特性的读值方法</span></span><br><span class="line"><span class="comment"># obj.prop = 'foo'  # AttributeError: can't set attribute，只读特性，报错</span></span><br><span class="line">obj.__dict__[<span class="string">'prop'</span>] = <span class="string">'foo'</span>  <span class="comment"># 通过__dict__成功设置实例属性</span></span><br><span class="line">print(vars(obj))    <span class="comment"># &#123;'data': 'bar', 'prop': 'foo'&#125;</span></span><br><span class="line">print(obj.prop)  <span class="comment"># prop value，仍会运行特性的读值方法，特性覆盖了实例属性</span></span><br><span class="line">Class.prop = <span class="string">'baz'</span>  <span class="comment"># 相当于销毁了特性对象</span></span><br><span class="line">print(obj.prop)  <span class="comment"># foo，现在读取的是实例属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class.data = property(<span class="keyword">lambda</span> self: <span class="string">'class data prop'</span>, doc=<span class="string">'data doc'</span>)</span><br><span class="line">print(obj.data)  <span class="comment"># class data prop，实例的data属性被类的data特性覆盖了</span></span><br><span class="line"><span class="keyword">del</span> Class.data</span><br><span class="line">print(obj.data)  <span class="comment"># bar，恢复原样</span></span><br></pre></td></tr></table></figure>
<p>obj.attr 这样的表达式不会从 obj 开始寻找attr，而是从 <code>obj.__class__</code> 开始。而且， 仅当类中没有名为 attr的特性时， Python 才会在 obj 实例中寻找。</p>
<h2 id="特性工厂"><a href="#特性工厂" class="headerlink" title="特性工厂"></a>特性工厂</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    weight = quantity(<span class="string">'weight'</span>)  <span class="comment"># 把自定义特性定义为类属性</span></span><br><span class="line">    price = quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, desc, weight, price)</span>:</span></span><br><span class="line">        self.desc = desc</span><br><span class="line">        self.weight = weight  <span class="comment"># 特性已经激活</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight*self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = LineItem(<span class="string">'desc'</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">print(LineItem.weight)</span><br><span class="line"><span class="comment"># &#123;'desc': 'desc', 'weight': 10, 'price': 20&#125;，实例也创建了属性的，真正用于存储值</span></span><br><span class="line">print(vars(i))</span><br><span class="line">print(i.weight)  <span class="comment"># 10，调用了特性的读值方法</span></span><br></pre></td></tr></table></figure>
<h2 id="处理属性删除操作"><a href="#处理属性删除操作" class="headerlink" title="处理属性删除操作"></a>处理属性删除操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackKnight</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.members = [<span class="string">'an arm'</span>, <span class="string">'another arm'</span>, <span class="string">'a leg'</span>, <span class="string">'another leg'</span>]</span><br><span class="line">        self.phrases = [<span class="string">"'Tis but a scratch."</span>,</span><br><span class="line">                        <span class="string">"It's just a flesh wound."</span>,</span><br><span class="line">                        <span class="string">"I'm invincible!"</span>,</span><br><span class="line">                        <span class="string">"All right, we'll call it a draw."</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'next member is:'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.members[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @member.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">member</span><span class="params">(self)</span>:</span></span><br><span class="line">        text = <span class="string">'BLACK KNIGHT (loses &#123;&#125;)\n-- &#123;&#125;'</span></span><br><span class="line">        print(text.format(self.members.pop(<span class="number">0</span>), self.phrases.pop(<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">knight = BlackKnight()</span><br><span class="line">print(knight.member)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="keyword">del</span> knight.member</span><br><span class="line"><span class="keyword">del</span> knight.member</span><br></pre></td></tr></table></figure>
<h2 id="处理属性的重要属性和函数"><a href="#处理属性的重要属性和函数" class="headerlink" title="处理属性的重要属性和函数"></a>处理属性的重要属性和函数</h2><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = BlackKnight()</span><br><span class="line"></span><br><span class="line">print(type(BlackKnight))  <span class="comment"># &lt;class 'type'&gt;</span></span><br><span class="line">print(BlackKnight.__class__)  <span class="comment"># &lt;class 'type'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(b))  <span class="comment"># &lt;class '__main__.BlackKnight'&gt;</span></span><br><span class="line">print(b.__class__)  <span class="comment"># &lt;class '__main__.BlackKnight'&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>__class__</code>：对象所属类的引用（即 <code>obj.__class__</code> 与 type(obj) 的作用相同） 。Python 的某些特殊方法， 例如 <code>__getattr__</code>， 只在对象的类中寻找， 而不在实例中寻找。</p>
<p><code>__dict__</code>：一个映射， 存储对象或类的可写属性（键值对）。 有 <code>__dict__</code> 属性的对象，任何时候都能随意设置新属性。 如果类有 <code>__slots__</code> 属性， 它的实例可能没有 <code>__dict__</code> 属性。 参见下面对 <code>__slots__</code> 属性的说明。</p>
<p><code>__slots__</code>：类可以定义这个这属性， 限制实例能有哪些属性。 <code>__slots__</code> 属性的值是一个字符串组成的元组， 指明允许有的属性。 如果 <code>__slots__</code> 中没有 <code>__dict__</code>， 那么该类的实例没有 <code>__dict__</code> 属性， 实例只允许有指定名称的属性。</p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>dir([object])：列出对象的大多数属性。dir 函数的目的是交互式使用， 因此没有提供完整的属性列表， 只列出一组“重要的”属性名。 dir 函数能审查有或没有 <code>__dict__</code> 属性的对象。 dir 函数不会列出 <code>__dict__</code> 属性本身， 但会列出其中的键。 dir 函数也不会列出类的几个特殊属性， 例如 <code>__mro__</code>、 <code>__bases__</code> 和 <code>__name__</code>。 如果没有指定可选的 object 参数， dir 函数会列出当前作用域中的名称。</p>
<p>getattr(object, name[, default])：从 object 对象中获取 name 字符串对应的属性。 获取的属性可能来自对象所属的类或超类。 如果没有指定的属性， getattr 函数抛出AttributeError 异常， 或者返回 default 参数的值（如果设定了这个参数的话） 。</p>
<p>hasattr(object, name)：如果 object 对象中存在指定的属性， 或者能以某种方式（例如继承） 通过 object 对象获取指定的属性， 返回 True。 文档说： “这个函数的实现方法是调用 getattr(object, name) 函数， 看看是否抛出AttributeError 异常。 ”</p>
<p>setattr(object, name, value)：把 object 对象指定属性的值设为 value， 前提是 object 对象能接受那个值。 这个函数可能会创建一个新属性， 或者覆盖现有的属性。</p>
<p>vars([object])：返回 object 对象的 <code>__dict__</code> 属性； 如果实例所属的类定义了 <code>__slots__</code> 属性， 实例没有 <code>__dict__</code> 属性， 那么 vars 函数不能处理那个实例（相反， dir 函数能处理这样的实例） 。 如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样： 返回表示本地作用域的字典。</p>
<h3 id="特殊方法-1"><a href="#特殊方法-1" class="headerlink" title="特殊方法"></a>特殊方法</h3><p>使用点号或内置的 getattr、 hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。 但是， 直接通过实例的 <code>__dict__</code> 属性读写属性不会触发这些特殊方法——如果需要， 通常会使用这种方式跳过特殊方法。<br>要假定特殊方法从类上获取， 即便操作目标是实例也是如此。 因此， 特殊方法不会被同名实例属性遮盖。例如， obj.attr 和 getattr(obj, ‘attr’, 42) 都会触发 <code>Class.__getattribute__(obj, &#39;attr&#39;)</code> 方法。</p>
<p><code>__delattr__(self, name)</code>：只要使用 del 语句删除属性， 就会调用这个方法。 例如， del obj.attr 语句触发 <code>Class.__delattr__(obj, &#39;attr&#39;)</code> 方法。</p>
<p><code>__dir__(self)</code>：把对象传给 dir 函数时调用， 列出属性。 例如， dir(obj) 触发 <code>Class.__dir__(obj)</code> 方法。</p>
<p><code>__getattr__(self, name)</code>：仅当获取指定的属性失败， 搜索过 obj、 Class 和超类之后调用。表达式 obj.no_such_attr、 getattr(obj, ‘no_such_attr’) 和hasattr(obj, ‘no_such_attr’) 可能会触发 <code>Class.__getattr__(obj, &#39;no_such_attr&#39;)</code> 方法， 但是， 仅当在obj、 Class 和超类中找不到指定的属性时才会触发。</p>
<p><code>__setattr__(self, name, value)</code>：尝试设置指定的属性时总会调用这个方法。 点号和 setattr 内置函数会触发这个方法。 例如， obj.attr = 42 和 setattr(obj,’attr’, 42) 都会触发 <code>Class.__setattr__(obj, ‘attr’, 42)</code> 方法。</p>
<p><code>__getattribute__(self, name)</code>：尝试获取指定的属性时总会调用这个方法， 不过， 寻找的属性是特殊属性或特殊方法时除外。 点号与 getattr 和 hasattr 内置函数会触发这个方法。 调用 <code>__getattribute__</code> 方法且抛出 AttributeError 异常时， 才会调用 <code>__getattr__</code> 方法。 为了在获取 obj 实例的属性时不导致无限递归， <code>__getattribute__</code> 方法的实现要使用 <code>super().__getattribute__(obj, name)</code>。</p>
<h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>描述符是对多个属性运用相同存取逻辑的一种方式。描述符是实现了特定协议的类， 这个协议包括 <code>__get__</code>、 <code>__set__</code> 和 <code>__delete__</code> 方法。 property 类实现了完整的描述符协议。 通常， 可以只实现部分协议。我们在真实的代码中见到的大多数描述符只实现了 <code>__get__</code> 和 <code>__set__</code> 方法， 还有很多只实现了其中的一个。<strong>Django模型</strong>的字段就是描述符。</p>
<h2 id="描述符示例：验证属性"><a href="#描述符示例：验证属性" class="headerlink" title="描述符示例：验证属性"></a>描述符示例：验证属性</h2><p>把19章的把 quantity 特性工厂函数重构成 Quantity 描述符类。</p>
<p>术语说明：</p>
<ul>
<li>描述符类：实现描述符协议的类</li>
<li>托管类：把描述符实例声明为类属性的类</li>
<li>描述符实例：描述符类的各个实例， 声明为托管类的类属性</li>
<li>托管实例：托管类的实例</li>
<li>储存属性：托管实例中存储自身托管属性的属性</li>
<li>托管属性：托管类中由描述符实例处理的公开属性， 值存储在储存属性中。 也就是说， 描述符实例和储存属性为托管属性建立了基础</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">()</span>:</span>  <span class="comment"># 基于协议实现，不用继承</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name  <span class="comment"># 储存属性的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 为托管属性赋值时调用，设置托管实例的储存属性</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 如果使用内置的setattr 函数， 会再次触发 __set__ 方法， 导致无限递归</span></span><br><span class="line">            instance.__dict__[self.storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>)  <span class="comment"># 把描述符实例绑定到类属性 weight</span></span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, desc, weight, price)</span>:</span></span><br><span class="line">        self.desc = desc</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight*self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">truffle = LineItem(<span class="string">'White truffe'</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">print(vars(truffle))</span><br></pre></td></tr></table></figure>
<h3 id="自动获取储存属性的名称"><a href="#自动获取储存属性的名称" class="headerlink" title="自动获取储存属性的名称"></a>自动获取储存属性的名称</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">()</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span>  <span class="comment"># Quantity的私有类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)  <span class="comment"># 为每个储存属性生成一个唯一的名称</span></span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  <span class="comment"># instance是托管实例的引用， owner是托管类（如 LineItem） 的引用</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 因为托管属性和储存属性的名称不同， 所以把储存属性传给 getattr 函数不会触发描述符</span></span><br><span class="line">            setattr(instance, self.storage_name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="重构描述符"><a href="#重构描述符" class="headerlink" title="重构描述符"></a>重构描述符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span><span class="params">()</span>:</span>  <span class="comment"># AutoStorage 类提供了之前 Quantity 描述符的大部分功能</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        prefix = cls.__name__</span><br><span class="line">        index = cls.__counter</span><br><span class="line">        self.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(prefix, index)</span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>  <span class="comment"># 把验证操作委托给 validate 方法</span></span><br><span class="line">        value = self.validate(instance, value)</span><br><span class="line">        super().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""a string with at least one non-space character"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    desc = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lineitem</span><br><span class="line"></span><br><span class="line">print(lineitem.Quantity.__mro__)  <span class="comment"># (&lt;class 'lineitem.Quantity'&gt;, &lt;class 'lineitem.Validated'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'lineitem.AutoStorage'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line"></span><br><span class="line">print(LineItem5.Quantity.__mro__)</span><br></pre></td></tr></table></figure>
<h2 id="覆盖型和非覆盖型描述符对比"><a href="#覆盖型和非覆盖型描述符对比" class="headerlink" title="覆盖型和非覆盖型描述符对比"></a>覆盖型和非覆盖型描述符对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_name</span><span class="params">(obj_or_cls)</span>:</span></span><br><span class="line">    cls = type(obj_or_cls)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        cls = obj_or_cls</span><br><span class="line">    <span class="keyword">return</span> cls.__name__.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(obj)</span>:</span></span><br><span class="line">    cls = type(obj)</span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">is</span> type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;class &#123;&#125;&gt;'</span>.format(obj.__name__)</span><br><span class="line">    <span class="keyword">elif</span> cls <span class="keyword">in</span> [type(<span class="keyword">None</span>), int]:</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&#123;&#125; object&gt;'</span>.format(cls_name(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    pseudo_args = <span class="string">', '</span>.join(display(x) <span class="keyword">for</span> x <span class="keyword">in</span> args)</span><br><span class="line">    print(<span class="string">'-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'</span>.format(cls_name(args[<span class="number">0</span>]), name, pseudo_args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span><span class="params">()</span>:</span>  <span class="comment"># 有 __get__ 和 __set__ 方法的典型覆盖型描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span>  <span class="comment"># 没有 __get__ 方法的覆盖型描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print_args(<span class="string">'set'</span>, self, instance, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>  <span class="comment"># 没有 __set__ 方法， 所以这是非覆盖型描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print_args(<span class="string">'get'</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span></span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># 为了对比， 因为方法也是描述符</span></span><br><span class="line">        print(<span class="string">'-&gt; Managed.spam(&#123;&#125;)'</span>.format(display(self)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Managed()</span><br></pre></td></tr></table></figure>
<p>覆盖型描述符：也叫数据描述符或强制描述符，实现 <code>__set__</code> 方法的描述符属于覆盖型描述符， 因为虽然描述符是类属性， 但是实现 <code>__set__</code> 方法的话， 会覆盖对实例属性的赋值操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj.over  <span class="comment"># (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line">Managed.over  <span class="comment"># (&lt;Overriding object&gt;, None, &lt;class Managed&gt;)</span></span><br><span class="line">obj.over = <span class="number">7</span>  <span class="comment"># (&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line">obj.over  <span class="comment"># (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line">obj.__dict__[<span class="string">'over'</span>] = <span class="number">8</span></span><br><span class="line">print(vars(obj))  <span class="comment"># &#123;'over': 8&#125;</span></span><br><span class="line">obj.over  <span class="comment"># 即使有了over的实例属性，Managed.over仍会覆盖读取obj.over操作</span></span><br><span class="line"><span class="comment"># (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br></pre></td></tr></table></figure>
<p>没有 <code>__get__</code> 方法的覆盖性描述符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有实现__get__方法，因此从类中获取描述符实例 &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;</span></span><br><span class="line">print(obj.over_no_get)</span><br><span class="line"><span class="comment"># &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;</span></span><br><span class="line">print(Managed.over_no_get)</span><br><span class="line"><span class="comment"># 触发__set__方法，(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line">obj.over_no_get = <span class="number">7</span></span><br><span class="line"><span class="comment"># 仍是托管类中的描述符实例，&lt;__main__.OverridingNoGet object at 0x000001A913D8C908&gt;</span></span><br><span class="line">print(obj.over_no_get)</span><br><span class="line">obj.__dict__[<span class="string">'over_no_get'</span>] = <span class="number">9</span></span><br><span class="line">print(obj.over_no_get)  <span class="comment"># 9，over_no_get 实例属性会遮盖描述符， 但是只有读操作是如此</span></span><br><span class="line"><span class="comment"># 仍然经过描述符的 __set__ 方法处理。(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)</span></span><br><span class="line">obj.over_no_get = <span class="number">7</span></span><br><span class="line">print(obj.over_no_get)  <span class="comment"># 9，只要有同名的实例属性存在，描述符就会被遮盖</span></span><br></pre></td></tr></table></figure>
<p>非覆盖型描述符：也叫非数据描述符或遮盖型描述符，没有实现 <code>__set__</code> 方法的描述符是非覆盖型描述符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.non_over  <span class="comment"># (&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line">obj.non_over = <span class="number">7</span>  <span class="comment"># 非覆盖型描述符，没有干涉赋值操作的__set__方法</span></span><br><span class="line">print(obj.non_over)  <span class="comment"># 7，名为 non_over 的实例属性，把类的同名描述符属性遮盖掉了</span></span><br><span class="line">Managed.non_over  <span class="comment"># (&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)</span></span><br><span class="line"><span class="keyword">del</span> obj.non_over</span><br><span class="line"><span class="comment"># 删掉实例属性后，仍然触发了描述符。(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)</span></span><br><span class="line">obj.non_over</span><br></pre></td></tr></table></figure>
<h3 id="在类中覆盖描述符"><a href="#在类中覆盖描述符" class="headerlink" title="在类中覆盖描述符"></a>在类中覆盖描述符</h3><p>不管描述符是不是覆盖型， 为类属性赋值都能覆盖描述符。读类属性的操作可以由依附在托管类上定义有 <code>__get__</code> 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 <code>__set__</code> 方法的描述符处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Managed.over = <span class="number">1</span></span><br><span class="line">Managed.over_no_get = <span class="number">2</span></span><br><span class="line">Managed.non_over = <span class="number">3</span></span><br><span class="line">print(obj.over, obj.over_no_get, obj.non_over)  <span class="comment"># 1 2 3，描述符真的不见了</span></span><br></pre></td></tr></table></figure>
<h2 id="方法是描述符"><a href="#方法是描述符" class="headerlink" title="方法是描述符"></a>方法是描述符</h2><p>在类中定义的函数属于绑定方法（bound method） ， 因为用户定义的函数都有 <code>__get__</code> 方法， 所以依附到类上时， 就相当于描述符。</p>
<p>方法是非覆盖型描述符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj = Managed()</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj.spam 获取的是绑定方法对象。&lt;bound method Managed.spam of &lt;__main__.Managed object at ...&gt;&gt;</span></span><br><span class="line">print(obj.spam)</span><br><span class="line"><span class="comment"># Managed.spam 获取的是函数。&lt;function Managed.spam at 0x0000013D5D3DD400&gt;</span></span><br><span class="line">print(Managed.spam)</span><br><span class="line">obj.spam = <span class="number">7</span>  <span class="comment"># 为 obj.spam 赋值，创建了同名的实例属性，将会遮盖类属性，导致无法通过 obj 实例访问 spam 方法</span></span><br><span class="line">print(obj.spam)  <span class="comment"># 7</span></span><br><span class="line">print(Managed.spam)  <span class="comment"># &lt;function Managed.spam at 0x0000013D5D3DD400&gt;</span></span><br></pre></td></tr></table></figure>
<p>与描述符一样， 通过托管类访问时， 函数的 <code>__get__</code> 方法会返回自身的引用。 但是， 通过实例访问时， 函数的 <code>__get__</code> 方法返回的是绑定方法对象： 一种可调用的对象， 里面包装着函数， 并把托管实例（例如 obj） 绑定给函数的第一个参数（即 self） ， 这与 functools.partial 函数的行为一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">(collections.UserString)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Text(&#123;!r&#125;)'</span>.format(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">word = Text(<span class="string">'forward'</span>)</span><br><span class="line">print(word)  <span class="comment"># forward</span></span><br><span class="line">print(word.reverse())  <span class="comment"># drawrof</span></span><br><span class="line">print(Text.reverse(word))  <span class="comment"># drawrof，在类上调用方法相当于调用函数</span></span><br><span class="line"><span class="comment"># &lt;class 'function'&gt; &lt;class 'method'&gt;</span></span><br><span class="line">print(type(Text.reverse), type(word.reverse))</span><br><span class="line"><span class="comment"># 函数都是非覆盖型描述符。 在函数上调用 __get__ 方法时传入实例， 得到的是绑定到那个实例上的方法。</span></span><br><span class="line"><span class="comment"># &lt;bound method Text.reverse of Text('forward')&gt;</span></span><br><span class="line">print(Text.reverse.__get__(word))</span><br><span class="line"><span class="comment"># 如果 instance 参数的值是 None， 那么得到的是函数本身</span></span><br><span class="line"><span class="comment"># &lt;function Text.reverse at 0x000001F3A93DF0D0&gt;</span></span><br><span class="line">print(Text.reverse.__get__(<span class="keyword">None</span>, Text))</span><br><span class="line"><span class="comment"># word.reverse 表达式其实会调用Text.reverse.__get__(word)， 返回对应的绑定方法</span></span><br><span class="line"><span class="comment"># &lt;bound method Text.reverse of Text('forward')&gt;</span></span><br><span class="line">print(word.reverse)</span><br><span class="line">print(word.reverse.__self__)  <span class="comment"># forward，调用这个方法的实例引用。</span></span><br><span class="line">print(word.reverse.__func__ <span class="keyword">is</span> Text.reverse)  <span class="comment"># True，依附在托管类上那个原始函数的引用</span></span><br></pre></td></tr></table></figure>
<p>绑定方法对象还有个 <code>__call__</code> 方法， 用于处理真正的调用过程。 这个方法会调用 <code>__func__</code> 属性引用的原始函数， 把函数的第一个参数设为绑定方法的 <code>__self__</code> 属性。</p>
<h2 id="描述符用法建议"><a href="#描述符用法建议" class="headerlink" title="描述符用法建议"></a>描述符用法建议</h2><ul>
<li>使用特性以保持简单</li>
</ul>
<p>内置的 property 类创建的其实是覆盖型描述符， <code>__set__</code> 方法和 <code>__get__</code> 方法都实现了， 即便不定义设值方法也是如此。 特性的 <code>__set__</code> 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性， 这能避免下一条所述的问题。</p>
<ul>
<li>只读描述符必须有 <code>__set__</code> 方法</li>
</ul>
<p>如果使用描述符类实现只读属性， 要记住， <code>__get__</code> 和 <code>__set__</code> 两个方法必须都定义， 否则， 实例的同名属性会遮盖描述符。 只读属性的 <code>__set__</code> 方法只需抛出 AttributeError 异常， 并提供合适的错误消息。</p>
<ul>
<li>用于验证的描述符可以只有 <code>__set__</code> 方法</li>
</ul>
<p>对仅用于验证的描述符来说， <code>__set__</code> 方法应该检查 value 参数获得的值， 如果有效， 使用描述符实例的名称为键， 直接在实例的 <code>__dict__</code> 属性中设置。 这样， 从实例中读取同名属性的速度很快， 因为不用经过 <code>__get__</code> 方法处理。 </p>
<ul>
<li>仅有 <code>__get__</code> 方法的描述符可以实现高效缓存</li>
</ul>
<p>如果只编写了 <code>__get__</code> 方法， 那么创建的是非覆盖型描述符。 这种描述符可用于执行某些耗费资源的计算， 然后为实例设置同名属性，缓存结果。 同名实例属性会遮盖描述符， 因此后续访问会直接从实例的 <code>__dict__</code> 属性中获取值， 而不会再触发描述符的 <code>__get__</code> 方法。</p>
<ul>
<li>非特殊的方法可以被实例属性遮盖</li>
</ul>
<p>由于函数和方法只实现了 <code>__get__</code> 方法， 它们不会处理同名实例属性的赋值操作。 因此， 像 my_obj.the_method = 7 这样简单赋值之后， 后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。 然而， 特殊方法不受这个问题的影响。 解释器只会在类中寻找特殊的方法， 也就是说， repr(x) 执行的其实是 <code>x.__class__.__repr__(x)</code>， 因此 x 的 <code>__repr__</code> 属性对 repr(x) 方法调用没有影响。 出于同样的原因， 实例的 <code>__getattr__</code> 属性不会破坏常规的属性访问规则。</p>
<h1 id="类元编程"><a href="#类元编程" class="headerlink" title="类元编程"></a>类元编程</h1><p>类元编程是指在运行时创建或定制类的技艺。元类是类元编程最高级的工具： 使用元类可以创建具有某种特质的全新类种， 例如我们见过的抽象基类。</p>
<h2 id="类工厂函数"><a href="#类工厂函数" class="headerlink" title="类工厂函数"></a>类工厂函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight, owner)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.owner = owner</span><br></pre></td></tr></table></figure>
<p>避免编写上述样板代码，我们下面创建一个类工厂函数，即可变对象版本的collections.namedtuple。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_names)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        field_names = field_names.replace(<span class="string">','</span>, <span class="string">' '</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:  <span class="comment"># 不能调用.replace或.split方法</span></span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 假定field_names本就是标识符组成的序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建元组，这将成为新建类的 __slots__ 属性；这么做还设定了拆包和字符串表示形式中各字段的顺序</span></span><br><span class="line">    field_names = tuple(field_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        attrs = dict(zip(self.__slots__, args))</span><br><span class="line">        attrs.update(kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        values = <span class="string">', '</span>.join(<span class="string">'&#123;&#125;=&#123;!r&#125;'</span>.format(*i)</span><br><span class="line">                           <span class="keyword">for</span> i <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;&#125;)'</span>.format(self.__class__.__name__, values)</span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(__slots__=field_names,</span><br><span class="line">                     __init__=__init__,</span><br><span class="line">                     __iter__=__iter__,</span><br><span class="line">                     __repr__=__repr__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (object,), cls_attrs)  <span class="comment"># 调用 type 构造方法，构建新类，然后返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog = record_factory(<span class="string">'Dog'</span>, <span class="string">'name weight owner'</span>)</span><br><span class="line">rex = Dog(<span class="string">'Rex'</span>, <span class="number">30</span>, <span class="string">'Bob'</span>)</span><br><span class="line">print(rex)  <span class="comment"># Dog(name='Rex', weight=30, owner='Bob')</span></span><br></pre></td></tr></table></figure>
<p>type 的实例是类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ty = type(<span class="string">'MyClass'</span>, (object,), &#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">print(type(ty))  <span class="comment"># &lt;class 'type'&gt;</span></span><br><span class="line">obj = ty()</span><br><span class="line">print(obj)  <span class="comment"># &lt;__main__.MyClass object at ...&gt;</span></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(type(MyClass))  <span class="comment"># &lt;class 'type'&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="定制描述符的类装饰器"><a href="#定制描述符的类装饰器" class="headerlink" title="定制描述符的类装饰器"></a>定制描述符的类装饰器</h2><p>类装饰器与函数装饰器非常类似， 是参数为类对象的函数， 返回原来的类或修改后的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span>  <span class="comment"># 类装饰器的参数是一个类</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">()</span>:</span></span><br><span class="line">    desc = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br></pre></td></tr></table></figure>
<p>类装饰器能以较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。</p>
<p>类装饰器有个重大缺点： 只对直接依附的类有效。 这意味着， 被装饰的类的子类可能继承也可能不继承装饰器所做的改动，这个缺点在下面解决。</p>
<h2 id="导入时和运行时比较"><a href="#导入时和运行时比较" class="headerlink" title="导入时和运行时比较"></a>导入时和运行时比较</h2><p><img src="/images/python/fluent_python/导入时和运行时.png" alt="导入时和运行时比较"></p>
<p>evaltime.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    </span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure>
<p>evalsupport.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span>  <span class="comment"># cls（self）：这是要初始化的类对象（例如 ClassFive）</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span>  <span class="comment"># self，是初始化类的实例</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure>
<p>场景1：import evaltime</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime</span><br><span class="line"></span><br><span class="line"><span class="comment"># evalsupport 模块中的所有顶层代码在导入模块时运行； 解释器会编译 deco_alpha 函数， 但是不会执行定义体。</span></span><br><span class="line">&lt;[<span class="number">100</span>] &gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>] &gt; MetaAleph body  <span class="comment"># MetaAleph 类的定义体运行了</span></span><br><span class="line">&lt;[<span class="number">700</span>] &gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>] &gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>] &gt; ClassOne body  <span class="comment"># 每个类的定义体都执行了</span></span><br><span class="line">&lt;[<span class="number">6</span>] &gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>] &gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>] &gt; deco_alpha  <span class="comment"># 先计算被装饰的类 ClassThree 的定义体， 然后运行装饰器函数。</span></span><br><span class="line">&lt;[<span class="number">9</span>] &gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">14</span>] &gt; evaltime module end  <span class="comment"># evaltime 模块是导入的， 因此不会运行 if __name__ == '__main__': 块</span></span><br></pre></td></tr></table></figure>
<p>场景2：python3 evaltime.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>py evaltime.py</span><br><span class="line"></span><br><span class="line">&lt;[<span class="number">100</span>] &gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>] &gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>] &gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>] &gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>] &gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>] &gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>] &gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>] &gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>] &gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">11</span>] &gt; ClassOne tests ..............................</span><br><span class="line">&lt;[<span class="number">3</span>] &gt; ClassOne.__init__</span><br><span class="line">&lt;[<span class="number">5</span>] &gt; ClassOne.method_x</span><br><span class="line">&lt;[<span class="number">12</span>] &gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>] &gt; deco_alpha: inner_1</span><br><span class="line">&lt;[<span class="number">13</span>] &gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>] &gt; ClassFour.method_y  <span class="comment"># 类装饰器可能对子类没有影响</span></span><br><span class="line">&lt;[<span class="number">14</span>] &gt; evaltime module end</span><br><span class="line">&lt;[<span class="number">4</span>] &gt; ClassOne.__del__  <span class="comment"># 程序结束时， 绑定在全局变量 one 上的 ClassOne 实例才会被垃圾回收程序回收。</span></span><br></pre></td></tr></table></figure>
<h2 id="元类基础知识"><a href="#元类基础知识" class="headerlink" title="元类基础知识"></a>元类基础知识</h2><p>元类是制造类的工厂， 不过不是函数， 而是类。元类是用于构建类的类。</p>
<p>根据 Python 对象模型， 类是对象， 因此类肯定是另外某个类的实例。 默认情况下， Python 中的类是 type 类的实例。 也就是说， type 是大多数内置的类和用户定义的类的元类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'spam'</span>.__class__)  <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(str.__class__)  <span class="comment"># &lt;class 'type'&gt;</span></span><br><span class="line">print(type.__class__)  <span class="comment"># 为了避免无限回溯， type 是其自身的实例。</span></span><br></pre></td></tr></table></figure>
<p>type和object的关系</p>
<p><img src="/images/python/fluent_python/type和object.png" alt="type和object"></p>
<p>ABCMeta和type的关系</p>
<p><img src="/images/python/fluent_python/ABCMeta和type.png" alt="ABCMeta和type"></p>
<p>所有类都是 type 的实例， 但是元类还是 type 的子类， 因此可以作为制造类的工厂。 具体来说， 元类可以通过实现 <code>__init__</code> 方法定制实例。 元类的 <code>__init__</code> 方法可以做到类装饰器能做的任何事情， 但是作用更大。</p>
<p>元类计算时间的练习：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_z'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure>
<p>场景3：import evaltime_meta</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta</span><br><span class="line"></span><br><span class="line">&lt;[<span class="number">100</span>] &gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>] &gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>] &gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>] &gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>] &gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>] &gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>] &gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>] &gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>] &gt; MetaAleph.__init__   <span class="comment">#创建 ClassFive 时调用了 MetaAleph.__init__ 方法</span></span><br><span class="line">&lt;[<span class="number">9</span>] &gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>] &gt; MetaAleph.__init__   <span class="comment">#创建 ClassFive 的子类 ClassSix 时也调用了 MetaAleph.__init__ 方法</span></span><br><span class="line">&lt;[<span class="number">15</span>] &gt; evaltime_meta module end</span><br></pre></td></tr></table></figure>
<p>场景4：py evaltime_meta.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>py evaltime_meta.py</span><br><span class="line"></span><br><span class="line">&lt;[<span class="number">100</span>] &gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>] &gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>] &gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>] &gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>] &gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>] &gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>] &gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>] &gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>] &gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">9</span>] &gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>] &gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">11</span>] &gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>] &gt; deco_alpha: inner_1</span><br><span class="line">&lt;[<span class="number">12</span>] &gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>] &gt; ClassFour.method_y <span class="comment">#没有直接依附装饰器的 ClassFour 类不受影响</span></span><br><span class="line">&lt;[<span class="number">13</span>] &gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>] &gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>] &gt; MetaAleph.__init__: inner_2</span><br><span class="line">&lt;[<span class="number">14</span>] &gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>] &gt; ClassFive.__init__</span><br><span class="line">&lt;[<span class="number">600</span>] &gt; MetaAleph.__init__: inner_2  <span class="comment">#ClassSix 类没有直接引用 MetaAleph 类， 但是却受到了影响， 因为它是 ClassFive 的子类， 进而也是 MetaAleph 类的实例， 所以由 MetaAleph.__init__ 方法初始化。</span></span><br><span class="line">&lt;[<span class="number">15</span>] &gt; evaltime_meta module end</span><br></pre></td></tr></table></figure>
<h2 id="定制描述符的元类"><a href="#定制描述符的元类" class="headerlink" title="定制描述符的元类"></a>定制描述符的元类</h2><p>替代 @entity 装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类， 用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span>  <span class="comment"># 在超类（在这里是 type） 上调用 __init__ 方法</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        <span class="keyword">for</span> name, attr <span class="keyword">in</span> attr_dict.items():  <span class="comment"># 与 @entity 装饰器的逻辑一样</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> line_item <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span><span class="params">(model.Entity)</span>:</span></span><br><span class="line">    desc = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="元类的特殊方法-prepare"><a href="#元类的特殊方法-prepare" class="headerlink" title="元类的特殊方法 prepare"></a>元类的特殊方法 <strong>prepare</strong></h2><p>在某些应用中， 可能需要知道类的属性定义的顺序。<br>type 构造方法及元类的 <code>__new__</code> 和 <code>__init__</code> 方法都会收到要计算的类的定义体， 形式是名称到属性的映射。 然而在默认情况下， 那个映射是字典； 也就是说，元类或类装饰器获得映射时， 属性在类定义体中的顺序已经丢失了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""元类， 用于创建带有验证字段的业务实体"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        cls._field_names = []  <span class="comment"># 非私有属性</span></span><br><span class="line">        <span class="comment"># 这里的 attr_dict 是那个OrderedDict 对象， 由解释器在调用 __init__ 方法之前调用 __prepare__ 方法时获得（prepare-&gt;new-&gt;init）</span></span><br><span class="line">        <span class="comment"># 因此， 这个 for 循环会按照添加属性的顺序迭代属性</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line">                cls._field_names.append(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">field_names</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> cls._field_names:</span><br><span class="line">            <span class="keyword">yield</span> name</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> LineItem.field_names():</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>
<p><code>__prepare__</code>：这个特殊方法只在元类中有用， 而且必须声明为类方法（即使用@classmethod 装饰器定义） 。 解释器调用元类的 <code>__new__</code> 方法之前会先调用 <code>__prepare__</code> 方法， 使用类定义体中的属性创建映射。 <code>__prepare__</code> 方法的第一个参数是元类， 随后两个参数分别是要构建的类的名称和基类组成的元组， 返回值必须是映射。 元类构建新类时，<code>__prepare__</code> 方法返回的映射会传给 <code>__new__</code> 方法的最后一个参数， 然后再传给 <code>__init__</code> 方法。</p>
<p>框架和库会使用元类协助程序员执行很多任务， 例如：</p>
<ul>
<li>验证属性</li>
<li>一次把装饰器依附到多个方法上</li>
<li>序列化对象或转换数据</li>
<li>对象关系映射</li>
<li>基于对象的持久存储</li>
<li>动态转换使用其他语言编写的类结构</li>
</ul>
<h2 id="类作为对象"><a href="#类作为对象" class="headerlink" title="类作为对象"></a>类作为对象</h2><p>Python 数据模型为每个类定义了很多属性，除了 <code>__mro__</code> 、 <code>__class__</code> 和 <code>__name__</code> 属性之外，还有：</p>
<p><code>cls.__bases__</code>：由类的基类组成的元组</p>
<p><code>cls.__qualname__</code>：其值是类或函数的限定名称， 即从模块的全局作用域到类的点分路径。例如：内部类ClassTwo 的 <code>__qualname__</code> 属性， 其值是字符串 ‘ClassOne.ClassTwo’， 而 <code>__name__</code> 属性的值是 ‘ClassTwo’</p>
<p><code>cls.__subclasses__()</code>：包含类的直接子类。 这个方法的实现使用弱引用， 防止在超类和子类（子类在 <code>__bases__</code> 属性中储存指向超类的强引用） 之间出现循环引用。 这个方法返回的列表中是内存里现存的子类</p>
<p><code>cls.mro()</code>：超类元组</p>
<p><strong>dir(…)</strong> 函数不会列出本节提到的任何一个属性。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>欢迎打赏</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Alan 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Alan 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Alan
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://adieUkid.github.io/2018/09/13/流畅的Python_注释笔记/" title="流畅的Python_注释笔记">http://adieUkid.github.io/2018/09/13/流畅的Python_注释笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/30/Python编程：从入门到实践_注释笔记/" rel="next" title="Python编程：从入门到实践_注释笔记">
                <i class="fa fa-chevron-left"></i> Python编程：从入门到实践_注释笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/24/Python网络数据采集/" rel="prev" title="Python网络数据采集_注释笔记">
                Python网络数据采集_注释笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Alan" />
            
              <p class="site-author-name" itemprop="name">Alan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python-数据模型"><span class="nav-number">1.</span> <span class="nav-text">Python 数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊方法"><span class="nav-number">1.1.</span> <span class="nav-text">特殊方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列构成的数组"><span class="nav-number">2.</span> <span class="nav-text">序列构成的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内置序列"><span class="nav-number">2.1.</span> <span class="nav-text">内置序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表推导式、生成器表达式"><span class="nav-number">2.2.</span> <span class="nav-text">列表推导式、生成器表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#列表推导式"><span class="nav-number">2.2.1.</span> <span class="nav-text">列表推导式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">2.3.</span> <span class="nav-text">元组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#具名元组"><span class="nav-number">2.3.1.</span> <span class="nav-text">具名元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组拆包"><span class="nav-number">2.3.2.</span> <span class="nav-text">元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套元组拆包"><span class="nav-number">2.3.3.</span> <span class="nav-text">嵌套元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具名元组-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">具名元组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">2.4.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对序列使用-和"><span class="nav-number">2.5.</span> <span class="nav-text">对序列使用+和*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列的增量赋值"><span class="nav-number">2.6.</span> <span class="nav-text">序列的增量赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-sort-和sorted"><span class="nav-number">2.7.</span> <span class="nav-text">list.sort()和sorted()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bisect管理已排序的序列"><span class="nav-number">2.8.</span> <span class="nav-text">bisect管理已排序的序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表不是首选时"><span class="nav-number">2.9.</span> <span class="nav-text">列表不是首选时</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字典和集合"><span class="nav-number">3.</span> <span class="nav-text">字典和集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#泛映射类型"><span class="nav-number">3.1.</span> <span class="nav-text">泛映射类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典推导"><span class="nav-number">3.2.</span> <span class="nav-text">字典推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射的常用方法"><span class="nav-number">3.3.</span> <span class="nav-text">映射的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典的变种"><span class="nav-number">3.4.</span> <span class="nav-text">字典的变种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">3.5.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dict和set的背后原理"><span class="nav-number">3.6.</span> <span class="nav-text">dict和set的背后原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#散列表算法"><span class="nav-number">3.6.1.</span> <span class="nav-text">散列表算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict的实现及其限制"><span class="nav-number">3.6.2.</span> <span class="nav-text">dict的实现及其限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文本和字节序列"><span class="nav-number">4.</span> <span class="nav-text">文本和字节序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符问题"><span class="nav-number">4.1.</span> <span class="nav-text">字符问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节概要"><span class="nav-number">4.2.</span> <span class="nav-text">字节概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码异常"><span class="nav-number">4.3.</span> <span class="nav-text">编码异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理文本文件"><span class="nav-number">4.4.</span> <span class="nav-text">处理文本文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一等函数"><span class="nav-number">5.</span> <span class="nav-text">一等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#把函数视作对象"><span class="nav-number">5.1.</span> <span class="nav-text">把函数视作对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数"><span class="nav-number">5.2.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数"><span class="nav-number">5.3.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可调用对象"><span class="nav-number">5.4.</span> <span class="nav-text">可调用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户定义的可调用类型"><span class="nav-number">5.5.</span> <span class="nav-text">用户定义的可调用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数内省"><span class="nav-number">5.6.</span> <span class="nav-text">函数内省</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从定位参数到仅限关键字参数"><span class="nav-number">5.7.</span> <span class="nav-text">从定位参数到仅限关键字参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取关于参数的信息"><span class="nav-number">5.8.</span> <span class="nav-text">获取关于参数的信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数注解"><span class="nav-number">5.9.</span> <span class="nav-text">函数注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程的包"><span class="nav-number">5.10.</span> <span class="nav-text">函数式编程的包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用一等函数实现设计模式"><span class="nav-number">6.</span> <span class="nav-text">使用一等函数实现设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-number">6.1.</span> <span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#经典的策略模式"><span class="nav-number">6.1.1.</span> <span class="nav-text">经典的策略模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数实现“策略”模式"><span class="nav-number">6.1.2.</span> <span class="nav-text">函数实现“策略”模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出模块中的全部策略"><span class="nav-number">6.1.3.</span> <span class="nav-text">找出模块中的全部策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式"><span class="nav-number">6.2.</span> <span class="nav-text">命令模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数装饰器和闭包"><span class="nav-number">7.</span> <span class="nav-text">函数装饰器和闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器基础"><span class="nav-number">7.1.</span> <span class="nav-text">装饰器基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器的执行时机"><span class="nav-number">7.2.</span> <span class="nav-text">装饰器的执行时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量作用域"><span class="nav-number">7.3.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">7.4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nonlocal-声明"><span class="nav-number">7.5.</span> <span class="nav-text">nonlocal 声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个简单的装饰器"><span class="nav-number">7.6.</span> <span class="nav-text">实现一个简单的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库中的装饰器"><span class="nav-number">7.7.</span> <span class="nav-text">标准库中的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#叠放装饰器"><span class="nav-number">7.8.</span> <span class="nav-text">叠放装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数化装饰器"><span class="nav-number">7.9.</span> <span class="nav-text">参数化装饰器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象引用、可变性和垃圾回收"><span class="nav-number">8.</span> <span class="nav-text">对象引用、可变性和垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标识、相等性和别名"><span class="nav-number">8.1.</span> <span class="nav-text">标识、相等性和别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认浅复制"><span class="nav-number">8.2.</span> <span class="nav-text">默认浅复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的参数作为引用时"><span class="nav-number">8.3.</span> <span class="nav-text">函数的参数作为引用时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#del-和-垃圾回收"><span class="nav-number">8.4.</span> <span class="nav-text">del 和 垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弱引用"><span class="nav-number">8.5.</span> <span class="nav-text">弱引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#符合Python风格的对象"><span class="nav-number">9.</span> <span class="nav-text">符合Python风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#向量类"><span class="nav-number">9.1.</span> <span class="nav-text">向量类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classmethod与staticmethod"><span class="nav-number">9.2.</span> <span class="nav-text">classmethod与staticmethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化显示"><span class="nav-number">9.3.</span> <span class="nav-text">格式化显示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可散列的Vector2d"><span class="nav-number">9.4.</span> <span class="nav-text">可散列的Vector2d</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有属性和“受保护”的属性"><span class="nav-number">9.5.</span> <span class="nav-text">私有属性和“受保护”的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用slots类属性节省空间"><span class="nav-number">9.6.</span> <span class="nav-text">使用slots类属性节省空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖类属性"><span class="nav-number">9.7.</span> <span class="nav-text">覆盖类属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列的修改、散列和切片"><span class="nav-number">10.</span> <span class="nav-text">序列的修改、散列和切片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#协议和鸭子类型"><span class="nav-number">10.1.</span> <span class="nav-text">协议和鸭子类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可切片的序列"><span class="nav-number">10.2.</span> <span class="nav-text">可切片的序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切片原理"><span class="nav-number">10.2.1.</span> <span class="nav-text">切片原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义切片的getitem"><span class="nav-number">10.2.2.</span> <span class="nav-text">自定义切片的getitem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态存取属性"><span class="nav-number">10.3.</span> <span class="nav-text">动态存取属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列和快速等值测试"><span class="nav-number">10.4.</span> <span class="nav-text">散列和快速等值测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口：从协议到抽象基类"><span class="nav-number">11.</span> <span class="nav-text">接口：从协议到抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口和协议"><span class="nav-number">11.1.</span> <span class="nav-text">接口和协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用猴子补丁在运行时实现协议"><span class="nav-number">11.2.</span> <span class="nav-text">使用猴子补丁在运行时实现协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库中的抽象基类"><span class="nav-number">11.3.</span> <span class="nav-text">标准库中的抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collections-abc模块中的抽象基类"><span class="nav-number">11.3.1.</span> <span class="nav-text">collections.abc模块中的抽象基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象基类的数字塔"><span class="nav-number">11.3.2.</span> <span class="nav-text">抽象基类的数字塔</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义使用一个抽象基类"><span class="nav-number">11.4.</span> <span class="nav-text">定义使用一个抽象基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用register"><span class="nav-number">11.5.</span> <span class="nav-text">使用register</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承的优缺点"><span class="nav-number">12.</span> <span class="nav-text">继承的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#子类化内置类型很麻烦"><span class="nav-number">12.1.</span> <span class="nav-text">子类化内置类型很麻烦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承和方法解析顺序"><span class="nav-number">12.2.</span> <span class="nav-text">多重继承和方法解析顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正确重载运算符"><span class="nav-number">13.</span> <span class="nav-text">正确重载运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可迭代的对象、迭代器和生成器"><span class="nav-number">14.</span> <span class="nav-text">可迭代的对象、迭代器和生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单词序列"><span class="nav-number">14.1.</span> <span class="nav-text">单词序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可迭代的对象与迭代器的对比"><span class="nav-number">14.2.</span> <span class="nav-text">可迭代的对象与迭代器的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型的迭代器"><span class="nav-number">14.3.</span> <span class="nav-text">典型的迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器函数"><span class="nav-number">14.4.</span> <span class="nav-text">生成器函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性实现"><span class="nav-number">14.5.</span> <span class="nav-text">惰性实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器表达式"><span class="nav-number">14.6.</span> <span class="nav-text">生成器表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何时使用生成器表达式"><span class="nav-number">14.7.</span> <span class="nav-text">何时使用生成器表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等差数列生成器"><span class="nav-number">14.8.</span> <span class="nav-text">等差数列生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库中的生成器函数"><span class="nav-number">14.9.</span> <span class="nav-text">标准库中的生成器函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-from"><span class="nav-number">14.10.</span> <span class="nav-text">yield from</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可迭代的归约函数"><span class="nav-number">14.11.</span> <span class="nav-text">可迭代的归约函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入分析iter函数"><span class="nav-number">14.12.</span> <span class="nav-text">深入分析iter函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#上下文管理器和else块"><span class="nav-number">15.</span> <span class="nav-text">上下文管理器和else块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if之外的else块"><span class="nav-number">15.1.</span> <span class="nav-text">if之外的else块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文管理器和with块"><span class="nav-number">15.2.</span> <span class="nav-text">上下文管理器和with块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-contextmanager"><span class="nav-number">15.3.</span> <span class="nav-text">使用@contextmanager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程"><span class="nav-number">16.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用作协程的生成器的基本行为"><span class="nav-number">16.1.</span> <span class="nav-text">用作协程的生成器的基本行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用协程计算移动平均值"><span class="nav-number">16.2.</span> <span class="nav-text">使用协程计算移动平均值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预激协程的装饰器"><span class="nav-number">16.3.</span> <span class="nav-text">预激协程的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止协程和异常处理"><span class="nav-number">16.4.</span> <span class="nav-text">终止协程和异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让协程返回值"><span class="nav-number">16.5.</span> <span class="nav-text">让协程返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用yield-from"><span class="nav-number">16.6.</span> <span class="nav-text">使用yield from</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-from-的意义"><span class="nav-number">16.7.</span> <span class="nav-text">yield from 的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散事件仿真"><span class="nav-number">16.8.</span> <span class="nav-text">离散事件仿真</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用期物处理并发"><span class="nav-number">17.</span> <span class="nav-text">使用期物处理并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络下载的三种风格"><span class="nav-number">17.1.</span> <span class="nav-text">网络下载的三种风格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#依序下载的脚本"><span class="nav-number">17.1.1.</span> <span class="nav-text">依序下载的脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用concurrent-futures模块下载"><span class="nav-number">17.1.2.</span> <span class="nav-text">使用concurrent.futures模块下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#期物在哪里"><span class="nav-number">17.1.3.</span> <span class="nav-text">期物在哪里</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞性I-O和GIL"><span class="nav-number">17.2.</span> <span class="nav-text">阻塞性I/O和GIL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用concurrent-futures模块启动进程"><span class="nav-number">17.3.</span> <span class="nav-text">使用concurrent.futures模块启动进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验Executor-map方法"><span class="nav-number">17.4.</span> <span class="nav-text">实验Executor.map方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和多进程的替代方案"><span class="nav-number">17.4.1.</span> <span class="nav-text">线程和多进程的替代方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用asyncio包处理并发"><span class="nav-number">18.</span> <span class="nav-text">使用asyncio包处理并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程与协程的对比"><span class="nav-number">18.1.</span> <span class="nav-text">线程与协程的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncio-Future和concurrent-futures-Future区别"><span class="nav-number">18.1.1.</span> <span class="nav-text">asyncio.Future和concurrent.futures.Future区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用asyncio和aiohttp包下载"><span class="nav-number">18.2.</span> <span class="nav-text">使用asyncio和aiohttp包下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免阻塞型调用"><span class="nav-number">18.3.</span> <span class="nav-text">避免阻塞型调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改进asyncio下载脚本"><span class="nav-number">18.4.</span> <span class="nav-text">改进asyncio下载脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从回调到期物和协程"><span class="nav-number">18.5.</span> <span class="nav-text">从回调到期物和协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用asyncio包编写服务器"><span class="nav-number">18.6.</span> <span class="nav-text">使用asyncio包编写服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用asyncio包编写TCP服务器"><span class="nav-number">18.6.1.</span> <span class="nav-text">使用asyncio包编写TCP服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用aiohttp包编写Web服务器"><span class="nav-number">18.6.2.</span> <span class="nav-text">使用aiohttp包编写Web服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态属性和特性"><span class="nav-number">19.</span> <span class="nav-text">动态属性和特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用动态属性转换数据"><span class="nav-number">19.1.</span> <span class="nav-text">使用动态属性转换数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用动态属性访问JSON类数据"><span class="nav-number">19.1.1.</span> <span class="nav-text">使用动态属性访问JSON类数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用new方法灵活创建对象"><span class="nav-number">19.1.2.</span> <span class="nav-text">使用new方法灵活创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shelve模块"><span class="nav-number">19.1.3.</span> <span class="nav-text">shelve模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用特性验证属性"><span class="nav-number">19.2.</span> <span class="nav-text">使用特性验证属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性全解析"><span class="nav-number">19.3.</span> <span class="nav-text">特性全解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特性会覆盖实例属性"><span class="nav-number">19.3.1.</span> <span class="nav-text">特性会覆盖实例属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性工厂"><span class="nav-number">19.4.</span> <span class="nav-text">特性工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理属性删除操作"><span class="nav-number">19.5.</span> <span class="nav-text">处理属性删除操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理属性的重要属性和函数"><span class="nav-number">19.6.</span> <span class="nav-text">处理属性的重要属性和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊属性"><span class="nav-number">19.6.1.</span> <span class="nav-text">特殊属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置函数"><span class="nav-number">19.6.2.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊方法-1"><span class="nav-number">19.6.3.</span> <span class="nav-text">特殊方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性描述符"><span class="nav-number">20.</span> <span class="nav-text">属性描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#描述符示例：验证属性"><span class="nav-number">20.1.</span> <span class="nav-text">描述符示例：验证属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动获取储存属性的名称"><span class="nav-number">20.1.1.</span> <span class="nav-text">自动获取储存属性的名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构描述符"><span class="nav-number">20.1.2.</span> <span class="nav-text">重构描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖型和非覆盖型描述符对比"><span class="nav-number">20.2.</span> <span class="nav-text">覆盖型和非覆盖型描述符对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在类中覆盖描述符"><span class="nav-number">20.2.1.</span> <span class="nav-text">在类中覆盖描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法是描述符"><span class="nav-number">20.3.</span> <span class="nav-text">方法是描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#描述符用法建议"><span class="nav-number">20.4.</span> <span class="nav-text">描述符用法建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类元编程"><span class="nav-number">21.</span> <span class="nav-text">类元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类工厂函数"><span class="nav-number">21.1.</span> <span class="nav-text">类工厂函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制描述符的类装饰器"><span class="nav-number">21.2.</span> <span class="nav-text">定制描述符的类装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入时和运行时比较"><span class="nav-number">21.3.</span> <span class="nav-text">导入时和运行时比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元类基础知识"><span class="nav-number">21.4.</span> <span class="nav-text">元类基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制描述符的元类"><span class="nav-number">21.5.</span> <span class="nav-text">定制描述符的元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元类的特殊方法-prepare"><span class="nav-number">21.6.</span> <span class="nav-text">元类的特殊方法 prepare</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类作为对象"><span class="nav-number">21.7.</span> <span class="nav-text">类作为对象</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://pages.github.com">GitHub Pages</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="250" alpha="0.6"  zIndex="0" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>

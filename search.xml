<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[流畅的Python_注释笔记]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%B5%81%E7%95%85%E7%9A%84Python_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python 数据模型特殊方法内置函数会调用特殊方法，一般无需直接调用特殊方法，除了__init__方法。 __len__：调用len(obj)，解释器会自动调用 obj.__len__()。 对于Python内置的类型（list,str等），CPython还会抄近路提升计算速度，直接返回PyVarObject（内存中长度可变的内置对象的C语言结构体）里的ob_size属性 __repr__：被repr()函数调用，或者直接在控制台输入，把一个对象用字符串的形式表达出来以便辨认。面向开发者使用 __str__：被str()函数调用，或者用print函数打印时调用，返回的字符串对中断用户更友好。面向用户的 区别：如果一个对象没有__str__函数，Python又需要调用时，会用__repr__代替 __add__：执行+运算 __mul__：执行*运算 PS：中缀运算符的原则是，不改变操作对象，而是产生出一个新的值 __rmul__：解决交换律问题 __bool__：被bool()函数调用，应该返回bool类型 12def __bool__(self): return bool(self.a or self.b) 序列构成的数组内置序列按元素类型分类： 容器序列：list、tuple、collections.deque，可以存放不同类型的数据 扁平序列：str、bytes、bytearray、memoryview、array.array，只能容纳一种类型 按是否能被修改分类： 可变序列：list、bytearray、array.array、collections.deque、memoryview 不可变序列：tuple、str、bytes 列表推导式、生成器表达式列表推导式生成新的列表 str = &#39;测试字符串&#39;arr = [ord(x) for x in str if ord(x) &gt; 30000] 与使用filter加map的比较 list(filter(lambda x: x &gt; 30000, map(ord, str))) 生成器表达式：生成列表以外的序列类型 逐个的产出元素，而不会在内存中留下一个列表，节省内存，提高效率。 str = &#39;测试字符串&#39;*1000000arr = (ord(x) for x in str if ord(x) &gt; 30000) 上述操作花费0.2s，如果换成列表推到式，将大约花费2s。 如果声称其表达式是函数调用中的唯一参数，那么不再需要括号围起来，如 tuple(x for x in arr)。 元组可以作为“不可变列表”，还可以用于没有字段名的纪录。 具名元组namedtuple，有名称和字段名的元组。 定义：x = (&#39;Beijing&#39;, 2018) 或省略括号 x = &#39;Beijing&#39;, 2018 访问元素：x[0] 元组拆包city, year, pop = (&#39;Tokyo&#39;, 2003, 32450) 等式左边是元组的省略括号的写法，等同于(city,year,pop) = ...。 元组拆包可以应用到任何可迭代对象上，唯一的要求是，接受元素的元组的空档数必须要和被迭代对象中的元素数量一致。 对于不关心的元素，可以用_占位符代替。对于多余的元素，可以用*来忽略。 str = &#39;测试字符串&#39; a,b,_,*args = str *前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置。 拆包时带的变量类型被定义为list，如果加在方法的形参上面，则变量被定义为tuple。 a, *b = &#39;Beijing&#39;, 2018, 1print(type(b)) #list 12def my(a,*b): print(type(b)) #tuple 不使用中间变量交换两个变量的值 b,a=a,b 嵌套元组拆包name, cc, pop, (lat, long) = (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667))print(&#39;{:^15}|{:^9.4f}|{:^9.4f}&#39;.format(name, lat, long)) # :9个单位的空间，保留4位小数，^居中 具名元组12345import collectionsCity = namedtuple('City', 'name country population coordinates') City = namedtuple('City', ['name','country','population','coordinates']) tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) 元素访问： tokyo[0]，tokyo.name 属性和方法： City._fields：返回包含这个类所有字段名称的元组City._make()：通过接受一个可迭代对象来生成一个实例，和调用City()是一样的City._asdict()：以 collections.OrderedDict 形式返回，方便遍历元素 12for k, v in tokyo._asdict().items(): print(k, v) 元组与列表的方法区别：元组没有列表的增删改/清空等方法，包含查询和统计的方法。 切片slice 切片和区间操作都不包含范围的最后一个元素，（左闭右开）。 优点：快速计算长度，后一个数减前一个数。快速分割元素不重叠，mylist[:10]和mylist[10:] s = &#39;bicycle&#39;print(s[::3]) # start:stop:step 相当于s[slice(None,None,3)]，即s.__getitem__(slice(None,None,3))。 多维切片：二维的numpy.ndarray就可以用a[m:n, k:l]的方式来得到二维切片 省略：ellipsis，Ellipsis对象是ellipsis类的单一实例 给切片复制：切片可以放在复制语句的左边或作为del操作的对象，可以对序列进行嫁接，切除或就地修改 1234l[2:5] = [20,30]del l[5:7]l[3::2] = [11,22]l[2:5] = 100 #报错，如果把切片放在赋值左侧·1，右侧则必须是个可迭代对象 对序列使用+和*浅表复制，序列中包含引用的话，仅仅是复制引用。 创建一个3*3的列表 arr = [[&#39;_&#39;]*3]*3 实际上创建了一个[‘‘,’‘,’_’]列表，然后复制了3次引用。改变其中一个列表的元素 arr[1][2] = &#39;0&#39;，将影响三个列表。 等同于： 123row = ['_'] * 3for i in range(3): arr.append(row) 正确的做法： arr = [[&#39;_&#39;] * 3 for i in range(3)] 序列的增量赋值a += b 增量赋值运算符+=和*=的表现取决于他们第一个操作对象。背后的特殊方法时 __iadd__ 和 __imul__ ，如果a实现了 __iadd__ ，则会调用这个方法。 对于可变序列（list,bytearray…）来说，a就会就地改动（in-place），好像调用了 a.extend(b) 一样。 如果a没有实现 __iadd__，这个表达式就变得跟 a = a+b 一样了。会计算 a+b，得出一个新对象，然后赋值给a。 123456789l=[1,2,3]print(id(l))l*=2print(id(l)) # 两次id相等，in-place，效率高t=(1,2,3)print(id(t))t*=2print(id(t)) # 两次id不等，新的对象，效率低 问题： 123456t = (1, 2, [30, 40])try: t[2] += [50, 60]except Exception as e: passprint(t) 结果：t变成（1,2,[30,40,50,60]），但仍会抛出TypeError异常 查看类似过程的字节码： 12import disdis.dis('s[a]+=b') 步骤说明： 将s[a]的值存入TOS（Top Of Stack） TOS += b，TOS是一个list，可以执行 s[a] = TOS，s是不可变的，所以执行失败 结论： 不要把可变对象放在元组里 增量赋值不是一个原子操作 list.sort()和sorted()list.sort()，就地排序，返回None。 sorted，新建一个列表并返回。可接受任何形式的可迭代对象，如，字符串，不可变序列或生成器，最后都会返回一个列表。 list.sort()和sorted()的参数： reverse：为True则降序排列 key：一个只有一个参数的函数，key=len，key=myfunc，默认值是恒等函数 包含key参数的内置函数还有，min()和max()等。 bisect管理已排序的序列bisect模块包含两个主要函数，bisect和insort，都利用二分查找来在有序序列中查找或插入元素。 bisect.bisect：bisect(haystack, needle)，在haystack(干草垛，必须升序)中找needle(针，待插入的元素)的位置 可选参数，lo和hi，控制搜索的范围。 bisect其实是bisect_right函数的别名，如果碰到相等的元素，bisect_right返回的插入位置是原序列中被插入元素相等的元素的之后的位置。 相应的还有bisect_left，对于这种情况则返回相等元素的原位置，即相等元素之前的位置。 123456789import bisectdef grade(score): breakpoints = [60, 70, 80, 90] grades = 'FDCBA' i = bisect.bisect(breakpoints, score) return grades[i]print([grade(x) for x in [59, 66, 99]]) bisect.insort：insort(seq,item)把变量item插入到序列seq中，并能保持seq的升序顺序 123456import bisectimport randoml = []for i in range(10): bisect.insort(l, random.randrange(100)) 列表不是首选时如果要存放1000万个浮点数的话，数组（array）的效率要高得多。因为数组背后存的不是float对象，而是数字的机器翻译，也就是字节表述。就跟C语言中的数组一样。 如果要频繁的进行FIFO的操作，deque速度会更快。如果检查元素是否存在的频率很高，用set更合适。因为set专为检查元素是否存在做过优化。 数组：数组支持所有跟可变序列有关的操作，pop，insert，extend。还有从文件读和存入文件的更快的方法，frombytes，tofile 12345678910111213141516from array import arrayfrom random import random# 用生成器表达式建立一个1000万个浮点数的数组。'd'是类型码，代表数组只能存放双精度浮点数fs = array('d', (random() for i in range(10**7)))print(fs[-1])fp = open('floats.bin', 'wb')fs.tofile(fp) #将1000万个浮点数以二进制格式写入一个二进制文件fp.close()fs2 = array('d')fp = open('floats.bin','rb')fs2.fromfile(fp, 10**7)fp.close()print(fs2[-1])print(fs == fs2) #两个数组的内容一模一样 从Python3.4开始，数组类型不在支持诸如list.sort()这种就地排序，排序要用sorted函数新建一个数组。 内存视图：能让用户在不复制内容的情况下操作同一个数组的不同切片。memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象。 1234567891011121314import arraynums = array.array('i', [2, 3, 4, 5])memv = memoryview(nums)print(memv[0]) #2memv[0] = 1print(nums[0]) #1memv_n = memv.cast('B')memv_n[0] = 9print(memv[0]) #9print(memv_n[0]) #9print(nums[0]) #9 双向队列和其他形式的队列： 1234567891011121314151617from collections import dequedq = deque(range(10), maxlen=10) # maxlen可选参数，指定队列的最大长度，超出的元素将被舍弃dq.rotate(3) # 旋转：接受一个参数n，当n&gt;0时，从队列最右边的n个元素移动到队列左边。当n&lt;0时，反之。dq.rotate(-4)dq.append(10) # 从队列尾部（右边）添加一个元素dq.append([10, 20]) # 从队列尾部添加一个列表元素dq.appendleft(10) # 与append相反dq.appendleft([10, 20])dq.extend([10, 20]) # 接受可迭代对象，将所有元素一个一个添加到队列右边dq.extendleft([10, 20]) # 与extend相反dq.pop() # 删除队列最右边的一个元素，并返回dq.popleft() append和popleft都是原子操作，deque可以在多线程程序中安全地当做FIFO的栈使用。 字典和集合泛映射类型collections.abc模块中有Mapping和MutableMapping两个基类。 ABC：Abstract Base Class 非抽象映射类型一般不直接继承这些abc，他们的作用是作为形式化文档，为dict何其他映射类型定义形式接口。还可以通过isinstance来判断某个数据是否是映射类型。 my_dict = {} # 或其他类型的Map isinstance(my_dict, abc.Mapping) # True 可散列类型： 如果一个对象是可散列的，那么在这个对象的声明周期中，它的散列值是不变的，而且这个对象要实现hash()方法。 另外可散列对象还有有qe()方法，这样才能和其他键值作比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。 原子不可变数据类型（str、butes和数值），frozenset，tuple（必须包含的所有元素都是可散列类型），都是可散列的。 可散列tuple： 1234t1 = (1, 2)hash(t1)t2 = (1, [])hash(t2) # TypeError: unhashable type: 'list' 字典的构造方法： 1234567a = &#123;'one': 1&#125;b = dict(&#123;'one': 1&#125;)c = dict(one=1)d = dict(zip(['one'], [1]))e = dict([('one', 1)])a == b == c == d == e # True 字典推导1234567891011CODES = [ (86, 'China'), (91, 'India'), (1, 'USA'), (55, 'Brazil'), (7, 'Russia'), (81, 'Japan')]codes = &#123;contry: code for code, contry in CODES if code &gt; 10&#125;print(codes) 映射的常用方法setdefault： my_dict.setdefault(key, []).append(new_value) 等价于 123if key not in my_dict: my_dict[key] = []my_dict[key].append(new_value) 等价于 123v = my_dict.get(key, [])v.append(new_value)my_dict[key] = v defaultdict： 123from collections import defaultdictd = defaultdict(list)d[key].append(new_value) 把list的构造方法作为default_factory来创建一个defaultdict，只会在getitem里被调用，其他比如get方法，在找不到键时只会返回None。 __missing__： 只被__getitem__调用，如defaultdict，在__missing__中实现了调用default_factory方法。 字典的变种collections.OrderedDict：添加键的时候会保持顺序 collections.ChainMap：可以容纳数个不同的映射对象，然后进行键查找时会把这些对象当成一个整体逐个查找。这个功能再给有嵌套作用域的语言做解释器的时候很有用，如： 1234567891011import builtinsprint(locals()) #本地变量print(globals()) #全局变量print(vars(builtins))collections.Counter：键-整数计数器，每次更新一个键的时候都会增加这个计数器。这个类型可以用来给可散列对象技术。ct = collections.Counter('absdfxasdasdf')ct.update('aaaadd')print(ct.most_common(2)) # 最常见的2个键和它们的计数 UserDict：子类化，以UserDict为基类创造自定义映射类型，它并不是dict的子类，继承的是MutableMapping，有一个data属性，是一个dict实例。最终存储数据的地方。 不可变映射类型：返回一个映射的只读视图，但是时动态的，如果原映射有改动，可以通过视图观察到。 123456789from types import MappingProxyTyped = &#123;1: 'A'&#125;d_proxy = MappingProxyType(d)print(d_proxy[1])d_proxy[1] = 'B' # 报错d[1] = 'B'print(d_proxy[1]) set保证元素的唯一性，集合中的元素必须是可散列的，set本身是不可散列的，但是frozenset可以 中缀运算：a|b，返回合集。a&amp;b返回交集，a-b返回差集 计算重叠元素的个数 found = len(needles &amp; haystack) #两侧都需要是集合类型 或 found = len(set(needles).intersection(haystack)) #如果一个对象还不是集合类型 直接使用set的交集计算比for遍历计算求和快的多 字面量：s = {1} 或 s = set([1]) 空集：s = set()，不能写{}（空字典） 直接写{1}的方式更快，因为Python会利用一个专门的BUILD_SET的字节码来创建集合。查看区别： 1234from dis import disdis('&#123;1&#125;')dis('set([1])') fronzenset只能通过构造方法创建。 集合推导： 123from unicodedata import nameprint(&#123;chr(c) for c in range(32, 256) if 'SIGN' in name(chr(c), '')&#125;) 集合的的继承关系： 基本操作： +/-/&amp;/| e in s，元素e是否属于s s &lt;= z，s是否为z的子集 s &lt; z，s是否为z的真子集 s &gt;=z/s&gt;z dict和set的背后原理散列表其实是一个稀疏数组（总有空白元素的数组），散列表的单元通常叫做表元（bucket），在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。 因为Python会设法保证大概还有三分之一的表元是空的，所以快要达到这个阈值时，原有的散列表会被复制到更大的空间里面进行扩容。 散列表算法为了获取dict[search_key]背后的值，Python首先会调用hash(search_key)来计算search_key的散列值，取这个值最低的几位数字（具体几位看当前散列表的大小）当做偏移量，在散列表里查找表元。若找到的表元是空的，则抛出KeyError异常。若不是空的，则表元里会有一堆found_key:found_value，这时候进行校验search_key == found_key是否为真，如果相等，则返回found_value。 如果search_key和found_key不匹配的话，这种情况称为散列冲突。发生这种情况原因是，把随机元素映射到几位的数字上，而索引又依赖于这几位数字的一部分而已。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当成索引寻找表元，重复以上给欧成。 添加和更新操作几乎跟上面一样。 dict的实现及其限制 键必须是可散列的 支持hash()函数，并且通过 __hash__() 方法得到的散列值是不变的。 支持通过 __eq__() 方法来检测相对性。 若a == b为真，则hash(a) == hash(b) 也为真。 所有由用户自定义的对象默认都是可散列的，散列值由id()来计算获取。 字典内存开销巨大 为了保持散列表是稀疏的，将降低在空间上的效率。 如果要存放数量巨大的纪录，元组或具名元组构成的列表是比较好的选择。 键查询很快 dict是典型的空间换时间，内存开销大，但是查询速度快。 键的次序取决于添加顺序 添加新键又发生散列冲突时，新键可能会被安排存放到另一个位置。这将导致键的顺序乱掉。 往字典里添加新键可能会改变已有键的顺序 无论何时添加新键，Python解释器都可能做出字典寇蓉的决定。扩容导致把字典中已有的元素添加到更大的新表中，过程中如果发生散列冲突，将导致新标中键的次序变化。因此不要同时对字典进行迭代和修改，最好分开两步进行。 文本和字节序列字符问题Unicode字符标识和字节表述： 字符的标识，即码位。是0~1114111的数字，以4~6个十六进制数字表示。 字节表述取决于所用的编码，是在码位和字节序列之间转换时使用的算法。如UTF-8，字符在ASCII范围内用的编码成1个字节，一个汉字占3个字节。 字节概要调用各自的构造方法，构建bytes或bytearray实例。 一个str对象和一个encoding关键字参数。 一个可迭代对象，提供0~255之间的数值。 一个实现了缓冲协议的对象（bytes，bytearray，memoryview，array.array），把源对象中的字节序列复制到新建的二进制序列中。 12345678910cafe = bytes('café', encoding='utf8')print(cafe) # b'caf\xc3\xa9'print(type(cafe)) # bytesprint(cafe[0]) # 99 0~255的整数print(cafe[:1]) # b'c' 一个字节的切片仍是bytes类型cafe_arr = bytearray(cafe)print(cafe_arr) # bytearray(b'caf\xc3\xa9')print(cafe_arr[-1:]) # bytearray(b'\xa9') 各个字节的值可能使用下列三种不同的方式显示， 可打印的ASCII范围内的字节（空格到~），使用ASCII字符本身。 制表符、换行符、回车符和\，使用转义序列\t、\n、\t和\。 其他字节，使用十六进制转义序列（\x00） 编码异常UnicodeEncodeError：编码时，编解码器没有定义某个字符时，就会抛出 123456city = 'São Paulo'city.encode('utf_8')city.encode('cp437') #抛出异常city.encode('cp437', errors='ignore') #忽略并删除无法编码的字符city.encode('cp437', errors='replace') #把无法编码的字符替换成'?'city.encode('cp437', errors='xmlcharrefreplace') #把无法编码的字符替换成XML实体 UnicodeDecodeError：解码时碰到无法转换的字节序列时会抛出 1234octets = b'Montr\xe9al'octets.decode('cp1252')octets.decode('utf_8') #抛出异常octets.decode('utf_8', errors='replace') #\xe9替换成“黑色菱形问号”（码位是U+FFFD），这是官方指定的 REPLACEMENT CHARACTER（替换字符），表示未知字符。 处理文本文件123456789import osopen('cafe.txt', 'w', encoding='utf_8').write('café') # 返回写入Unicode字符数，4# 报告文件中有5个字节：caf是ASKII范围内的字符，占一个字节，最后一个特殊字符占两个字节os.stat('cafe.txt').st_size print(open('cafe.txt', encoding='utf8').read())fp4 = open('cafe.txt', 'rb') # 以二进制模式打开文件。常规代码只应该使用二进制模式打开二进制文件fp4.read() # b'caf\xc3\xa9' 如果读取时不指定编码格式，那么Python会使用系统默认的编码，很有可能出现乱码。所以需要在多台设备或场合下运行的代码，打开读取文件时应始终明确传入encoding参数。 编码默认值： 12345678910111213141516171819202122import sysimport localeexpressions = """ locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding()"""my_file = open('dummy', 'w')for expression in expressions.split(): value = eval(expression) print(expression.rjust(30), '-&gt;', repr(value)) 输出： 1234567891011locale.getpreferredencoding() -&gt; 'cp936' type(my_file) -&gt; &lt;class '_io.TextIOWrapper'&gt; my_file.encoding -&gt; 'cp936' sys.stdout.isatty() -&gt; True sys.stdout.encoding -&gt; 'utf-8' sys.stdin.isatty() -&gt; True sys.stdin.encoding -&gt; 'utf-8' sys.stderr.isatty() -&gt; True sys.stderr.encoding -&gt; 'utf-8' sys.getdefaultencoding() -&gt; 'utf-8'sys.getfilesystemencoding() -&gt; 'utf-8' 一等函数把函数视作对象“一等对象”的定义为满足下述条件的程序实体： 函数是一等对象。 在运行时创建。 可以赋值给变量，通过变量调用。 能作为参数传给函数。 能作为函数的返回结果。 123456789101112def factorial(n): '''return n!''' return 1 if n &lt; 2 else n * factorial(n-1)print(factorial(42))print(factorial.__doc__)print(type(factorial))fact = factorialprint(fact(5))print(map(fact, range(10)))print(list(map(fact, range(10)))) 高阶函数接受函数为参数或返回函数为结果的是函数是高阶函数，如map，sorted map，filter返回生成器，因此现在它们的直接替代品是生成器表达式。 functools.reduce，最常用于求和。 all(iterable)，如果iterable的每个元素都是真值，就返回True。 any(iterable)，如果iterable中有元素是真值，就返回True。 匿名函数因为句法限制，lambda函数的定义体不能赋值和使用while等语句，在Python中很少使用。 12words = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']print(sorted(words, key=lambda word: word[::-1])) 可调用对象可被调用运算符（即()）应用的，叫做可调用对象，可以使用callable()函数判断。 包括： 用户定义的函数（def或lambda创建） 内置函数（C语言实现的函数，如len） 内置方法（C语言实现的方法，如dict.get） 方法（在类的定义体中定义的函数） 类（调用顺序为 __new__，__init__ 初始化实例，然后返回给调用方） 类的实例（定义了 __call__ 方法的类） 生成器函数（使用yield关键字的函数或方法，返回的是生成器对象） 用户定义的可调用类型实现了 __call__ 的对象： 123456789101112class Bingo(): def __init__(self, items): self._items = list(items) def pick(self): return self._items.pop() def __call__(self): return self.pick()b = Bingo(range(3))print(b()) 函数内省dir函数可以探知对象的属性，计算出函数专有而一般对象没有的属性： 12345class C(): passc = C()def func(): passprint(set(dir(func))-set(dir(c))) 从定位参数到仅限关键字参数123456789101112131415161718192021def tag(name='p', *content, cls=None, **attrs): if cls: attrs['class'] = cls if attrs: attrs_str = ''.join(' &#123;&#125;="&#123;&#125;"'.format(attr, value) for attr, value in attrs.items()) else: attrs_str = '' if content: return '\n'.join('&lt;&#123;&#125;&#123;&#125;&gt;&#123;&#125;&lt;/&#123;&#125;&gt;'.format(name, attrs_str, c, name) for c in content) return '&lt;&#123;&#125;&#123;&#125; /&gt;'.format(name, attrs_str)print(tag('br'))print(tag('p', 'hello'))print(tag('p', 'hello', 'world', id='33', cls='side'))print(tag(content='内容', name='img'))d = &#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;print(tag(**d)) cls即仅限关键字的参数，因为未指定关键字的参数会被cls前面的*content捕获，并且cls有默认值可不指定，所以想要指定的话就必须指定关键字。 获取关于参数的信息1234567891011from inspect import signaturedef tag(name, *content, cls=None, **attrs): passprint(tag.__defaults__) # None,如果形参是name='xx',则是('xx',)。返回一个元组，保存的定位参数和关键字参数的默认值print(tag.__code__) # &lt;code object tag at ...&gt;，一个 code 对象引用， 自身也有很多属性print(tag.__code__.co_varnames) # ('name', 'cls', 'content', 'attrs') print(tag.__code__.co_argcount) # 1 更好更直观的方式： 12345678910111213141516171819202122232425sig = signature(tag)print(sig) # (name='p', *content, cls=None, **attrs)for name, param in sig.parameters.items(): print(param.kind, ':', name, '=', param.default) # POSITIONAL_OR_KEYWORD : name = &lt;class 'inspect._empty'&gt;。通过定位参数和关键字参数传入的形参 # VAR_POSITIONAL : content = &lt;class 'inspect._empty'&gt;。定位参数元组 # KEYWORD_ONLY : cls = None。仅限关键字参数 # VAR_KEYWORD : attrs = &lt;class 'inspect._empty'&gt;。关键字参数字典。my_tag = &#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;bound_args = sig.bind(**my_tag) # 尝试绑定，验证参数，规则同调用# &lt;BoundArguments (name=&#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;)&gt;print(bound_args)for name, value in bound_args.arguments.items(): print(name, '=', value) # name = img # cls = framed # attrs = &#123;'title': 'Sunset Boulevard', 'src': 'sunset.jpg'&#125;del my_tag['name']bound_args = sig.bind(**my_tag) #抛出TypeError，缺少name参数。或提供name的默认值 函数注解123456789101112from inspect import signaturedef clip(text: str, max_len: 'int &gt; 0123'=80) -&gt; str: passsig = signature(clip)print(sig.return_annotation) # &lt;class 'str'&gt;for param in sig.parameters.values(): note = repr(param.annotation).ljust(30) print(note, ':', param.name, '=', param.default) # &lt;class 'str'&gt; : text = &lt;class 'inspect._empty'&gt; # 'int &gt; 0123' : max_len = 80 函数式编程的包operator模块：多个算术运算符提供了对应的函数， 从而避免编写lambda a, b: a*b这种平凡的匿名函数。 12345678910111213141516171819202122232425262728293031323334from functools import reducefrom operator import muldef fact(n): # return reduce(lambda curr, item: curr*item, range(1, n+1)) return reduce(mul, range(1, n+1))itemgetter，itemgetter(1) 即 lambda fields: fields[1]attrgetterfrom operator import itemgetter, attrgetterfrom collections import namedtuplemetro_data = [ ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),]for city in sorted(metro_data, key=itemgetter(1)): # 按某个字段排序 print(city)for city in metro_data: print(itemgetter(0, 1)(city))LatLong = namedtuple('LatLong', 'lat long')Metropolis = namedtuple('Metropolis', 'name cc pop coord')metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) for name, cc, pop, (lat, long) in metro_data]print(metro_areas[0])print(metro_areas[0].coord.lat)name_lat = attrgetter('name', 'coord.lat')for city in sorted(metro_areas, key=attrgetter('coord.lat')): print(name_lat(city)) methodcaller： 123456789101112131415161718192021from operator import methodcallers = 'The time has come'upcase = methodcaller('upper')hiphenate = methodcaller('replace', ' ', '-')print(upcase(s))print(hiphenate(s))使用functools.partial 冻结参数：即柯里化，基于一个函数创建一个新的可调用对象，固定指定某些参数from operator import mulfrom functools import partialtriple = partial(mul, 3)print(list(triple(i) for i in range(10)))picture = partial(tag, 'img', cls='pic-frame')picture(src='some.jpg') 使用一等函数实现设计模式策略模式经典的策略模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from abc import ABC, abstractmethodfrom collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem(): def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order(): def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(c.total() for c in self.cart) return self.__total def due(self): if self.promotion: discount = self.promotion.discount(self) else: discount = 0 return self.total()-discount def __repr__(self): fmt = '&lt;Order total:&#123;:.2f&#125; due:&#123;:.2f&#125;' return fmt.format(self.total(), self.due())class Promotion(ABC): @abstractmethod def discount(self, order): passclass FidelityPromo(Promotion): def discount(self, order): return order.total() * .05 if order.customer.fidelity &gt; 1000 else 0class BulkItemPromo(Promotion): def discount(self, order): return sum(item.total()*.1 for item in order.cart if item.quantity &gt;= 20)class LargeOrderPromo(Promotion): def discount(self, order): distinct_items = &#123;item.product for item in order.cart&#125; return order.total() * .07 if len(distinct_items) &gt;= 10 else 0ann = Customer('Ann Smith', 1100)cart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]print(Order(ann, cart, FidelityPromo())) 函数实现“策略”模式12345678910111213141516171819202122def fidelity_promo(order): return order.total() * .05 if order.customer.fidelity &gt; 1000 else 0def bulk_item_promo(order): return sum(item.total()*.1 for item in order.cart if item.quantity &gt;= 20)def large_order_promo(order): distinct_items = &#123;item.product for item in order.cart&#125; return order.total() * .07 if len(distinct_items) &gt;= 10 else 0promos = [fidelity_promo, bulk_item_promo, large_order_promo]def best_promo(order): return max(p(order) for p in promos)print(Order(ann, cart, best_promo)) 找出模块中的全部策略若想添加新的促销策略，要定义函数且加到promos列表中，下面尝试更灵活的方式。 globals：返回一个字典，表示当前的全局符号表 把策略方法封装到promotions模块中，使用inspect内省，取出 内省模块的全局命名空间， 构建 promos 列表： 123promos = [globals()[name] for name in globals() if name.endswith('_promo') and name != 'best_promo'] 内省单独的 promotions 模块， 构建 promos 列表： 1promos = [func for name, func in inspect.getmembers(promotions, inspect.isfunction)] 命令模式命令模式是回调机制的面向对象替代品，目的是解耦调用者和接收者。做法是在调用者和接收者之间放一个Command对象，让它实现execute接口，调用接受者自己的方法执行所需的操作，这样调用者无需了解接收者的接口，不同的接收者也可以适应不同的Command子类。 在 Python 中使用函数或可调用对象实现回调更自然，可以不用为调用者提供一个Command实例，而是给它一个函数，调用者不用调用command.execute()，直接调用command()即可。 12345678class MacroCommand(): def __init__(self, commands): self.commands = commands def __call__(self): for command in self.commands: command() 函数装饰器和闭包装饰器基础装饰器是可调用对象，参数是被装饰的函数。可以把它替换掉也可以原样返回。 12345678910def decorate(func): def inner(): print('running inner') return inner@decoratedef target(): print('running target')print(target) # &lt;function decorate.&lt;locals&gt;.inner at ...&gt; 装饰器只是语法糖： 123@decoratedef target(): pass 可以转换为： 123def target(): passtarget = decorate(target() 装饰器的执行时机装饰器在被装饰的函数定义之后立即执行，这通常是在导入时（即Python加载模块时）。 1234567891011121314def reister(func): print('running reister &#123;&#125;'.format(func)) return func@reisterdef f1(): print('running f1')def main(): print('running main') f1()if __name__ == '__main__': main() 打印如下： 123running reister &lt;function f1 at ...&gt;running mainrunning f1 装饰器在真实代码中的常用方式： 装饰器通常定义在一个模块中，然后应用到其他模块中的函数上。 大多数装饰器会在内部定义一个函数，然后将其返回。也可能原样返回，比如很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处。比如上面的例子中，使用促销装饰器把所有促销注册起来，供best_promo使用。 变量作用域1234567b = 6def func(a): print(a) print(b) b = 9func(1) 会报错local variable ‘b’ referenced before assignment，Python判断b是局部变量，运行时从本地环境中获取，但是还未定义，所以报错。通过dis查看操作b的字节码为LOAD_GLOBAL。 改为： 123456789b = 6def func(a): global b #让解释器把b当成全局变量 print(a) print(b) b = 9func(1)print(b) # 9 不再报错，读取和修改的都是全局变量。通过dis查看操作b的字节码为LOAD_FAST。CPython VM是栈机器，LOAD和POP操作引用的是栈。 闭包闭包指延伸了作用域的函数， 它能访问定义体之外定义的非全局变量。 1234567891011121314def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()print(avg(10))print(avg(22)) 在 averager 中， series 是自由变量（free variable， 指未在本地作用域中绑定的变量）。 1234print(avg.__code__.co_varnames) # 局部变量print(avg.__code__.co_freevars) # 自由变量print(avg.__closure__) # 一个元组 (&lt;cell at 0x0000028489CDA4C8: list object at ...&gt;,)print(avg.__closure__[0].cell_contents # nonlocal 声明123456789101112131415def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total # python3的关键字，python2中通过赋值给可变对象（如字典）的属性来实现。不加这一句下面将会报错，因为相当于声明了局部变量的count 。count = count + 1。在读取count时报错 count += 1 total += new_value return total / count return averageravg = make_averager()print(avg(1))print(avg(4)) 实现一个简单的装饰器12345678910111213141516171819202122232425262728293031import timedef clock(func): def clocked(*args): t0 = time.perf_counter() result = func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = ','.join(repr(arg) for arg in args) print('[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'.format(elapsed, name, arg_str, result)) return result return clocked@clockdef snooze(seconds): time.sleep(seconds)@clockdef factorial(n): return n if n == 1 else n * factorial(n-1)if __name__ == '__main__': print(factorial.__name__) # clocked。factorial已经被替换为clocked函数，__name__属性被覆盖 print('*'*40, 'Calling snooze(.123)') snooze(.123) print('*'*40, 'Calling factorial(6)') factorial(6) 使用functools.wraps装饰器解决name覆盖的问题： functools.wraps 装饰器会把相关的属性从 func 复制到 clocked 中。 1234567891011121314151617181920def clock(func): @functools.wraps(func) def clocked(*args, **kwargs): # 支持关键字参数 t0 = time.perf_counter() result = func(*args, **kwargs) elapsed = time.perf_counter() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['&#123;&#125;=&#123;&#125;'.format(k, v) for k, v in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'.format(elapsed, name, arg_str, result)) return result return clocked 标准库中的装饰器functools.lru_cache： lru，即“Least Recently Used”。 它把耗时的函数的结果保存起来， 避免相同的参数重复计算。缓存不会无限制增长， 一段时间不用的缓存会被扔掉。 1234567891011import functools@functools.lru_cache() # ()调用，可传入配置参数@clockdef fibonacci(n): if n &lt; 2: return n return fibonacci(n-2) + fibonacci(n-1)if __name__ == '__main__': print(fibonacci(20)) 极大的减少调用次数。 functools.lru_cache(maxsize=128, typed=False) 参数： maxsize，指定存储多少个调用的结果，应该设为2的幂。 typed，True会把不同参数类型得到的结果区分开，比如1和1.0。 因为lru_cache使用字典存储结果，所以被修饰的函数，所有参数都必须是可散列的。 functools.singledispatch： Python 不支持重载方法或函数， 所以我们不能使用不同的签名定义函数的变体， 也无法使用不同的方式处理不同的数据类型。 在Python 中， 一种常见的做法是把函数变成一个分派函数。singledispatch装饰器可以把整体方案拆分成多个模块。 12345678910111213141516171819from functools import singledispatchfrom collections import abcimport numbersimport html@singledispatchdef htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content)@htmlize.register(numbers.Integral)def _(n): # 函数名称无所谓 return '&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'.format(n)@htmlize.register(tuple)@htmlize.register(abc.MutableSequence) #可以叠放多个 register 装饰器def _(seq): inner = '&lt;/li&gt;\n&lt;li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\n&lt;li&gt;' + inner + '&lt;/li&gt;\n&lt;/ul&gt;' 叠放装饰器1234@d1@d2def f(): print('f') 相当于： 123def f(): print('f')f = d1(d2(f)) 参数化装饰器12345678910111213141516171819202122registry = set()def register(active=True): def decorate(func): print('running register(active=&#123;&#125;)-&gt;decorate(&#123;&#125;)'.format(active, func)) registry.add(func) if active else registry.discard(func) return func return decorate@register(active=False)def f1(): print('running f1()')@register()def f2(): print('running f2()')print(registry) # 只有f2 装饰器函数金字塔： 12345678910111213141516171819import timedef clock(): # 装饰器工厂 def decorate(func): # 装饰器 def clocked(*_args): # 包装被装饰的函数 t0 = time.time() _result = func(*_args) # 被包装的函数返回的真正结果 elapsed = time.time() - t0 # pass print('1') return _result # clocked会取代原函数，因此应该返回被装饰函数的返回值 return clocked # 装饰器返回包装函数 return decorate # 工厂返回一个装饰器@clock()def funcname(): pass 对象引用、可变性和垃圾回收标识、相等性和别名id()： 在 CPython 中， id() 返回对象的内存地址， 但是在其他 Python 解释器中可能是别的值。 关键是， ID 一定是唯一的数值标注， 而且在对象的生命周期中绝不会变。 ==和is： is运算符比==速度快，==是语法糖，等同于a.__eq__(b) 默认浅复制列表的内置构造函数或list[:]语句，做的都是浅复制（只复制最外层的容器，容器中的元素只复制引用）。 123456789101112l1 = [3, [66, 55, 44], (7, 8, 9)]l2 = list(l1)l1.append(100) # l1的容器添加一个元素l1[1].remove(55) print('l1:', l1)print('l2:', l2)l2[1] += [33, 22]l2[2] += (10, 11) # l2 创建了新的元组print('l1:', l1)print('l2:', l2) 深复制和浅复制： 1234from copy import deepcopycopy.copy(list) # 浅复制copy.deepcopy(list) # 深复制 函数的参数作为引用时Python 唯一支持的参数传递模式是共享传参，指函数的各个形式参数获得实参中各个引用的副本。 也就是说， 函数内部的形参是实参的别名。 123456789101112131415161718def f(a, b): a += b return ax = 1y = 2f(x, y)print(x, y) # x未改变a = [1, 2]b = [3, 4]f(a, b)print(a, b) # a改变t = (10, 20)u = (30, 40)f(t, u)print(t, u) # t未改变 不要使用可变类型作为参数的默认值，如： 12def __init__(self, passengers=[]): self.passengers = passengers 默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象， 而且修改了它的值， 那么后续的函数调用都会受到影响。 默认值会储存在class.__init__.__defaults__的属性里（一个tuple）。 防御可变对象参数： 当参数是可变对象时，如果没有约定的情况下，最好创造一个可变参数的副本，如： 12345def __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers) 这样就不会影响外部的对象了。 del 和 垃圾回收del语句删除名称，而不是对象。仅当删除的变量保存的是对象的最后一个引用， 或者无法得到对象时，del 命令才可能导致对象被当作垃圾回收。 在 CPython 中， 垃圾回收使用的主要算法是引用计数。 实际上， 每个对象都会统计有多少引用指向自己。 当引用计数归零时， 对象立即就被销毁： CPython 会在对象上调用 __del__ 方法（如果定义了），然后释放分配给对象的内存。 1234567891011121314import weakrefdef bye(): print('Gone with the wind...')s1 = &#123;1, 2, 3&#125;s2 = s1ender = weakref.finalize(s1, bye)print(ender.alive) # Truedel s1print(ender.alive) # Trues2 = 'spam' # Gone..print(ender.alive) # False 弱引用弱引用不会增加对象的引用数量，不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用而始终缓存对象。 12345678910111213141516&gt;&gt;&gt; import weakref&gt;&gt;&gt; a_set = &#123;0, 1&#125;&gt;&gt;&gt; wref = weakref.ref(a_set) # 创建弱引用&gt;&gt;&gt; wref&lt;weakref at 0x0000021194B76598; to 'set' at 0x00000211969AF588&gt;&gt;&gt;&gt; wref() # 返回被引用的对象，但因为是控制台会话，所以&#123;0,1&#125;会绑定给_变量&#123;0, 1&#125;&gt;&gt;&gt; a_set = &#123;0, 1, 2&#125; # a_set 不再指代&#123;0,1&#125;集合，但是变量_仍然指代它&gt;&gt;&gt; wref()&#123;0, 1&#125;&gt;&gt;&gt; _&#123;0, 1&#125;&gt;&gt;&gt; wref() is None # 返回值False绑定给变量_，&#123;0,1&#125;没有强引用了False&gt;&gt;&gt; wref() is None # &#123;0,1&#125;对象不存在了True weakref.ref类其实是低层接口，最好不要手动处理weakref.ref实例，而是使用weakref集合。 符合Python风格的对象向量类1234567891011121314151617181920212223242526272829303132333435363738394041from array import arrayimport mathclass Vector2d(): typecode = 'd' def __init__(self, x, y): self.x = float(x) self.y = float(y) def __iter__(self): yield self.x yield self.y # return (i for i in (self.x, self.y)) def __repr__(self): class_name = type(self).__name__ return '&#123;&#125;(&#123;!r&#125;,&#123;!r&#125;)'.format(class_name, *self) def __str__(self): return str(tuple(str)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.hypot(self.x, self.y) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv) classmethod与staticmethodclassmethod： 定义操作类的方法，第一个参数是类本身，最常见的用途是定义备选构造函数 staticmethod： 静态方法就是普通函数，只是碰巧在类的定义体中，而不是在模块层定义的。完全可以不用使用它。 123456789101112class Demo(): @classmethod def klassmeth(*args): return args @staticmethod def statmeth(*args): return argsprint(Demo.klassmeth(1)) # (&lt;class '__main__.Demo'&gt;, 1)print(Demo.statmeth(1)) # (1,) 格式化显示委托给相应的 __format__(format_spec) 方法 1234brl = 1/2.43print(brl) # 0.4115226337448559print(format(brl, '.4f')) # 0.4115print('1 BRL = &#123;rate:.2f&#125; USD'.format(rate=brl)) # 1 BRL = 0.41 USD rate是字段名，.4f是格式规范微语言。 整数使用的代码有 ‘bcdoxXn’， 浮点数使用的代码有’eEfFgGn%’， 字符串使用的代码有 ‘s’。 格式规范微语言文档（https://docs.python.org/3/library/string.html#formatspec） 12print(format(42, 'b')) # b二进制 o八进制 x十六进制print(format(2/3, '.1%')) # 66.7% 如果没有定义__format__方法，从object继承的方法会返回str(obj)。 print(format(v)) # (2.0, 3.0) 但是如果传入格式说明符，object.format方法会抛出TypeError。 print(format(v,&#39;.2f)) # TypeError 给Vector2d定义__format__方法： 12345def __format__(self, fmt_spec=''): compoments = (format(c, fmt_spec) for c in self) return '(&#123;&#125;,&#123;&#125;)'.format(*compoments)print(format(v, '.2f')) # (2.00,3.00) 自定义格式代码： 假设我们自定义的代码为p，用来显示极坐标中的向量 123456789101112131415161718def angle(self): return math.atan2(self.y, self.x)def __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '&lt;&#123;&#125;,&#123;&#125;&gt;' else: coords = self outer_fmt = '(&#123;&#125;,&#123;&#125;)' compoments = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*compoments)print(format(v, 'p')) # &lt;3.605551275463989,0.982793723247329&gt;print(format(v, '.5fp')) # &lt;3.60555,0.98279&gt; 可散列的Vector2d123456789101112131415# other codedef __init__(self, x, y): self.__x = float(x) # 使用两个__把属性"标记"为私有的 self.__y = float(y)@property # 把读值方法标记为特性def x(self): # 方法名即公开属性名 return self.__x@propertydef y(self): return self.__ydef __hash__(self): return hash(self.x) ^ hash(self.y) # 最好使用位运算符异或(^)混合各分量的散列值 让这些向量不可变是有原因的， 因为这样才能实现hash 方法。 私有属性和“受保护”的属性12def __init__(self, x, y): self.__x = float(x) 使用两个_作为前缀命名实例属性，Python会把属性名存入实例的dict属性中，而且会进行“名称改写”，如prop会被改写成_ClassNameprop。 123v = Vector2d(3, 4)print(v.__dict__) # &#123;'_Vector2d__x': 3.0, '_Vector2d__y': 4.0&#125;，__dict__为实例的可读属性的键值字典print(v.__dir__()) # __dir__()方法返回实例和类的所有属性名和方法名的list 也有人不喜欢这种不对称的名称，他们约定使用一个_前缀编写“受保护”的属性，如self._x。Python不会对这种属性名做特殊处理，这仅仅是程序员之间遵守的约定，他们不会在类外部访问这种属性。 使用slots类属性节省空间创建一个类属性，使用 __slots__ 这个名字， 并把它的值设为一个字符串构成的可迭代对象。 12class Vector2d: __slots__ = ('__x', '__y') 作用是告诉解释器，这个类中的所有实例属性都在这儿了！ Python会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的dict属性。当同时有数百万个实例活动时，能节省大量内存。 副作用是定义了slots属性之后，实例不能再有slots 中所列名称之外的其他属性。 但故意这样禁止用户新增属性是不对的。 如果定义了slots属性，且想让对象支持弱引用，则必须把weakref添加到slots中。 解释器会忽略继承的slots属性，所以每个子类都要定义slots属性。 覆盖类属性1234567class Vector2d(): typecode = 'd'v = Vector2d(3, 4)print(v.typecode) # dv.typecode = 'f'print(v.typecode) # f 类属性为实例属性提供默认值，但是并不代表实例拥有此实例，如果为类属性赋值，类属性不会受影响，实例会创建同名的属性覆盖掉类属性。想要修改类属性，需要直接在类上修改，Vector2d.typecode = &#39;f&#39;。 序列的修改、散列和切片1234567891011121314151617181920212223242526272829303132333435363738394041from array import arrayimport reprlibimport mathclass Vector(): typecode = 'd' def __init__(self, components): self._components = array(self.typecode, components) def __iter__(self): return iter(self._components) def __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return 'Vector(&#123;&#125;)'.format(components) def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components)) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.sqrt(sum(x ** 2 for x in self)) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv) reprlib.repr() 函数获取 self._components 的有限长度表示形式（如 array(‘d’, [0.0, 1.0, 2.0, 3.0, 4.0, …])） 。 协议和鸭子类型12345def __len__(self): return len(self._components)def __getitem__(self, index): return self._components[index] 协议是非正式的接口， 只在文档中定义， 在代码中不定义。 例如， Python 的序列协议只需要 __len__ 和 __getitem__ 两个方法。 任何类（如 Spam）只要实现了这两个方法， 就能用在任何期待序列的地方。 12v = Vector([1, 2, 3, 4, 5])print(v[1:2]) # array('d', [2.0]) 可切片的序列切片原理12345678910class MySeq(): def __getitem__(self, index): return indexs = MySeq()print(s[1]) # 1print(s[1:2]) # slice(1, 2, None)print(s[1:2:3]) # slice(1, 2, 3)print(s[1:2:3, 4]) # (slice(1, 2, 3), 4)。多维切片，__getitem__收到的是元组print(s[1:2:3, 4:5]) # (slice(1, 2, 3), slice(4, 5, None)) slice.indices方法： 123print(slice(None, 10, 2)) # slice(None, 10, 2)print(slice(None, 10, 2).indices(5)) # (0, 5, 2)print(slice(-3, None, None).indices(5)) # (2, 5, 1) indices方法提供了内置序列实现的复杂“整顿”逻辑，用于优雅地处理索引缺失、负数、长度过长等情况。如果自定义的getitem最终不是依靠的底层序列，那么可以使用这个方法节省大量时间。 自定义切片的getitem1234567891011121314def __getitem__(self, index): cls = type(self) if isinstance(index, slice): return cls(self._components[index]) # 返回当前类型的切片，而不是委托给数组返回一个数组的切片 elif isinstance(index, numbers.Integral): return self._components[index] else: msg = '&#123;cls.__name__&#125; indices must be integers' raise TypeError(msg.format(cls=cls))s = Vector(range(100))print(type(s[1])) # Vectorprint(type(s[1:10])) # Vectorprint(s[1:10, 2]) # TypeError 动态存取属性使用x、y、z、t来取代v[0]，v[1]，v[2]，v[3]。 123456789def __getattr__(self, name): cls = type(self) if len(name) == 1: pos = cls.shortcut_names.find(name) if len(self._components) &gt; pos &gt;= 0: return self._components[pos] # .__name__会从cls中取值，!r以文本形式'' msg = '&#123;.__name__!r&#125; objects has no attribute &#123;!r&#125;' raise AttributeError(msg.format(cls, name)) 为了防止直接向v.x赋值而创建一个新的属性。 1234567891011121314def __setattr__(self, name, value): cls = type(self) if len(name)=1: if name in cls.shortcut_names: error = 'readonly attribute &#123;attr_name!r&#125;' elif name.islower(): error = "can't set attribute 'a' to 'z' in &#123;cls_name!r&#125;" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value) # 在超类上调用 __setattr__ 方法， 提供标准行为 散列和快速等值测试规约函数reduce,sum,any,all把序列或有限可迭代对象编程一个聚合结果。reduce函数的参数，第一个函数是接受两个参数的函数，第二个参数是一个可迭代的对象，第三个参数是初始值。 reduce(fn,lst)： fn(lst[0],lst[1]) -&gt; r1fn(r1,lst[2]) -&gt; r2fn(r2,lst[3]) -&gt; r3... 实现阶乘的三种方式： 1. 123n = 0for i in range(1, 6): n ^= 1 2. functools.reduce(lambda a, b: a ^ b, range(6)) 3. functools.reduce(operator.xor, range(6)) 把Vector变成可散列的对象：123def __hash__(self): hashes = (hash(x) for x in self._components) return functools.reduce(operator.xor, hashes, 0) 修改 __eq__ 方法： 使用zip函数 1234567def __eq__(self, other): if len(self) != len(other): return False for a, b in zip(self, other): if a != b: return False return True 使用all函数 12def __eq__(self, other): return len(self) == len(other) and all(a == b for a, b in zip(self, other)) 出色的zip函数： zip函数能并行迭代两个或多个可迭代对象，它返回的元组可以拆包成变量，分别对应各个并行输入中的一个元素。 123456from itertools import zip_longestprint(zip(range(3), 'ABC')) # &lt;zip object at ...&gt;print(list(zip(range(3), 'ABC'))) # [(0, 'A'), (1, 'B'), (2, 'C')]# [(0, 'A', 1), (1, 'B', 2), (2, 'C', 3), (-1, -1, 4)]print(list(zip_longest(range(3), 'ABC', [1, 2, 3, 4], fillvalue=-1))) itertools.chain函数：合并两个序列 123456import itertoolsl1 = [1,2,3]t1 = (4,5,6)r1 = itertools.chain(l1,t1)print(r1) #&lt;itertools.chain object at ...&gt; 接口：从协议到抽象基类接口和协议协议：非正式的接口，不能像正式接口那样施加限制，是Python实现多态的方式。一个类可依只实现部分接口，这是允许的。 1234567class Foo: def __getitem__(self, pos): return range(0, 30, 10)[pos]f = Foo()f[1]for i in f: print(i) Foo类没有继承abc.Sequence，只实现了序列协议的一个方法：__getitem__，没有__iter__方法，但是仍然会后备使用__getitem__来进行迭代。没有实现__contains__方法，但是也能使用in运算。 使用猴子补丁在运行时实现协议123456import randomfrom french_deck import FrenchDeckf = FrenchDeck()# 就地打乱, TypeError: 'FrenchDeck' object does not support item assignmentrandom.shuffle(f) 我们可以动态修正这个问题： 12345def set_card(self, position, card): self._cards[position] = cardFrenchDeck.__setitem__ = set_cardrandom.shuffle(f) 猴子补丁： 在运行时修改类或模块， 而不改动源码。 猴子补丁很强大， 但是打补丁的代码与要打补丁的程序耦合十分紧密， 而且往往要处理隐藏和没有文档的部分 标准库中的抽象基类collections.abc模块中的抽象基类collections.abc： Iterable、 Container 和 Sized： 各个集合应该继承这三个抽象基类， 或者至少实现兼容的协议。 Iterable 通过 __iter__ 方法支持迭代， Container 通过__contains__ 方法支持 in 运算符， Sized 通过 __len__ 方法支持len() 函数。 Sequence、 Mapping 和 Set： 这三个是主要的不可变集合类型， 而且各自都有可变的子类。 MappingView： 映射方法 .items()、 .keys() 和 .values() 返回的对象分别是 ItemsView、 KeysView 和 ValuesView 的实例。 前两个类还继承了 Set 类 Callable 和 Hashable： 没有Callable 或 Hashable 的子类。 这两个抽象基类的主要作用是为内置函数 isinstance 提供支持， 以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用， 可以使用内置的 callable() 函数； 但是没有类似的 hashable() 函数， 因此测试对象是否可散列， 最好使用 isinstance(my_obj, Hashable)。 抽象基类的数字塔numbers包定义的抽象基类是线性的层次结构，依次往下是，Number、Complex、Real、Rational、Integral。 检查是否为整数，isinstance(x,numbers.Integral)。 定义使用一个抽象基类定义： 123456789101112131415161718192021222324252627import abcclass Tombola(abc.ABC): #自己定义的抽象基类要继承 abc.ABC。 @abc.abstractmethod def load(self, iterable): """从可迭代对象中添加元素。 """ #抽象方法使用 @abstractmethod 装饰器标记， 而且定义体中通常只有文档字符串。 @abc.abstractmethod def pick(self): """随机删除元素， 然后将其返回。 如果实例为空， 这个方法应该抛出`LookupError`。 """ def loaded(self): #抽象基类可以包含具体方法 """如果至少有一个元素， 返回`True`， 否则返回`False`。 """ return bool(self.inspect()) def inspect(self): """返回一个有序元组， 由当前元素构成。 """ items = [] while True: try: items.append(self.pick()) except LookupError: break self.load(items) #抽象基类中的具体方法可以依赖抽象基类中的其他具体方法、 抽象方法或特性 return tuple(sorted(items)) 错误的实现： 123456from tombola import Tombolaclass Fake(Tombola): passf = Fake() # TypeError: Can't instantiate abstract class Fake with abstract methods load, pick 正确的实现： 123456789101112131415161718192021import randomfrom tombola import Tombolaclass BingoCage(Tombola): def __init__(self, items): self._randomizer = random.SystemRandom() self._items = [] self.load(items) def load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items) def pick(self): try: return self._items.pop() except IndexError as e: raise LookupError('pick from empty BingoCage') def __call__(self): self.pick() 虚拟子类： 在抽象基类上调用register方法，issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。Python也不会做检查。 12345678910111213141516171819from random import randrangefrom tombola import Tombola@Tombola.registerclass TomboList(list): def pick(self): if self: position = randrange(len(self)) return self.pop(position) else: raise LookupError('pop from empty TomboList') load = list.extend def loaded(self): return bool(self) def inspect(self): return tuple(sorted(self)) 虚拟子类检查： 1234567from tombola import Tombolafrom tombolist import TomboListprint(issubclass(TomboList, Tombola)) # Truet = TomboList(range(100))print(isinstance(t, Tombola)) # True __mro__属性：方法解析顺序，按顺序列出类及其超类。 123# (&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)print(TomboList.__mro__)print(Tombola) # &lt;class 'tombola.Tombola'&gt; Tombolist.__mro__ 中没有 Tombola， 因此 Tombolist 没有从Tombola 中继承任何方法。 继承内省属性： 12345# __subclasses__()，这个方法返回类的直接子类列表， 不含虚拟子类。print(Tombola.__subclasses__()) # [&lt;class 'bingo.BingoCage'&gt;]# _abc_registry，只有抽象基类有这个数据属性， 其值是一个 WeakSet 对象， 即抽象类注册的虚拟子类的弱引用。print([x for x in Tombola._abc_registry]) # [&lt;class 'tombolist.TomboList'&gt;] 使用registerTombola.register可以当做类装饰器使用，也可以当做函数调用Tombola.register(TomboList)。这种做法更常见，可用于注册其他地方定义的类，例如，在collections.abc模块的源码中，Sequence.register(tuple)Sequence.register(str)Sequence.register(range)Sequence.register(memoryview) __subclasshook__： 12345678from collections import abcclass Struggle(): def __len__(self): return 23print(issubclass(Struggle, abc.Sized)) # Trueprint(isinstance(Struggle(), abc.Sized)) # True 没有注册和继承，抽象基类也能把一个类识别为虚拟子类，因为abc.Sized实现了一个特殊的类方法，名为__subclasshook__。源码： 12345678910111213class Sized(metaclass=ABCMeta): __slots__ = () @abstractmethod def __len__(self): return 0 @classmethod def __subclasshook__(cls, C): if cls is Sized: if any("__len__" in B.__dict__ for B in C.__mro__): # C及其超类__dict__属性里是否有__len__属性 return True return NotImplemented 继承的优缺点子类化内置类型很麻烦直接子类化内置类型（如 dict、 list 或 str） 容易出错，因为内置类型的方法通常会忽略用户覆盖的方法（这种问题只发生在C语言实现的内置类型内部的方法委托上，而且只影响直接继承内置类型的用户自定义类）。 不要子类化内置类型， 用户自己定义的类应该继承 collections 模块（http://docs.python.org/3/library/collections.html） 中的类， 例如UserDict、 UserList 和 UserString， 这些类做了特殊设计， 因此易于扩展。 多重继承和方法解析顺序12345678910111213141516171819202122class A: def ping(self): print('ping:', self)class B(A): def pong(self): print('pong:', self)class C(A): def pong(self): print('PONG:', self)class D(B, C): # 声明中超类的顺序影响方法解析顺序 def ping(self): super().ping()print('post-ping:', self) def pingpong(self): self.ping() super().ping() self.pong() super().pong() C.pong(self) Python能区分子类调用的是哪个父类的方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order， MRO）。类都有一个名为__mro__的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。 1D.__mro__ # (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;) 也可以在子类中绕过方法解析顺序，直接调用某个超类的方法，比如，A.ping(self)，而不是super().ping()。 正确重载运算符略 可迭代的对象、迭代器和生成器单词序列12345678910111213141516171819202122232425262728293031import reimport reprlibRE_WORD = re.compile('\w+')class Sentence(): def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __getitem__(self, index): return self.words[index] def __len__(self): return len(self.words) def __repr__(self): return 'Sentence(&#123;&#125;)'.format(reprlib.repr(self.text))from sentence import Sentences = Sentence('"The time has come," the Walrus said,')print(s) # Sentence('"The time ha... Walrus said,')for word in s: print(word) # 可以迭代print(list(s)) 可以迭代的原因： 从 Python 3.4 开始， 检查对象 x 能否迭代， 最准确的方法是：调用 iter(x) 函数(或直接进行迭代)， 如果不可迭代， 再处理 TypeError 异常。 这比使用 isinstance(x, abc.Iterable) 更准确， 因为 iter(x)函数会考虑到遗留的 __getitem__ 方法， 而 abc.Iterable 类则不考虑。 可迭代的对象与迭代器的对比使用 iter 内置函数可以获取迭代器的对象。 如果对象实现了能返回迭代器的 __iter__ 方法， 那么对象就是可迭代的。 可迭代的对象和迭代器之间的关系： Python 从可迭代的对象中获取迭代器。 123s = 'ABC'for c in s: print(c) 字符串’ABC’是可迭代的对象，背后运行的是迭代器。 不使用for语句的话，就需要使用while和iter组合迭代。 12345678910s = 'ABC'it = iter(s)while True: try: print(next(it)) #或 print(it.__next__()) except StopIteration as e: # 如果没有下一个元素，抛出StopIteration del it # 释放引用，废弃迭代器对象 break 标准的迭代器接口有两个方法： __next__，返回下一个可用元素或无元素时抛出StopIteration异常。 __iter__，返回self，以便在应该使用可迭代对象的地方使用迭代器，例如在for循环中。 collections.abc.Iterator抽象基类中定义了__next__抽象方法。且这个抽象基类继承自collections.abc.Iterable类，这个类中定义了__iter__抽象方法。 123i1 = id(s.__iter__()) # 返回字符串的迭代器i2 = id(s.__iter__().__iter__()) # 迭代器返回自身print(i1 == i2) # True Python中的迭代器是一种协议，而不是某种特定的类型。所以判断一个对象x(或类)是否为迭代器最好的方式是调用isinstance(x, abc.Iterator)(或issubclass)，得益于Iterator.__subclasshook__ 方法， 即使对象 x 所属的类不是Iterator 类的真实子类或虚拟子类， 也能这样检查。 123456789class X(): def __iter__(self): pass def __next__(self): passprint(issubclass(X, collections.abc.Iterator)) #True，因为实现了__iter__和__next__协议print(isinstance(X(), collections.abc.Iterable)) #True，因为事先了__iter__协议 迭代器的定义： 迭代器是这样的对象： 实现了无参数的 __next__ 方法， 返回序列中的下一个元素； 如果没有元素了， 那么抛出 StopIteration 异常。Python 中的迭代器还实现了 __iter__ 方法， 因此迭代器也可以迭代。 典型的迭代器123456789101112131415161718192021class Sentence(): # ... def __iter__(self): return SentenceIterator(self.words)class SentenceIterator(): def __init__(self, words): self.words = words self.index = 0 def __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word def __iter__(self): return self 为了“支持多种遍历”， 必须能从同一个可迭代的实例中获取多个独立的迭代器， 而且各个迭代器要能维护自身的内部状态， 因此这一模式正确的实现方式是， 每次调用 iter(my_iterable) 都新建一个独立的迭代器。 这就是为什么这个示例需要定义SentenceIterator 类。 可迭代的对象一定不能是自身的迭代器。 也就是说， 可迭代的对象必须实现 __iter__ 方法， 但不能实现 __next__ 方法。另一方面， 迭代器应该一直可以迭。 迭代器的 __iter__ 方法应该返回自身。 生成器函数实现相同功能， 但却符合 Python 习惯的方式是， 用生成器函数代替SentenceIterator 类。 1234567class Sentence(): # ... def __iter__(self): for word in self.words: yield word # 产出当前的word return # 可以不写，会触发生成器对象抛出 StopIteration 异常 生成器函数：只要 Python 函数的定义体中有 yield 关键字， 该函数就是生成器函数。 调用生成器函数时， 会返回一个生成器对象。 也就是说， 生成器函数是生成器工厂。 12345678910111213141516171819def gen_123(): yield 1 yield 2 yield 3 g = gen_123() # 通过生成器函数创建一个新的生成器print(g) # &lt;generator object gen_123 at ...&gt;for i in g: # 迭代生成器时，执行函数到定义体中的下一个yield语句暂停住，返回产出的值 print(i)def gen_AB(): print('start') yield 'A' print('continue') yield 'B' print('end')for i in gen_AB(): print('for:',i) 打印结果： 12345startfor: Acontinuefor: B # 执行了两次for循环中的语句end # 生成器前进到了生成器函数的末尾，但是没有产出返回值(yield关键字)，生成器对象抛出 StopIteration 异常。 for机制会捕获异常， 因此循环终止时没有报错。 惰性实现1234567class Sentence(): # ... def __iter__(self): # finditer函数构建一个迭代器,包含self.text中匹配RE_WORD的单词,产出MatchObject实例。 for match in RE_WORD.finditer(self.text): yield match.group() # match.group()方法从MatchObject实例中提取匹配正则表达式的具体文本。 生成器表达式生成器表达式可以理解为列表推导的惰性版本： 不会迫切地构建列表，而是返回一个生成器， 按需惰性生成元素。 如果说列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。 12def __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text)) 这里不再是生成器函数了(没有yield)，而是使用生成器表达式构建生成器，然后将其返回。 生成器表达式是语法糖： 完全可以替换成生成器函数。 何时使用生成器表达式如果生成器表达式要分成多行写，就使用生成器函数，更灵活，提高可读性，可重用，且可以作为协程使用。 如果函数或构造函数只有一个参数，传入的生成器表达式不用自带一对括号了，只要有一对函数的括号就行了。 等差数列生成器12345678910111213def aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) # 转换类型 forever = end is None # 无穷 index = 0 while forever or result &lt; end: yield result index += 1 result = begin + step * index # 没有不断的累加step的值，为了降低处理浮点数时累积效应致错的风险i = aritprog_gen(0, 1.5)print(next(i))print(next(i))... # 可以无穷迭代 itertools模块生成等差数列： 123gen = itertools.count(0, 1.5)print(next(gen))print(next(gen)) itertools.count函数生成无穷等差数列，作用与上面的函数相同。 itertools.takewhile函数会生成一个使用另一个生成器的生成器， 在指定的条件计算结果为 False 时停止。 因此， 可以把这两个函数结合在一起使用。 12gen = itertools.takewhile(lambda n: n &lt; 5, itertools.count(0, 1.5)) # n是每次返回的产出值[print(g) for g in gen] 重写aritprog_gen函数： 123456def aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) gen = itertools.count(begin, step) while end is not None: gen = itertools.takewhile(lambda n: n &lt; end, gen) return gen 标准库中的生成器函数用于“过滤”的生成器函数： 代码演示： 12345678910111213141516import itertoolsdef vowel(c): return c.lower() in 'aeiou's = 'Aardvark'print(list(filter(vowel, s))) # ['A', 'a', 'a']print(list(itertools.filterfalse(vowel, s))) # ['r', 'd', 'v', 'r', 'k']print(list(itertools.dropwhile(vowel, s))) # ['r', 'd', 'v', 'a', 'r', 'k']print(list(itertools.takewhile(vowel, s))) # ['A', 'a']print(list(itertools.compress(s, (1, 0, 1, 1, 0, 1)))) # ['A', 'r', 'd', 'a']print(list(itertools.islice(s, 4))) # ['A', 'a', 'r', 'd']print(list(itertools.islice(s, 4, 7))) # ['v', 'a', 'r']print(list(itertools.islice(s, 1, 7, 2))) # ['a', 'd', 'a'] takewhile和filter的区别： 12345def condition(e): return e &lt; 5i = itertools.takewhile(condition, itertools.count(0, 2)) # [0, 2, 4] 达成条件则停止迭代i2 = filter(condition, itertools.count(0, 1.5)) # 会卡死，应用到可迭代对象的所有元素，决定是否返回 用于”映射”的生成器函数： 代码演示： 12345678910111213141516171819202122import itertoolsimport operatorsample = [5, 4, 2, 7, 0, 3]print(list(itertools.accumulate(sample))) # [5, 9, 11, 18, 18, 21]，求和print(list(itertools.accumulate(sample, min))) # [5, 4, 2, 2, 0, 0]，求最小值print(list(itertools.accumulate(sample, max))) # [5, 5, 5, 7, 7, 7]，求最大值# [1, 2, 6, 24, 120]，计算1-5的阶乘print(list(itertools.accumulate(range(1, 6), operator.mul)))# [(1, 'a'), (2, 'b'), (3, 'c')]，从start(1)开始给每个元素编号print(list(enumerate('abc', 1)))# [0, 1, 4, 9, 16, 25] 映射求积，到短的迭代对象耗尽位置print(list(map(operator.mul, range(6), range(7))))# ['a', 'bb', 'ccc'] 对一对元素求积print(list(itertools.starmap(operator.mul, zip((1, 2, 3), ('a', 'b', 'c')))))# ['a', 'bb', 'ccc'] 同上print(list(itertools.starmap(operator.mul, enumerate('abc', 1))))# [5.0, 4.5, 3.6666666666666665, 4.5, 3.6, 3.5]，求阶段平均值print(list(itertools.starmap(lambda a, b: b/a, enumerate(itertools.accumulate(sample), 1)))) 用于“合并”的生成器函数： 123456789101112131415print(list(itertools.chain('ABC', range(2)))) # ['A', 'B', 'C', 0, 1]# [0, 'A', 1, 'B', 2, 'C']print(list(itertools.chain.from_iterable(enumerate('ABC'))))print(list(zip('ABC', range(5)))) # [('A', 0), ('B', 1), ('C', 2)]# [('A', 0), ('B', 1), ('C', 2), ('?', 3), ('?', 4)]print(list(itertools.zip_longest('ABC', range(5), fillvalue='?')))itertools.product生成器是计算笛卡尔积的惰性方式print(list(itertools.product('AB'))) # [('A',), ('B',)]# [('A', 0), ('A', 1), ('B', 0), ('B', 1)]print(list(itertools.product('AB', range(2))))# [('A', 'A'), ('A', 'B'), ('B', 'A'), ('B', 'B')]print(list(itertools.product('AB', repeat=2)))print(list(itertools.product('AB', range(2), repeat=2))) 把输入的各个元素扩展成多个输出元素的生成器函数： 1234567891011ct = itertools.count(5)ns = next(ct), next(ct), next(ct)print(ns) # (5, 6, 7)。不能使用ct构建列表，因为ct是无穷的print(list(itertools.islice(itertools.count(), 4))) # [0, 1, 2, 3]，指定大于4的数将会抛出异常cy = itertools.cycle('ABC')print(next(cy)) # Aprint(list(itertools.islice(cy, 5))) # ['B', 'C', 'A', 'B', 'C']rp = itertools.repeat(7, 3)print(next(rp), next(rp), next(rp)) # 7 7 7# [0.0, 1.5, 3.0, 4.5, 6.0]print(list(map(operator.mul, range(5), itertools.repeat(1.5)))) 扩展生成器中的“组合学”生成器函数： 123456# [('A', 'B'), ('A', 'C'), ('B', 'C')]print(list(itertools.combinations('ABC', 2)))# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]print(list(itertools.combinations_with_replacement('ABC', 2)))# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]print(list(itertools.permutations('ABC', 2))) 用于重新排列元素的生成器函数： 1234567891011121314151617print(list(itertools.groupby('AAABB')))# [('A', &lt;itertools._grouper object at ...&gt;), ('B', &lt;itertools._grouper object at ...&gt;)]for key, group in itertools.groupby('AAABB'): print(key, '-&gt;', list(group))# A -&gt; ['A', 'A', 'A']# B -&gt; ['B', 'B']animals = 'rat duck bat eagle shark bear'.split()animals.sort(key=len) # 为了使用groupby函数,输入要有序for length, group in itertools.groupby(reversed(animals), len): print(length, '-&gt;', list(group))# 5 -&gt; ['shark', 'eagle']# 4 -&gt; ['bear', 'duck']# 3 -&gt; ['bat', 'rat']g1, g2 = itertools.tee('ABC')print(next(g1)) # Aprint(list(g2)) # ['A', 'B', 'C'] yield from用于在生成器函数中方便的产出另一个生成器生成的值。 123456789101112def chain(*iterables): for it in iterables: for i in it: yield iprint(list(chain('ABC',range(3))))def chain2(*iterables): for it in iterables: yield from itprint(list(chain2('ABC',range(3)))) 可迭代的归约函数 这里的每个内置函数都可以用functools.reduce实现，内置是为了方便使用。此外，对all和any函数来说，有一项重要的优化措施是 reduce 函数做不到的： 这两个函数会短路。 1234567891011print(all([1, 2, 3])) # Trueprint(all([1, 0, 3])) # Falseprint(all([])) # Trueprint(any([1, 2, 3])) # Trueprint(any([1, 0, 3])) # Trueprint(any([])) # Falseg = (n for n in [0, 0.0, 7, 8])print(any(g)) # True，一旦确定结果就立即停止使用迭代器print(next(g)) # 8，剩余的元素 深入分析iter函数1234567def d6(): return randint(1, 6)d6_iter = iter(d6, 1) # 不断调用第一个参数（没有参数的可调用对象），产出各个值print(d6_iter) # &lt;callable_iterator object at ...&gt;for roll in d6_iter: print(roll) # 当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出(打印)哨符 上下文管理器和else块if之外的else块先做这个，再做那个。 12345for i in range(10): if i == 15: breakelse: print('else') # "如果中断了就不做了"。仅当for循环运行完毕时(即for循环没有被break语句中止)才运行else块。 while： 仅当while循环因为条件为假值而退出时（即while循环没有被break语句中止）才运行else块。 try： 仅当 try 块中没有异常抛出时才运行else块。官方文档还指出：“else 子句抛出的异常不会由前面的 except 子句处理。” EAFP风格： 上下文管理器和with块with 语句的目的是简化 try/finally 模式。 这种模式用于保证一段代码运行完毕后执行某项操作， 即便那段代码由于异常、 return 语句或sys.exit() 调用而中止， 也会执行指定的操作。 上下文管理器协议包含 __enter__ 和 __exit__ 两个方法。 with 语句开始运行时， 会在上下文管理器对象上调用 __enter__ 方法。 with 语句运行结束后， 会在上下文管理器对象上调用 __exit__ 方法， 以此扮演 finally 子句的角色。 上下文管理器举例： 123456789101112131415161718192021class LookingGlass(): def __enter__(self): import sys self.origin_write = sys.stdout.write sys.stdout.write = self.reverse_write # 猴子补丁 return 'JABBERWOCKY' # __enter__方法一般返回上下文管理器自己，也可返回别的对象 def reverse_write(self, text): self.origin_write(text[::-1]) def __exit__(self, exc_type, exc_value, traceback): """ exc_type：异常类（例如ZeroDivisionError） exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取 """ import sys # 重复导入模块不会消耗很多资源，因为Python会缓存导入的模块 sys.stdout.write = self.origin_write if exc_type is ZeroDivisionError: print('Please DO NOT divide by zero') return True # 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡 1234567from mirror import LookingGlasswith LookingGlass() as g: print('Hallo') # ollaH，打印出的内容是反向的 print(g) # YKCOWREBBAJ，g就是print(g) # JABBERWOCKY，已经调用__exit__方法恢复打印方法 使用@contextmanagercontextlib.contextmanager 装饰器会把函数包装成实现 __enter__ 和 __exit__ 方法的类：yield 语句前面的所有代码在 with 块开始时（即解释器调用 __enter__ 方法时） 执行， yield 语句后面的代码在with 块结束时（即调用 __exit__ 方法时） 执行。 1234567891011121314151617181920212223import contextlib@contextlib.contextmanagerdef looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) # 在闭包中可以访问original_write sys.stdout = reverse_write yield 'JABBERWOCKY' sys.stdout.write = original_writefrom mirror import looking_glasswith looking_glass() as g: print('abc') # cba print(g) # YKCOWREBBAJprint('abc') # abcprint(g) # JABBERWOCKY 上述示例有一个严重的错误：如果在with块中抛出了异常，Python 解释器会将其捕获，然后在 looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会中止，永远无法恢复成原来的sys.stdout.write方法。修复代码如下： 1234567891011121314151617@contextlib.contextmanagerdef looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) sys.stdout.write = reverse_write try: yield 'JABBERWOCKY' #要把yield语句放在try/finally语句中（或者放在with语句中），因为我们永远不知道上下文管理器的用户会在with块中做什么 except ZeroDivisionError: #假设的异常 msg = 'Please DO NOT divide by zero!' finally: sys.stdout.write = original_write if msg: print(msg) 协程用作协程的生成器的基本行为123456789def simple_coroutine(): print('-&gt;coroutine started') x = yield # 右边没有表达式，产出None print('-&gt;coroutine received:', x)c = simple_coroutine()print(c) # &lt;generator object simple_coroutine at ...&gt;print(next(c)) # -&gt;coroutine started Nonec.send('12') # -&gt;coroutine received: 12 抛出StopIteration 协程的四种状态，可以用inspect.getgeneratorstate(…)函数确定： ‘GEN_CREATED’，等待开始执行 ‘GEN_RUNNING’，解释器正在执行 ‘GEN_SUSPENDED’，在yield表达式处暂停 ‘GEN_CLOSED’，执行结束 仅当协程处于暂停时才能调用send方法，因此刚创建的协程必须先用next(coro)激活，也可用coro.send(None)，这一步成为“预激”（即让协程向前执行到第一个yield表达式）。 使用协程计算移动平均值1234567891011121314def averager(): total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/counta = averager()next(a)print(a.send(10))print(a.send(12)) 预激协程的装饰器自定义一个装饰器： 123456789from functools import wrapsdef coroutine(func): @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer 使用： 12345from coroutil import coroutine@coroutinedef averager(): ... 终止协程和异常处理1234567891011121314151617181920212223class DemoException(Exception): passdef demo_exc_handing(): print('coroutine started') try: while True: try: x = yield except DemoException: # 特别处理此异常 print('DemoException handled,Continuning...') else: # 如果没有异常，执行打印 print('coroutine received:&#123;!r&#125;'.format(x)) finally: # 未处理的其他异常，协程结束，执行清理等 print('coroutine ending')d = demo_exc_handing()next(d) # coroutine startedd.send('abc')d.send(2.00)d.throw(DemoException) # DemoException handled，Continuning...d.throw(ZeroDivisionError) # 先coroutine ending，后抛出ZeroDivisionError generator.throw(exc_type[, exc_value[, traceback]]) : 致使生成器在暂停的 yield 表达式处抛出指定的异常。 如果生成器处理了抛出的异常，代码会继续执行到下一个yield表达式，而产出的值会成为调用generator.throw方法得到的返回值。 如果生成器没有处理抛出的异常，协程会停止，即状态变成’GEN_CLOSED’，异常会向上冒泡，传到调用方的上下文中。 generator.close()： 致使生成器在暂停的yield表达式处抛出GeneratorExit异常。 如果生成器没有处理这个异常，或者抛出了StopIteration异常（通常是指运行到结尾），调用方不会报错。 如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。 生成器抛出的其他异常会向上冒泡， 传给调用方。 让协程返回值123456789101112131415161718192021222324from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): total = 0.0 count = 0 average = None while True: term = yield if term is None: # 为了返回值，协程必须停止，因此加一个条件 break total += term count += 1 average = total/count return Result(count, average)a = averager()next(a)print(a.send(10)) # None，没有产出值print(a.send(13))print(a.send(None)) # StopIteration: Result(count=2, average=11.5) 异常对象的 value 属性保存着返回的值。 注意，return表达式的值会偷偷传给调用方，赋值给StopIteration异常的一个属性。 这样做有点不合常理。 更合理的获取： 1234try: a.send(None)except StopIteration as e: print(e.value) # Result(count=2, average=11.5) 使用yield fromyield from x 表达式对 x 对象所做的第一件事是， 调用 iter(x)， 从中获取迭代器。 因此， x 可以是任何可迭代的对象。 yield from 的主要功能是打开双向通道， 把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值， 还可以直接传入异常， 而不用在位于中间的协程中添加大量处理异常的样板代码。 有了这个结构， 协程可以把职责委托给子生成器。 123456789101112def gen(): for c in 'AB': yield c for i in range(1, 3): yield idef gen_corountine(): yield from 'AB' yield from range(1, 3)print(list(gen()))print(list(gen_corountine())) 术语说明： 委派生成器：包含 yield from 表达式的生成器函数 子生成器：从 yield from 表达式中 部分获取的生成器 调用方：指代调用委派生成器的客户端代码。 即“客户端” 结构示意图： 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): """子生成器""" total = 0.0 count = 0 average = None while True: term = yield if term is None: # 子生成器的退出条件 break total += term count += 1 average = total/count return Result(count, average) # 结束时抛出StopIteration异常，把返回值赋到value属性上def grouper(result, key): """委派生成器""" while True: # 继续迭代，避免group实例执行迭代结束时抛出StopIteration异常 # grouper会在yield from表达式处暂停，发送的每个值都会经由yield from处理，通过管道传给averager实例，等待averager实例执行完毕。 # 抑制子生成器抛出的StopIteration异常，接收averager实例的返回值（从StopIteration异常的value属性中获取） result[key] = yield from averager()def main(data): results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) next(group) # 预激委派生成器，使委派生成器自身在yield from处暂停，接着委派生成器预激子生成器执行到第一个yeild语句处 for value in values: # 传入的值最终到达averager函数中term = yield那一行，grouper并不知道传入的值是什么 group.send(value) # 重要！结束averager函数执行，将返回值付给grouper的result变量。 # 如果没有这一句，在下一次循环时，新创建的grouper实例将会覆盖到group变量上，前一个实例（以及它创建的尚未终止的averager子生成器实例）被垃圾回收程序回收 group.send(None) print(results)data = &#123; 'girls;kg': [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5], 'girls;m': [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg': [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3], 'boys;m': [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],&#125;if __name__ == '__main__': main(data) yield from链： 一个委派生成器使用yield from调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield表达式的简单生成器（或任何可迭代的对象）结束；任何yield from链条都必须由客户驱动，在最外层委派生成器上调用next(…)函数或.send(…)方法。可以隐式调用，例如使用for循环。 yield from 的意义yield from的特性： 子生成器产出的值都直接传给委派生成器的调用方（即客户端代码） 使用 send() 方法发给委派生成器的值都直接传给子生成器。 如果发送的值是 None， 那么会调用子生成器的 __next__() 方法。 如果发送的值不是 None， 那么会调用子生成器的 send() 方法。 如果调用的方法抛出 StopIteration 异常， 那么委派生成器恢复运行。 任何其他异常都会向上冒泡， 传给委派生成器。 生成器退出时， 生成器（或子生成器） 中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。 yield from 表达式的值是子生成器终止时传给 StopIteration异常的第一个参数。 传入委派生成器的异常， 除了 GeneratorExit 之外都传给子生成器的 throw() 方法。 如果调用 throw() 方法时抛出StopIteration 异常， 委派生成器恢复运行。 StopIteration 之外的异常会向上冒泡， 传给委派生成器 如果把 GeneratorExit 异常传入委派生成器， 或者在委派生成器上调用 close() 方法， 那么在子生成器上调用 close() 方法， 如果它有的话。 如果调用 close() 方法导致异常抛出， 那么异常会向上冒泡， 传给委派生成器； 否则， 委派生成器抛出GeneratorExit 异常 yeidl from结构的伪代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546EXPR = 'AB'import sysdef yield_demo(): _i = iter(EXPR) # EXPR可以是任何可迭代对象 try: _y = next(_i) # 预激，保存第一次产出的结果 except StopIteration as e: _r = e.value # 最简单情况下的返回值（RESULT） else: while 1: # 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道 try: _s = yield _y # 产出上次子生成器的产出值，等待调用方发送值，保存在_s中 except GeneratorExit as _e: # 用于关闭子生成器和委派生成器自己 try: _m = _i.close except AttributeError: # 子生成器可能没有close方法（比如字符串），静默失败 pass else: _m() raise _e except BaseException as _e: # 处理调用方通过.throw(...)方法传入的异常 _x = sys.exc_info() try: _m = _i.throw() except AttributeError: # 子生成器可能没有throw方法，委派生成器抛出异常 raise _e else: # 有throw方法，调用 try: # 子生成器可能会处理掉出入的异常（然后继续循环），也可能抛出StopIteration异常，也可能抛出其他类型的异常 _y = _m(*_x) except StopIteration as _e: # 处理StopIteration异常，获取返回值。如果是其他异常直接冒泡 _r = _e.value break else: try: if _s is None: _y = next(_i) else: _y = _i.send(_s) except StopIteration as _e: _r = _e.value break return _r 离散事件仿真离散事件仿真（DES），定义： 出租车队运营仿真，代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from collections import namedtuplefrom queue import PriorityQueueEvent = namedtuple('Event', 'time proc action')# time 是事件发生的仿真时间# proc 是出租车进程实例的编号# action 描述活动的字符串def taxi_process(ident, trips, start_time=0): """ 每辆出租车调用一次taxi_process函数，创建一个生成器对象，表示各辆出租车的运营过程。 ident是出租车的编号，trips是出租车回家之前的行程数量，start_time是出租车离开车库的时间。 每次改变状态时传入一个time，把控制权让给仿真器，每次结束时返回一个Event对象 """ time = yield Event(start_time, ident, 'leave garage') for i in range(trips): # 每次行程运行一次 time = yield Event(time, ident, 'pick up passenger') time = yield Event(time, ident, 'drop off passenger') yield Event(time, ident, 'going home') # 一个出租车进程结束class Simulator: def __init__(self, procs_map): self.events = PriorityQueue() # 优先队列，可以按照指定优先顺序（item[0]，即time）取值 self.procs = dict(procs_map) # 副本 def run(self, end_time): # 预激、排定各辆出租车的第一个事件 for _, proc in sorted(self.procs.items()): first_event = next(proc) self.events.put(first_event) sim_time = 0 # sim_time（仿真钟）归零 while sim_time &lt; end_time: if self.events.empty(): print('*** end of events ***') break current_event = self.events.get() # 获取优先队列中time属性最小的Event对象 # 每次循环时仿真钟不会以固定的量推进，是根据各个事件持续的时间推进 sim_time, proc_id, previous_action = current_event print('taxi', proc_id, proc_id*' ', current_event) active_proc = self.procs[proc_id] next_time = sim_time + 2 # compute_duration(previous_action) try: next_event = active_proc.send(next_time) except StopIteration: del self.procs[proc_id] else: self.events.put(next_event) else: # 循环由于仿真事件到而退出，显示待完成的事件数量 msg = '*** end of simulation time: &#123;&#125; events pending ***' print(msg.format(self.events.qsize()))taxis = &#123;i: taxi_process(i, (i+1)*2, i*5) for i in range(3)&#125;sim = Simulator(taxis)sim.run(40) 事件： 驱动型框架（如 Tornado 和 asyncio） 的运作方式： 在单个线程中使用一个主循环驱动协程执行并发活动。 使用协程做面向事件编程时， 协程会不断把控制权让步给主循环， 激活并向前运行其他协程， 从而执行各个并发活动。 使用期物处理并发网络下载的三种风格依序下载的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osimport timeimport sysimport requests # 不在标准库，一个空行隔开POP20_CC = ('CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR').split()BASE_URL = 'http://flupy.org/data/flags'DEST_DIR = 'downloads/'def save_flag(img, filename): path = os.path.join(DEST_DIR, filename) if not os.path.exists(DEST_DIR): os.makedirs(DEST_DIR) with open(path, 'wb') as fp: fp.write(img)def get_flag(cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = requests.get(url) # 阻塞性I/O操作 return resp.contentdef show(text): print(text, end=' ') sys.stdout.flush() # 刷新sys.stdout，这样能在一行消息中看到进度。在Python在正常情况下，遇到换行才会刷新stdout缓冲def download_many(cc_list): for cc in sorted(cc_list): image = get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return len(cc_list)def main(download_many): t0 = time.time() count = download_many(POP20_CC) elapsed = time.time()-t0 msg = '\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s' print(msg.format(count, elapsed))if __name__ == '__main__': main(download_many) 使用concurrent.futures模块下载123456789101112131415161718192021from concurrent import futuresfrom flags import save_flag, get_flag, show, mainMAX_WORKERS = 20def download_one(cc): image = get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return ccdef download_many(cc_list): wokers = min(MAX_WORKERS, len(cc_list)) with futures.ThreadPoolExecutor(wokers) as executor: # download_one函数会在多个线程中并发调用；map方法返回一个生成器，因此可以迭代，获取各个函数返回的值 res = executor.map(download_one, sorted(cc_list)) return len(list(res))if __name__ == '__main__': main(download_many) 期物在哪里标准库中有两个名为 Future 的类： concurrent.futures.Future 和 asyncio.Future。 这两个类的作用相同： 两个 Future 类的实例都表示可能已经完成或者尚未完成的延迟计算。 这与 Twisted 引擎中的 Deferred 类、 Tornado 框架中的Future 类， 以及多个 JavaScript 库中的 Promise 对象类似。 使用as_completed函数改写download_many函数，来理解期物： 1234567891011121314151617181920212223242526272829303132333435def download_many(cc_list): cc_list = cc_list[:5] with futures.ThreadPoolExecutor(3) as executor: to_do = [] for cc in cc_list: # submit方法排定可调用对象的执行时间，返回一个期物，表示这个待执行（或正执行）的操作 future = executor.submit(download_one, cc) to_do.append(future) msg = 'Scheduled for &#123;&#125;:&#123;&#125;' print(msg.format(cc, future)) results = [] # as_completed 函数在期物运行结束后产出期物 for future in futures.as_completed(to_do): res = future.result() # 获取该期物（已结束，不会阻塞）的结果 msg = '&#123;&#125; result:&#123;!r&#125;' print(msg.format(future, res)) results.append(res) return len(results)# 打印：# Scheduled for CN:&lt;Future at 0x232955c9860 state=running&gt;# Scheduled for IN:&lt;Future at 0x232955c9f28 state=running&gt;# Scheduled for US:&lt;Future at 0x232955d9550 state=running&gt; 有三个工作线程，前三个期物的状态是running# Scheduled for ID:&lt;Future at 0x232955d9a90 state=pending&gt;# Scheduled for BR:&lt;Future at 0x232955d9b38 state=pending&gt; 后两个是pending，等待有线程可用# IN &lt;Future at 0x232955c9f28 state=finished returned str&gt; result:'IN' 第一个IN是download_one的子线程打印的，第二个'IN'是主线程获得返回后打印的# CN &lt;Future at 0x232955c9860 state=finished returned str&gt; result:'CN'# ID &lt;Future at 0x232955d9a90 state=finished returned str&gt; result:'ID'# BR US &lt;Future at 0x232955d9b38 state=finished returned str&gt; result:'BR' 子线程都先把download_one的show执行了，然后返回结果。主线程遍历打印了结果# &lt;Future at 0x232955d9550 state=finished returned str&gt; result:'US'# 5 flags downloaded in 0.88s 严格来说， 我们目前测试的并发脚本都不能并行下载。 使用concurrent.futures 库实现的两个示例受 GIL（Global InterpreterLock， 全局解释器锁） 的限制， 而 flags_asyncio.py 脚本在单个线程中运行。（GIL几乎对 I/O 密集型处理无害）。 阻塞性I/O和GILPython 线程受 GIL的限制， 任何时候都只允许运行一个线程，但 flags_threadpool.py 脚本的下载速度仍比 flags.py 脚本快 5倍。flags_asyncio.py 脚本和 flags.py 脚本都在单个线程中运行， 前者仍比后者快 5 倍。 Python 标准库中的所有阻塞型 I/O 函数都会释放 GIL， 允许其他线程运行。 time.sleep() 函数也会释放 GIL。 因此， 尽管有GIL， Python 线程还是能在 I/O 密集型应用中发挥作用。 CPython 解释器本身就不是线程安全的， 因此有全局解释器锁（GIL） ，一次只允许使用一个线程执行 Python 字节码。 因此， 一个 Python 进程通常不能同时使用多个 CPU 核心。这是 CPython 解释器的局限， 与 Python 语言本身无关。 Jython 和 IronPython 没有这种限制。不过， 目前最快的 Python 解释器 PyPy 也有 GIL。 使用concurrent.futures模块启动进程在CPU密集型作业中使用concurrent.futures模块轻松绕开GIL，ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的Executor 接口， 因此使用ProcessPoolExecutor能特别轻松地把基于线程的方案转成基于进程的方案。而在下载国旗的示例或其他I/O密集型作业使用ProcessPoolExecutor类得不到任何好处。 实验Executor.map方法123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import sleep, strftimefrom concurrent import futuresdef display(*args): print(strftime('[%H:%M:%S]'), end=' ') print(*args)def loiter(n): msg = '&#123;&#125;loiter(&#123;&#125;):start' display(msg.format('\t'*n, n, n)) sleep(n) msg = '&#123;&#125;loiter(&#123;&#125;):done' display(msg.format('\t'*n, n)) return n*10def main(): display('Starting') with futures.ThreadPoolExecutor(3) as exec: results = exec.map(loiter, range(5)) display('results', results) display('Waiting for individual results:') for i, result in enumerate(results): display('&#123;&#125;result &#123;&#125;:&#123;&#125;'.format('\t'*i, i, result))main()# 打印：# [18:55:54] Starting# [18:55:54] loiter(0):doint nothing for 0s# [18:55:54] loiter(0):done #sleep 函数总会释放 GIL，这一句可能在loiter(1)之前，也可能在后# [18:55:54] loiter(1):doint nothing for 1s# [18:55:54] loiter(2):doint nothing for 2s #因为线程池中有三个职程，可以并发运行三个函数# [18:55:54] results &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at ...&gt; #目前不会阻塞# [18:55:54] Waiting for individual results:# [18:55:54] result 0:0# [18:55:54] loiter(3):doint nothing for 3s #第一个线程可以启动第四个线程，运行loiter(3)。# [18:55:55] loiter(1):done# [18:55:55] loiter(4):doint nothing for 4s# [18:55:55] result 1:10# [18:55:56] loiter(2):done# [18:55:56] result 2:20# [18:55:57] loiter(3):done# [18:55:57] result 3:30# [18:55:59] loiter(4):done# [18:55:59] result 4:40 map的特性：这个函数返回结果的顺序与调用开始的顺序一致，如果后调用的函数早完成则会处于阻塞状态。只能处理参数不同的同一个可调用对象。 executor.submit和futures.as_completed组合更灵活，不管提交顺序，只要有结果就获取。 futures.as_completed能处理的期物集合可以来自多个Executor实例。 线程和多进程的替代方案如果futures.ThreadPoolExecutor 类对某个作业来说不够灵活， 可能要使用 threading 模块中的组件（如 Thread、 Lock、 Semaphore 等）自行制定方案， 比如说使用 queue 模块创建线程安全的队列， 在线程之间传递数据。 futures.ThreadPoolExecutor 类已经封装了这些组件。 对 CPU 密集型工作来说， 要启动多个进程， 规避 GIL。 创建多个进程最简单的方式是， 使用 futures.ProcessPoolExecutor 类。 不过和前面一样， 如果使用场景较复杂， 需要更高级的工具。 multiprocessing 模块的 API 与threading 模块相仿， 不过作业交给多个进程处理。 使用asyncio包处理并发线程与协程的对比spinner_thread.py： 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport itertoolsimport timeimport sysclass Signal(): go = True # 从外部控制线程关闭def spin(msg, signal): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char+' '+msg write(status) flush() write('\x08'*len(status)) # 使用退格符（\x08）把光标移回来 time.sleep(.1) if not signal.go: break write(' '*len(status)+'\x08'*len(status))def slow_function(): time.sleep(3) # 假装I/O。调用sleep函数会阻塞主线程，一定要这么做，以便释放GIL，创建子线程 return 42def supervisor(): signal = Signal() spinner = threading.Thread(target=spin, args=('thinking!', signal)) print('spinner object:', spinner) spinner.start() result = slow_function() signal.go = False spinner.join() return resultdef main(): result = supervisor() print('Answer:', result)if __name__ == '__main__': main() spinner_asyncio.py： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import asyncioimport itertoolsimport sysimport time@asyncio.coroutine # 强烈建议打算交给asyncio处理的协程要使用@asyncio.coroutine装饰def spin(msg): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char + ' '+msg write(status) flush() write('\x08'*len(status)) try: yield from asyncio.sleep(.1) # 这样的休眠不会阻塞事件循环 # time.sleep(.1) # 将会无限循环执行，调用方也不能中止子协程的执行 except asyncio.CancelledError: break write(' '*len(status)+'\x08'*len(status))@asyncio.coroutinedef slow_function(): yield from asyncio.sleep(3) # 表达式把控制权交给主事件循环（loop），在休眠结束后恢复这个协程。 return 42@asyncio.coroutinedef supervisor(): # 排定spin协程的运行时间（顺序），使用一个Task对象包装spin协程，并立即返回 spinner = asyncio.ensure_future(spin('thinking!')) # spinner object: &lt;Task pending coro=&lt;spin() running at .\index.py:7&gt;&gt; print('spinner object:', spinner) result = yield from slow_function() # 主循环在此处等待3秒，先去处理其他排定的协程 spinner.cancel() return resultdef main(): loop = asyncio.get_event_loop() # 获取事件循环的引用 result = loop.run_until_complete(supervisor()) # 驱动supervisor协程，让它运行完毕；这个协程的返回值是这次调用的返回值。 loop.close() print('Answer:', result)if __name__ == '__main__': main() 以上两种supervisor实现之间的主要区别： asyncio.Task对象差不多与threading.Thread对象等效。 Task对象用于驱动协程，Thread对象用于调用可调用对象。 Task对象不由自己动手实例化，而是通过把协程传给asyncio.ensure_future(..)函数或loop.create_task(…)方法获取。 获取的Task对象已经排定了运行时间。Thread实例则必须调用start方法。 没有API能从外部终止线程。可以使用Task.cancel()，在协程内部抛出CancelledError异常，协程可以在暂停的yield处捕获这个异常，处理终止请求。 supervisor协程必须在main函数中由loop.run_until_complete方法执行。 协程和线程的同步区别： 对协程来说， 无需保留锁， 在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻只有一个协程运行。 想交出控制权时， 可以使用 yield 或 yield from 把控制权交还调度程序。 asyncio.Future和concurrent.futures.Future区别期物只是调度执行某物的结果。 在asyncio 包中，BaseEventLoop.create_task(…)方法接收一个协程， 排定它的运行时间，然后返回一个asyncio.Task实例——也是asyncio.Future类的实例，因为Task是Future的子类，用于包装协程。这与调用Executor.submit(…)方法创建concurrent.futures.Future实例是一个道理。 与concurrent.futures.Future类似，asyncio.Future类也提供了.done()、.add_done_callback(…)和.result() 等方法。 因为asyncio.Future类的目的是与yield from一起使用，所以通常不需要使用以下方法： 无需调用my_future.add_done_callback(…)，因为可以直接把想在期物运行结束后执行的操作放在协程中 yield from my_future 表达式的后面。 这是协程的一大优势： 协程是可以暂停和恢复的函数。 无需调用my_future.result()，因为 yield from 从期物中产出的值就是结果（例如，result = yield from my_future）。 使用asyncio和aiohttp包下载从Python3.4起，asyncio包只支持TCP和UDP。如果想使用HTTP，可以使用aiohttp包。 123456789101112131415161718192021222324252627282930import asyncioimport aiohttpfrom flags import BASE_URL, save_flag, show, main@asyncio.coroutinedef get_flag(cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = yield from aiohttp.ClientSession().get(url) # 非阻塞I/O操作 image = yield from resp.read() return image@asyncio.coroutinedef download_one(cc): image = yield from get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return ccdef download_many(cc_list): loop = asyncio.get_event_loop() to_do = [download_one(cc) for cc in sorted(cc_list)] wait_coro = asyncio.wait(to_do) # wait 是一个协程，等传给它的所有协程运行完毕后结束 res, _ = loop.run_until_complete(wait_coro) loop.close() return len(res)if __name__ == '__main__': main(download_many) asyncio.wait 会分别把各个协程包装进一个 Task 对象。 最终的结果是， wait 处理的所有对象都通过某种方式变成 Future 类的实例。 wait 是协程函数， 因此返回的是一个协程或生成器对象。 在asyncio包的API中使用yield from时： 避免阻塞型调用有两种方法能避免阻塞型调用中止整个应用程序的进程： 在单独的线程中运行各个阻塞型操作 把每个阻塞型操作转换成非阻塞的异步调用使用 多个线程是可以的， 但是各个操作系统线程（Python 使用的是这种线程） 消耗的内存达兆字节（具体的量取决于操作系统种类） 。 如果要处理几千个连接， 而每个连接都使用一个线程的话， 我们负担不起。 asyncio 的基础设施获得第一个响应后， 事件循环把响应发给等待结果的 get_flag 协程。 得到响应后， getflag 向前执行到下一个 yieldfrom 表达式处， 调用 resp.read() 方法， 然后把控制权还给主循环。其他响应会陆续返回（因为请求几乎同时发出） 。 所有 get flag 协程都获得结果后， 委派生成器 download_one 恢复， 保存图像文件。 改进asyncio下载脚本把一个协程列表传给 asyncio.wait 函数， 经由loop.run_until_complete 方法驱动， 全部协程运行完毕后， 这个函数会返回所有下载结果。 可是， 为了更新进度条， 各个协程运行结束后就要立即获取结果。 为了集成进度条， 我们使用 as_completed 生成器函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import asyncioimport collectionsimport aiohttpfrom aiohttp import webimport tqdmfrom flags2_common import main, HTTPStatus, Result, save_flagDEFAULT_CONCUR_REQ = 5MAX_CONCUR_REQ = 1000class FetchError(Exception): def __init__(self, country_code): self.country_code = country_code@asyncio.coroutinedef get_flag(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) resp = yield from aiohttp.ClientSession().get(url) if resp.status == 200: image = yield from resp.read() return image elif resp.status == 404: raise web.HTTPNotFound() else: raise aiohttp.HttpProcessingError( code=resp.status, message=resp.reason, headers=resp.headers)@asyncio.coroutine# semaphore 参数是 asyncio.Semaphore 类的实例。 Semaphore 类是同步装置， 用于限制并发请求数量def download_one(cc, base_url, semaphore, verbose): try: # 使用 with 表达式或手动在 semaphore 对象上调用 release 方法(递增)或 acquire 方法(递减)来操作内部计数器 with (yield from semaphore): # 退出这个 with 语句后， semaphore 计数器的值会递减， 解除阻塞可能在等待同一个 semaphore 对象的其他协程实例 image = yield from get_flag(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc # raise X from Y 句法链接原来的异常 else: # 1, save_flag(image, cc.lower() + '.gif') # 直接调用 save_flag 访问本地文件系统会阻塞客户代码与 asyncio 事件循环共用的唯一线程 # 2, asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，我们可以调用 run_in_executor 方法， 把可调用的对象发给它执行 # 第一个参数是 Executor 实例； 如果设为None， 使用事件循环的默认 ThreadPoolExecutor 实例 loop = asyncio.get_event_loop() loop.run_in_executur(None, save_flag, image, cc.lower()+'.gif') status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc)@asyncio.coroutinedef downloader_coro(cc_list, base_url, verbose, concur_req): # 不直接调用，使用事件循环驱动 counter = collections.Counter() # 最多允许激活 concur_req 个使用这个计数器的协程，锁 semaphore = asyncio.Semaphore(concur_req) to_do = [download_one(cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] # 循环调用 download_one 协程， 创建一个协程对象列表。 to_do_iter = asyncio.as_completed(to_do) # 获取一个迭代器， 这个迭代器会在期物运行结束后返回期物 if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len( cc_list)) # 传给 tqdm 函数， 显示进度 for future in to_do_iter: # 迭代运行结束并返回结果的期物 try: res = yield from future # 获取该期物的结果（此时已结束，不会阻塞）的最简单的方式，而不是使用future.result() except FetchError as exc: country_code = exc.country_code try: # 尝试从原来的异常（__cause__） 中获取错误消息 error_msg = exc.__cause__.args[0] except IndexError: error_msg = exc.__cause__.__class__.__name__ if verbose and error_msg: msg = '*** Error for &#123;&#125;: &#123;&#125;' print(msg.format(country_code, error_msg)) status = HTTPStatus.error else: status = res.status counter[status] += 1 return counterdef download_many(cc_list, base_url, verbose, concur_req): loop = asyncio.get_event_loop() coro = downloader_coro(cc_list, base_url, verbose, concur_req) # download_many 函数只是实例化 downloader_coro 协程， 然后通过 run_until_complete 方法把它传给事件循环。 counts = loop.run_until_complete(coro) loop.close() return countsif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ) 从回调到期物和协程Python中的回调地狱：链式回调 123456789101112def stage1(response1): request2 = step1(response1) api_call2(request2, stage2)def stage2(response2): request3 = step2(response2) api_call3(request3, stage3)def stage3(response3): step3(response3)api_call1(request1, stage1) 使用协程和yield from 结构做异步编程，无需回调： 12345678910111213@asyncio.coroutinedef three_stages(request1): response1 = yield from api_call1(request1) # 第一步 request2 = step1(response1) response2 = yield from api_call2(request2) # 第二步 request3 = step2(response2) response3 = yield from api_call3(request3) # 第三步 step3(response3)loop.create_task(three_stages(request1)) # 必须显式调度执行 使用yield from 异步编程，每次下载发起多次请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@asyncio.coroutinedef http_get(url): resp = yield from aiohttp.ClientSession().get(url) if resp.status == 200: ctype = resp.headers.get('Content-Type', '').lower() if 'json' in ctype or url.endswith('json'): data = yield from resp.json() # 如果内容类型包含'json'，解析为一个字典 else: data = yield from resp.read() # 读取原始字节 return data elif resp.status == 404: raise web.HTTPNotFound() else: raise aiohttp.HttpProcessingError( code=resp.status, message=resp.reason, headers=resp.headers)@asyncio.coroutinedef get_contry(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/metadata.json'.format(base_url, cc=cc.lower()) metadata = yield from http_get(url) return metadata['country'] # 获取字典中的值@asyncio.coroutinedef get_flag(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) return (yield from http_get(url)) # 这里必须在外层加上括号@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose): try: with (yield from semaphore): image = yield from get_flag(base_url, cc) with (yield from semaphore): country = yield from get_contry(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc # raise X from Y 句法链接原来的异常 else: country = country.replace(' ', '_') filename = '&#123;&#125;-&#123;&#125;.gif'.format(country, cc) loop = asyncio.get_event_loop() loop.run_in_executur(None, save_flag, image, filename) status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc) 使用asyncio包编写服务器使用asyncio包编写TCP服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import sysimport asynciofrom charfinder import UnicodeNameIndexCRLF = b'\r\n'PROMPT = b'?&gt; '# 实例化 UnicodeNameIndex 类时， 它会使用 charfinder_index.pickle文件（如果没有则构建）index = UnicodeNameIndex()@asyncio.coroutine# 这个协程要传给start_server，接收的两个参数是，asyncio.StreamReader和asyncio.StreamWriterdef handle_queries(reader, writer): while True: # 循环处理会话， 直到从客户端收到控制字符 # 发送提示符，StreamWriter.write 方法不是协程，只是普通的函数，不能使用yield from writer.write(PROMPT) yield from writer.drain() # 刷新 writer 缓冲，因为它是协程，必须使用 yield from data = yield from reader.readline() # 协程，返回bytes对象 try: query = data.decode().strip() except UnicodeDecodeError: query = '\x00' # Telnet 客户端发送控制字符时，可能会抛出 UnicodeDecodeError异常；简单起见，假装发送的是空字符。 client = writer.get_extra_info('peername') # 返回与套接字连接的远程地址 print('Received from &#123;&#125;:&#123;!r&#125;!'.format(client, query)) if query: if ord(query[:1]) &lt; 32: break # 收到控制字符或者空字符， 退出循环 # 产出包含 Unicode 码位、真正的字符和字符名称的字符串 lines = list(index.find_description_strs(query)) if lines: # 把 lines 转换成 bytes 对象，并在每一行末尾添加回车符和换行符 # writer.writelines(line.encode()+CRLF for line in lines) writer.writelines(line.encode('utf8')+CRLF for line in '卧室的') writer.write(index.status(query, len(lines)).encode()+CRLF) yield from writer.drain() # 刷新输出缓冲 print('Sent &#123;&#125; results'.format(len(lines))) print('Close the client socket') writer.close() # 关闭StreamWriter流def main(address='127.0.0.1', port=2323): port = int(port) loop = asyncio.get_event_loop() # asyncio.start_server 协程运行结束后， 返回的协程对象返回一个 asyncio.Server 实例， 即一个 TCP 套接字服务器 server_coro = asyncio.start_server( handle_queries, address, port, loop=loop) # 驱动 server_coro 协程， 启动服务器（server） server = loop.run_until_complete(server_coro) host = server.sockets[0].getsockname() # 获取这个服务器的第一个套接字的地址和端口 print('Serving on &#123;&#125;. Hit CTRL-C to stop.'.format(host)) try: loop.run_forever() # main 函数在这里阻塞，直到在服务器的控制台中按CTRL-C 键才会关闭 except KeyboardInterrupt: # 按CTRL-C pass print('Server shutting down.') server.close() # server.wait_closed() 方法返回一个期物，调用loop.run_until_complete运行期物 loop.run_until_complete(server.wait_closed()) loop.close()if __name__ == '__main__': # 处理可选的命令行参数的简便方式：展开 sys.argv[1:]，传给main函数 main(*sys.argv[1:]) handle_queries 协程的名称是复数， 因为它启动交互式会话后能处理各个客户端发来的多次请求。代码中所有的 I/O 操作都使用 bytes 格式。 因此， 我们要解码从网络中收到的字符串， 还要编码发出的字符串。Python 3 默认使用的编码是 UTF-8， 这里就隐式使用了这个编码。run_until_complete 方法的参数是一个协程（start_server方法返回的结果）或一个 Future 对象（server.wait_closed 方法返回的结果）,如果传给 run_until_complete 方法的参数是协程， 会把协程包装在 Task 对象中。调用 loop.run_forever() 时阻塞。控制权流动到事件循环中， 而且一直待在那里。不过偶尔会回到 handle_queries 协程， 这个协程需要等待网络发送或接收数据时， 控制权又交还事件循环。在事件循环运行期间， 只要有新客户端连接服务器就会启动一个handle_queries 协程实例。 使用aiohttp包编写Web服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import sysimport asynciofrom aiohttp import webimport aiohttpfrom charfinder import UnicodeNameIndexTEMPLATE_NAME = 'http_charfinder.html'SAMPLE_WORDS = ('bismillah chess cat circled Malayalam digit' ' Roman face Ethiopic black mark symbol dot' ' operator Braille hexagram').split()ROW_TPL = '&lt;tr&gt;&lt;td&gt;&#123;code_str&#125;&lt;/td&gt;&lt;th&gt;&#123;char&#125;&lt;/th&gt;&lt;td&gt;&#123;name&#125;&lt;/td&gt;&lt;/tr&gt;'LINK_TPL = '&lt;a href="/?query=&#123;0&#125;" title="find &amp;quot;&#123;0&#125;&amp;quot;"&gt;&#123;0&#125;&lt;/a&gt;'LINKS_HTML = ', '.join(LINK_TPL.format(word) for word in sorted(SAMPLE_WORDS, key=str.upper))index = UnicodeNameIndex()template = ''with open(TEMPLATE_NAME) as tpl: template = tpl.read()template = template.replace('&#123;links&#125;', LINKS_HTML)def home(request): # 每次请求执行一遍 query = request.query.get('query').strip() print('Query:&#123;!r&#125;'.format(query)) if query: descriptions = list(index.find_descriptions(query)) res = '\n'.join(ROW_TPL.format(**descr._asdict()) for descr in descriptions) msg = index.status(query, len(descriptions)) else: descriptions = [] res = '' msg = 'Enter words describing characters' html = template.format(query=query, result=res, message=msg) print('Sending &#123;&#125; results'.format(len(descriptions))) return web.Response(content_type='text/html', charset='utf-8', text=html)@asyncio.coroutinedef init(loop, address, port): # init 协程产出一个服务器， 交给事件循环驱动 app = web.Application(loop=loop) app.router.add_route('GET', '/', home) # 返回一个 aiohttp.web.RequestHandler实例，在 app 对象上设置路由处理 HTTP 请求 handler = app.make_handler() # 创建服务器， 以 handler 为协议处理程序， 并把服务器绑定在指定的地址和端口上 server = yield from loop.create_server(handler, address, port) return server.sockets[0].getsockname()def main(address='127.0.0.1', port=8111): port = int(port) loop = asyncio.get_event_loop() host = loop.run_until_complete( init(loop, address, port)) # 执行init方法，启动服务器，获取服务器的地址和端口 print('Serving on &#123;&#125;. Hit CTRL-C to stop.'.format(host)) try: loop.run_forever() # 控制权在事件循环手上时， main 函数会在这里阻塞 except KeyboardInterrupt: pass print('Server shutting down.') loop.close()if __name__ == '__main__': main(*sys.argv[1:]) 只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方法： yield from 传给 asyncio 包中某个参数为协程或期物的函数，例如 run_until_complete。 动态属性和特性使用动态属性转换数据使用动态属性访问JSON类数据下载和加载，osconfeed.py：1234567891011121314151617from urllib.request import urlopenimport warningsimport osimport jsonURL = 'http://www.oreilly.com/pub/sc/osconfeed'JSON = 'data/osconfeed.json'def load(): if not os.path.exists(JSON): msg = 'downloading &#123;&#125; to &#123;&#125;'.format(URL, JSON) warnings.warn(msg) with urlopen(URL) as remote, open(JSON, 'wb') as local: # 同时进行下载和保存 local.write(remote.read()) with open(JSON, encoding='utf8') as fp: return json.load(fp) 动态访问属性：12345678910111213141516171819202122232425262728293031from collections import abcimport keywordclass FrozenJSON(): """一个只读接口，使用属性表示法访问JSON类对象 """ def __init__(self, mapping): self.__data = &#123;&#125; for key, value in mapping.items(): if keyword.iskeyword(key): # 判断键是否为Python关键词，特殊处理 key += '_' self.__data[key] = value def __getattr__(self, name): if hasattr(self.__data, name): # 如果 name 是实例属性 __data 的属性，返回那个属性，如 keys return getattr(self.__data, name) else: # 否则从 self.__data 中获取 name 键对应的元素， 返回调用FrozenJSON.build() 方法得到的结果。 return FrozenJSON.build(self.__data[name]) @classmethod def build(cls, obj): # 备选构造函数 if isinstance(obj, abc.Mapping): return cls(obj) elif isinstance(obj, abc.MutableSequence): return [cls.build(item) for item in obj] else: return obj 动态访问： 12345678910from osconfeed import loadfrom fronzen_json import FrozenJSONraw_feed = load()print(raw_feed['Schedule']['events'][40]['name'])feed = FrozenJSON(raw_feed)print(feed.Schedule.events[40].name) #动态访问属性 使用new方法灵活创建对象__new__： 这是个类方法（使用特殊方式处理， 因此不必使用 @classmethod 装饰器） ， 必须返回一个实例（自身类或其他类的实例，返回其他类的实例解释器不会调用 __init__ 方法）。 返回的实例会作为第一个参数（即 self） 传给 __init__ 方法。 所以 __init__ 方法其实是“初始化方法”。 真正的构造方法是 __new__。我们几乎不需要自己编写 __new__ 方法， 因为从 object 类继承的实现已经足够了。 Python构件对象的过程的伪代码： 12345678910# 构建对象的伪代码def object_maker(the_class, some_arg): new_object = the_class.__new__(some_arg) if isinstance(new_object, the_class): the_class.__init__(new_object, some_arg) return new_object# 下述两个语句的作用基本等效x = Foo('bar')x = object_maker(Foo, 'bar') 使用 __new__ 方法取代build方法，构建可能是也可能不是FrozenJSON实例的新对象： 123456789101112131415161718192021def __init__(self, mapping): #__new__构建的“原始”对象，在__init__里进行初始化 self.__data = &#123;&#125; for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = valuedef __getattr__(self, name): if hasattr(self.__data, name): return getattr(self.__data, name) else: return FrozenJSON(self.__data[name])def __new__(cls, arg): # cls是类本身 if isinstance(arg, abc.Mapping): # 默认的行为是委托给超类（这里是object）的 __new__ 方法来构建“原始”对象。背后真正的构建操作由解释器调用 C 语言实现的 object.__new__ 方法执行 return super().__new__(cls) elif isinstance(arg, abc.MutableSequence): return [cls(item) for item in arg] else: return arg shelve模块略 使用特性验证属性12345678910111213141516171819class LineItem(): def __init__(self, desc, weight, price): self.desc = desc self.weight = weight # 这里赋值已经使用了特性的设值方法 self.price = price def subtotal(self): return self.weight*self.price @property def weight(self): # 读值方法 return self.__weight @weight.setter # 这个装饰器把读值方法和设值方法绑定在一起 def weight(self, value): # 设值方法 if value &gt; 0: self.__weight = value else: raise ValueError('value must be &gt; 0') 特性全解析特性会覆盖实例属性12345678910111213141516171819202122232425262728293031class Class(): data = 'class data' # 类属性 @property def prop(self): '''prop doc''' return 'prop value'obj = Class()print(dir(obj)) # 查询所有属性名列表，包括从父类继承的，返回__dir__()的结果print(vars(obj)) # &#123;&#125;，实例的属性名值对，返回__dict__属性的值print(obj.data) # class data，获取的是Class.data的值obj.data = 'bar' # 创建一个实例属性，覆盖了类属性print(vars(obj)) # &#123;'data': 'bar'&#125;print(Class.data) # class data，类属性没有改变print(Class.prop) # &lt;property object at ...&gt;，特性相当于类属性，获取的是特性对象本身，不会运行特性的读值方法print(obj.prop) # prop value，实例调用，执行了特性的读值方法# obj.prop = 'foo' # AttributeError: can't set attribute，只读特性，报错obj.__dict__['prop'] = 'foo' # 通过__dict__成功设置实例属性print(vars(obj)) # &#123;'data': 'bar', 'prop': 'foo'&#125;print(obj.prop) # prop value，仍会运行特性的读值方法，特性覆盖了实例属性Class.prop = 'baz' # 相当于销毁了特性对象print(obj.prop) # foo，现在读取的是实例属性Class.data = property(lambda self: 'class data prop', doc='data doc')print(obj.data) # class data prop，实例的data属性被类的data特性覆盖了del Class.dataprint(obj.data) # bar，恢复原样 obj.attr 这样的表达式不会从 obj 开始寻找attr，而是从 obj.__class__ 开始。而且， 仅当类中没有名为 attr的特性时， Python 才会在 obj 实例中寻找。 特性工厂12345678910111213141516171819202122232425262728293031def quantity(storage_name): def qty_getter(instance): return instance.__dict__[storage_name] def qty_setter(instance, value): if value &gt; 0: instance.__dict__[storage_name] = value else: raise ValueError('value must be &gt; 0') return property(qty_getter, qty_setter)class LineItem(): weight = quantity('weight') # 把自定义特性定义为类属性 price = quantity('price') def __init__(self, desc, weight, price): self.desc = desc self.weight = weight # 特性已经激活 self.price = price def subtotal(self): return self.weight*self.pricei = LineItem('desc', 10, 20)print(LineItem.weight)# &#123;'desc': 'desc', 'weight': 10, 'price': 20&#125;，实例也创建了属性的，真正用于存储值print(vars(i))print(i.weight) # 10，调用了特性的读值方法 处理属性删除操作1234567891011121314151617181920212223242526class BlackKnight(): def __init__(self): self.members = ['an arm', 'another arm', 'a leg', 'another leg'] self.phrases = ["'Tis but a scratch.", "It's just a flesh wound.", "I'm invincible!", "All right, we'll call it a draw."] @property def member(self): print('next member is:') return self.members[0] @member.deleter def member(self): text = 'BLACK KNIGHT (loses &#123;&#125;)\n-- &#123;&#125;' print(text.format(self.members.pop(0), self.phrases.pop(0)))knight = BlackKnight()print(knight.member)del knight.memberdel knight.memberdel knight.memberdel knight.member 处理属性的重要属性和函数特殊属性1234567b = BlackKnight()print(type(BlackKnight)) # &lt;class 'type'&gt;print(BlackKnight.__class__) # &lt;class 'type'&gt;print(type(b)) # &lt;class '__main__.BlackKnight'&gt;print(b.__class__) # &lt;class '__main__.BlackKnight'&gt; __class__：对象所属类的引用（即 obj.__class__ 与 type(obj) 的作用相同） 。Python 的某些特殊方法， 例如 __getattr__， 只在对象的类中寻找， 而不在实例中寻找。 __dict__：一个映射， 存储对象或类的可写属性（键值对）。 有 __dict__ 属性的对象，任何时候都能随意设置新属性。 如果类有 __slots__ 属性， 它的实例可能没有 __dict__ 属性。 参见下面对 __slots__ 属性的说明。 __slots__：类可以定义这个这属性， 限制实例能有哪些属性。 __slots__ 属性的值是一个字符串组成的元组， 指明允许有的属性。 如果 __slots__ 中没有 __dict__， 那么该类的实例没有 __dict__ 属性， 实例只允许有指定名称的属性。 内置函数dir([object])：列出对象的大多数属性。dir 函数的目的是交互式使用， 因此没有提供完整的属性列表， 只列出一组“重要的”属性名。 dir 函数能审查有或没有 __dict__ 属性的对象。 dir 函数不会列出 __dict__ 属性本身， 但会列出其中的键。 dir 函数也不会列出类的几个特殊属性， 例如 __mro__、 __bases__ 和 __name__。 如果没有指定可选的 object 参数， dir 函数会列出当前作用域中的名称。 getattr(object, name[, default])：从 object 对象中获取 name 字符串对应的属性。 获取的属性可能来自对象所属的类或超类。 如果没有指定的属性， getattr 函数抛出AttributeError 异常， 或者返回 default 参数的值（如果设定了这个参数的话） 。 hasattr(object, name)：如果 object 对象中存在指定的属性， 或者能以某种方式（例如继承） 通过 object 对象获取指定的属性， 返回 True。 文档说： “这个函数的实现方法是调用 getattr(object, name) 函数， 看看是否抛出AttributeError 异常。 ” setattr(object, name, value)：把 object 对象指定属性的值设为 value， 前提是 object 对象能接受那个值。 这个函数可能会创建一个新属性， 或者覆盖现有的属性。 vars([object])：返回 object 对象的 __dict__ 属性； 如果实例所属的类定义了 __slots__ 属性， 实例没有 __dict__ 属性， 那么 vars 函数不能处理那个实例（相反， dir 函数能处理这样的实例） 。 如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样： 返回表示本地作用域的字典。 特殊方法使用点号或内置的 getattr、 hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。 但是， 直接通过实例的 __dict__ 属性读写属性不会触发这些特殊方法——如果需要， 通常会使用这种方式跳过特殊方法。要假定特殊方法从类上获取， 即便操作目标是实例也是如此。 因此， 特殊方法不会被同名实例属性遮盖。例如， obj.attr 和 getattr(obj, ‘attr’, 42) 都会触发 Class.__getattribute__(obj, &#39;attr&#39;) 方法。 __delattr__(self, name)：只要使用 del 语句删除属性， 就会调用这个方法。 例如， del obj.attr 语句触发 Class.__delattr__(obj, &#39;attr&#39;) 方法。 __dir__(self)：把对象传给 dir 函数时调用， 列出属性。 例如， dir(obj) 触发 Class.__dir__(obj) 方法。 __getattr__(self, name)：仅当获取指定的属性失败， 搜索过 obj、 Class 和超类之后调用。表达式 obj.no_such_attr、 getattr(obj, ‘no_such_attr’) 和hasattr(obj, ‘no_such_attr’) 可能会触发 Class.__getattr__(obj, &#39;no_such_attr&#39;) 方法， 但是， 仅当在obj、 Class 和超类中找不到指定的属性时才会触发。 __setattr__(self, name, value)：尝试设置指定的属性时总会调用这个方法。 点号和 setattr 内置函数会触发这个方法。 例如， obj.attr = 42 和 setattr(obj,’attr’, 42) 都会触发 Class.__setattr__(obj, ‘attr’, 42) 方法。 __getattribute__(self, name)：尝试获取指定的属性时总会调用这个方法， 不过， 寻找的属性是特殊属性或特殊方法时除外。 点号与 getattr 和 hasattr 内置函数会触发这个方法。 调用 __getattribute__ 方法且抛出 AttributeError 异常时， 才会调用 __getattr__ 方法。 为了在获取 obj 实例的属性时不导致无限递归， __getattribute__ 方法的实现要使用 super().__getattribute__(obj, name)。 属性描述符描述符是对多个属性运用相同存取逻辑的一种方式。描述符是实现了特定协议的类， 这个协议包括 __get__、 __set__ 和 __delete__ 方法。 property 类实现了完整的描述符协议。 通常， 可以只实现部分协议。我们在真实的代码中见到的大多数描述符只实现了 __get__ 和 __set__ 方法， 还有很多只实现了其中的一个。Django模型的字段就是描述符。 描述符示例：验证属性把19章的把 quantity 特性工厂函数重构成 Quantity 描述符类。 术语说明： 描述符类：实现描述符协议的类 托管类：把描述符实例声明为类属性的类 描述符实例：描述符类的各个实例， 声明为托管类的类属性 托管实例：托管类的实例 储存属性：托管实例中存储自身托管属性的属性 托管属性：托管类中由描述符实例处理的公开属性， 值存储在储存属性中。 也就是说， 描述符实例和储存属性为托管属性建立了基础 123456789101112131415161718192021222324252627class Quantity(): # 基于协议实现，不用继承 def __init__(self, storage_name): self.storage_name = storage_name # 储存属性的名称 def __set__(self, instance, value): # 为托管属性赋值时调用，设置托管实例的储存属性 if value &gt; 0: # 如果使用内置的setattr 函数， 会再次触发 __set__ 方法， 导致无限递归 instance.__dict__[self.storage_name] = value else: raise ValueError('value must be &gt; 0')class LineItem(): weight = Quantity('weight') # 把描述符实例绑定到类属性 weight price = Quantity('price') def __init__(self, desc, weight, price): self.desc = desc self.weight = weight self.price = price def subtotal(self): return self.weight*self.pricetruffle = LineItem('White truffe', 100, 10)print(vars(truffle)) 自动获取储存属性的名称123456789101112131415161718192021222324252627282930class Quantity(): __counter = 0 # Quantity的私有类属性 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) # 为每个储存属性生成一个唯一的名称 cls.__counter += 1 def __get__(self, instance, owner): # instance是托管实例的引用， owner是托管类（如 LineItem） 的引用 if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): if value &gt; 0: # 因为托管属性和储存属性的名称不同， 所以把储存属性传给 getattr 函数不会触发描述符 setattr(instance, self.storage_name, value) else: raise ValueError('value must be &gt; 0')class LineItem(): weight = Quantity() price = Quantity() pass 重构描述符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import abcclass AutoStorage(): # AutoStorage 类提供了之前 Quantity 描述符的大部分功能 __counter = 0 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) cls.__counter += 1 def __get__(self, instance, owner): if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): setattr(instance, self.storage_name, value)class Validated(abc.ABC, AutoStorage): def __set__(self, instance, value): # 把验证操作委托给 validate 方法 value = self.validate(instance, value) super().__set__(instance, value) @abc.abstractmethod def validate(self, instance, value): """return validated value or raise ValueError"""class Quantity(Validated): """a number greater than zero""" def validate(self, instance, value): if value &lt;= 0: raise ValueError('value must be &gt; 0') return valueclass NonBlank(Validated): """a string with at least one non-space character""" def validate(self, instance, value): value = value.strip() if len(value) == 0: raise ValueError('value cannot be empty or blank') return valueclass LineItem(): desc = NonBlank() weight = Quantity() price = Quantity() pass 12345import lineitemprint(lineitem.Quantity.__mro__) # (&lt;class 'lineitem.Quantity'&gt;, &lt;class 'lineitem.Validated'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'lineitem.AutoStorage'&gt;, &lt;class 'object'&gt;)print(LineItem5.Quantity.__mro__) 覆盖型和非覆盖型描述符对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]def display(obj): cls = type(obj) if cls is type: return '&lt;class &#123;&#125;&gt;'.format(obj.__name__) elif cls in [type(None), int]: return repr(obj) else: return '&lt;&#123;&#125; object&gt;'.format(cls_name(obj))def print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print('-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'.format(cls_name(args[0]), name, pseudo_args))class Overriding(): # 有 __get__ 和 __set__ 方法的典型覆盖型描述符 def __get__(self, instance, owner): print_args('get', self, instance, owner) def __set__(self, instance, value): print_args('set', self, instance, value)class OverridingNoGet: # 没有 __get__ 方法的覆盖型描述符 def __set__(self, instance, value): print_args('set', self, instance, value)class NonOverriding: # 没有 __set__ 方法， 所以这是非覆盖型描述符 def __get__(self, instance, owner): print_args('get', self, instance, owner)class Managed: over = Overriding() over_no_get = OverridingNoGet() non_over = NonOverriding() def spam(self): # 为了对比， 因为方法也是描述符 print('-&gt; Managed.spam(&#123;&#125;)'.format(display(self)))obj = Managed() 覆盖型描述符：也叫数据描述符或强制描述符，实现 __set__ 方法的描述符属于覆盖型描述符， 因为虽然描述符是类属性， 但是实现 __set__ 方法的话， 会覆盖对实例属性的赋值操作 12345678obj.over # (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)Managed.over # (&lt;Overriding object&gt;, None, &lt;class Managed&gt;)obj.over = 7 # (&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)obj.over # (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.__dict__['over'] = 8print(vars(obj)) # &#123;'over': 8&#125;obj.over # 即使有了over的实例属性，Managed.over仍会覆盖读取obj.over操作# (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;) 没有 __get__ 方法的覆盖性描述符： 12345678910111213# 没有实现__get__方法，因此从类中获取描述符实例 &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;print(obj.over_no_get)# &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;print(Managed.over_no_get)# 触发__set__方法，(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get = 7# 仍是托管类中的描述符实例，&lt;__main__.OverridingNoGet object at 0x000001A913D8C908&gt;print(obj.over_no_get)obj.__dict__['over_no_get'] = 9print(obj.over_no_get) # 9，over_no_get 实例属性会遮盖描述符， 但是只有读操作是如此# 仍然经过描述符的 __set__ 方法处理。(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get = 7print(obj.over_no_get) # 9，只要有同名的实例属性存在，描述符就会被遮盖 非覆盖型描述符：也叫非数据描述符或遮盖型描述符，没有实现 __set__ 方法的描述符是非覆盖型描述符。 1234567obj.non_over # (&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.non_over = 7 # 非覆盖型描述符，没有干涉赋值操作的__set__方法print(obj.non_over) # 7，名为 non_over 的实例属性，把类的同名描述符属性遮盖掉了Managed.non_over # (&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)del obj.non_over# 删掉实例属性后，仍然触发了描述符。(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.non_over 在类中覆盖描述符不管描述符是不是覆盖型， 为类属性赋值都能覆盖描述符。读类属性的操作可以由依附在托管类上定义有 __get__ 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 __set__ 方法的描述符处理 1234Managed.over = 1Managed.over_no_get = 2Managed.non_over = 3print(obj.over, obj.over_no_get, obj.non_over) # 1 2 3，描述符真的不见了 方法是描述符在类中定义的函数属于绑定方法（bound method） ， 因为用户定义的函数都有 __get__ 方法， 所以依附到类上时， 就相当于描述符。 方法是非覆盖型描述符。 123456789obj = Managed()# obj.spam 获取的是绑定方法对象。&lt;bound method Managed.spam of &lt;__main__.Managed object at ...&gt;&gt;print(obj.spam)# Managed.spam 获取的是函数。&lt;function Managed.spam at 0x0000013D5D3DD400&gt;print(Managed.spam)obj.spam = 7 # 为 obj.spam 赋值，创建了同名的实例属性，将会遮盖类属性，导致无法通过 obj 实例访问 spam 方法print(obj.spam) # 7print(Managed.spam) # &lt;function Managed.spam at 0x0000013D5D3DD400&gt; 与描述符一样， 通过托管类访问时， 函数的 __get__ 方法会返回自身的引用。 但是， 通过实例访问时， 函数的 __get__ 方法返回的是绑定方法对象： 一种可调用的对象， 里面包装着函数， 并把托管实例（例如 obj） 绑定给函数的第一个参数（即 self） ， 这与 functools.partial 函数的行为一致。 12345678910111213141516171819202122232425262728import collectionsclass Text(collections.UserString): def __repr__(self): return 'Text(&#123;!r&#125;)'.format(self.data) def reverse(self): return self[::-1]word = Text('forward')print(word) # forwardprint(word.reverse()) # drawrofprint(Text.reverse(word)) # drawrof，在类上调用方法相当于调用函数# &lt;class 'function'&gt; &lt;class 'method'&gt;print(type(Text.reverse), type(word.reverse))# 函数都是非覆盖型描述符。 在函数上调用 __get__ 方法时传入实例， 得到的是绑定到那个实例上的方法。# &lt;bound method Text.reverse of Text('forward')&gt;print(Text.reverse.__get__(word))# 如果 instance 参数的值是 None， 那么得到的是函数本身# &lt;function Text.reverse at 0x000001F3A93DF0D0&gt;print(Text.reverse.__get__(None, Text))# word.reverse 表达式其实会调用Text.reverse.__get__(word)， 返回对应的绑定方法# &lt;bound method Text.reverse of Text('forward')&gt;print(word.reverse)print(word.reverse.__self__) # forward，调用这个方法的实例引用。print(word.reverse.__func__ is Text.reverse) # True，依附在托管类上那个原始函数的引用 绑定方法对象还有个 __call__ 方法， 用于处理真正的调用过程。 这个方法会调用 __func__ 属性引用的原始函数， 把函数的第一个参数设为绑定方法的 __self__ 属性。 描述符用法建议 使用特性以保持简单 内置的 property 类创建的其实是覆盖型描述符， __set__ 方法和 __get__ 方法都实现了， 即便不定义设值方法也是如此。 特性的 __set__ 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性， 这能避免下一条所述的问题。 只读描述符必须有 __set__ 方法 如果使用描述符类实现只读属性， 要记住， __get__ 和 __set__ 两个方法必须都定义， 否则， 实例的同名属性会遮盖描述符。 只读属性的 __set__ 方法只需抛出 AttributeError 异常， 并提供合适的错误消息。 用于验证的描述符可以只有 __set__ 方法 对仅用于验证的描述符来说， __set__ 方法应该检查 value 参数获得的值， 如果有效， 使用描述符实例的名称为键， 直接在实例的 __dict__ 属性中设置。 这样， 从实例中读取同名属性的速度很快， 因为不用经过 __get__ 方法处理。 仅有 __get__ 方法的描述符可以实现高效缓存 如果只编写了 __get__ 方法， 那么创建的是非覆盖型描述符。 这种描述符可用于执行某些耗费资源的计算， 然后为实例设置同名属性，缓存结果。 同名实例属性会遮盖描述符， 因此后续访问会直接从实例的 __dict__ 属性中获取值， 而不会再触发描述符的 __get__ 方法。 非特殊的方法可以被实例属性遮盖 由于函数和方法只实现了 __get__ 方法， 它们不会处理同名实例属性的赋值操作。 因此， 像 my_obj.the_method = 7 这样简单赋值之后， 后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。 然而， 特殊方法不受这个问题的影响。 解释器只会在类中寻找特殊的方法， 也就是说， repr(x) 执行的其实是 x.__class__.__repr__(x)， 因此 x 的 __repr__ 属性对 repr(x) 方法调用没有影响。 出于同样的原因， 实例的 __getattr__ 属性不会破坏常规的属性访问规则。 类元编程类元编程是指在运行时创建或定制类的技艺。元类是类元编程最高级的工具： 使用元类可以创建具有某种特质的全新类种， 例如我们见过的抽象基类。 类工厂函数12345class Dog: def __init__(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner 避免编写上述样板代码，我们下面创建一个类工厂函数，即可变对象版本的collections.namedtuple。 1234567891011121314151617181920212223242526272829303132333435def record_factory(cls_name, field_names): try: field_names = field_names.replace(',', ' ').split() except AttributeError: # 不能调用.replace或.split方法 pass # 假定field_names本就是标识符组成的序列 # 构建元组，这将成为新建类的 __slots__ 属性；这么做还设定了拆包和字符串表示形式中各字段的顺序 field_names = tuple(field_names) def __init__(self, *args, **kwargs): attrs = dict(zip(self.__slots__, args)) attrs.update(kwargs) for name, value in attrs.items(): setattr(self, name, value) def __iter__(self): for name in self.__slots__: yield getattr(self, name) def __repr__(self): values = ', '.join('&#123;&#125;=&#123;!r&#125;'.format(*i) for i in zip(self.__slots__, self)) return '&#123;&#125;(&#123;&#125;)'.format(self.__class__.__name__, values) cls_attrs = dict(__slots__=field_names, __init__=__init__, __iter__=__iter__, __repr__=__repr__) return type(cls_name, (object,), cls_attrs) # 调用 type 构造方法，构建新类，然后返回Dog = record_factory('Dog', 'name weight owner')rex = Dog('Rex', 30, 'Bob')print(rex) # Dog(name='Rex', weight=30, owner='Bob') type 的实例是类。 1234ty = type('MyClass', (object,), &#123;'x': 1&#125;)print(type(ty)) # &lt;class 'type'&gt;obj = ty()print(obj) # &lt;__main__.MyClass object at ...&gt; 相当于 1234class MyClass(): x = 1print(type(MyClass)) # &lt;class 'type'&gt; 定制描述符的类装饰器类装饰器与函数装饰器非常类似， 是参数为类对象的函数， 返回原来的类或修改后的类。 123456789101112def entity(cls): # 类装饰器的参数是一个类 for key, attr in cls.__dict__.items(): if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key) return cls@entityclass LineItem(): desc = NonBlank() weight = Quantity() price = Quantity() 类装饰器能以较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。 类装饰器有个重大缺点： 只对直接依附的类有效。 这意味着， 被装饰的类的子类可能继承也可能不继承装饰器所做的改动，这个缺点在下面解决。 导入时和运行时比较 evaltime.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344from evalsupport import deco_alphaprint('&lt;[1]&gt; evaltime module start')class ClassOne(): print('&lt;[2]&gt; ClassOne body') def __init__(self): print('&lt;[3]&gt; ClassOne.__init__') def __del__(self): print('&lt;[4]&gt; ClassOne.__del__') def method_x(self): print('&lt;[5]&gt; ClassOne.method_x') class ClassTwo(object): print('&lt;[6]&gt; ClassTwo body')@deco_alphaclass ClassThree(): print('&lt;[7]&gt; ClassThree body') def method_y(self): print('&lt;[8]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[9]&gt; ClassFour body') def method_y(self): print('&lt;[10]&gt; ClassFour.method_y')if __name__ == '__main__': print('&lt;[11]&gt; ClassOne tests', 30 * '.') one = ClassOne() one.method_x() print('&lt;[12]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[13]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('&lt;[14]&gt; evaltime module end') evalsupport.py 1234567891011121314151617181920212223print('&lt;[100]&gt; evalsupport module start')def deco_alpha(cls): print('&lt;[200]&gt; deco_alpha') def inner_1(self): print('&lt;[300]&gt; deco_alpha:inner_1') cls.method_y = inner_1 return clsclass MetaAleph(type): print('&lt;[400]&gt; MetaAleph body') def __init__(cls, name, bases, dic): # cls（self）：这是要初始化的类对象（例如 ClassFive） print('&lt;[500]&gt; MetaAleph.__init__') def inner_2(self): # self，是初始化类的实例 print('&lt;[600]&gt; MetaAleph.__init__:inner_2') cls.method_z = inner_2print('&lt;[700]&gt; evalsupport module end') 场景1：import evaltime 12345678910111213&gt;&gt;&gt; import evaltime# evalsupport 模块中的所有顶层代码在导入模块时运行； 解释器会编译 deco_alpha 函数， 但是不会执行定义体。&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body # MetaAleph 类的定义体运行了&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassOne body # 每个类的定义体都执行了&lt;[6] &gt; ClassTwo body&lt;[7] &gt; ClassThree body&lt;[200] &gt; deco_alpha # 先计算被装饰的类 ClassThree 的定义体， 然后运行装饰器函数。&lt;[9] &gt; ClassFour body&lt;[14] &gt; evaltime module end # evaltime 模块是导入的， 因此不会运行 if __name__ == '__main__': 块 场景2：python3 evaltime.py 1234567891011121314151617181920&gt;&gt;&gt; py evaltime.py&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassOne body&lt;[6] &gt; ClassTwo body&lt;[7] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[9] &gt; ClassFour body&lt;[11] &gt; ClassOne tests ..............................&lt;[3] &gt; ClassOne.__init__&lt;[5] &gt; ClassOne.method_x&lt;[12] &gt; ClassThree tests ..............................&lt;[300] &gt; deco_alpha: inner_1&lt;[13] &gt; ClassFour tests ..............................&lt;[10] &gt; ClassFour.method_y # 类装饰器可能对子类没有影响&lt;[14] &gt; evaltime module end&lt;[4] &gt; ClassOne.__del__ # 程序结束时， 绑定在全局变量 one 上的 ClassOne 实例才会被垃圾回收程序回收。 元类基础知识元类是制造类的工厂， 不过不是函数， 而是类。元类是用于构建类的类。 根据 Python 对象模型， 类是对象， 因此类肯定是另外某个类的实例。 默认情况下， Python 中的类是 type 类的实例。 也就是说， type 是大多数内置的类和用户定义的类的元类。 123print('spam'.__class__) # &lt;class 'str'&gt;print(str.__class__) # &lt;class 'type'&gt;print(type.__class__) # 为了避免无限回溯， type 是其自身的实例。 type和object的关系 ABCMeta和type的关系 所有类都是 type 的实例， 但是元类还是 type 的子类， 因此可以作为制造类的工厂。 具体来说， 元类可以通过实现 __init__ 方法定制实例。 元类的 __init__ 方法可以做到类装饰器能做的任何事情， 但是作用更大。 元类计算时间的练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from evalsupport import deco_alphafrom evalsupport import MetaAlephprint('&lt;[1]&gt; evaltime module start')@deco_alphaclass ClassThree(): print('&lt;[2]&gt; ClassThree body') def method_y(self): print('&lt;[3]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[4]&gt; ClassFour body') def method_y(self): print('&lt;[5]&gt; ClassFour.method_y')class ClassFive(metaclass=MetaAleph): print('&lt;[6]&gt; ClassFive body') def __init__(self): print('&lt;[7]&gt; ClassFive.__init__') def method_z(self): print('&lt;[8]&gt; ClassFive.method_z')class ClassSix(ClassFive): print('&lt;[9]&gt; ClassSix body') def method_z(self): print('&lt;[10]&gt; ClassSix.method_z')if __name__ == '__main__': print('&lt;[11]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[12]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('&lt;[13]&gt; ClassFive tests', 30 * '.') five = ClassFive() five.method_z() print('&lt;[14]&gt; ClassSix tests', 30 * '.') six = ClassSix() six.method_z()print('&lt;[15]&gt; evaltime_meta module end') 场景3：import evaltime_meta 1234567891011121314&gt;&gt;&gt; import evaltime_meta&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[4] &gt; ClassFour body&lt;[6] &gt; ClassFive body&lt;[500] &gt; MetaAleph.__init__ #创建 ClassFive 时调用了 MetaAleph.__init__ 方法&lt;[9] &gt; ClassSix body&lt;[500] &gt; MetaAleph.__init__ #创建 ClassFive 的子类 ClassSix 时也调用了 MetaAleph.__init__ 方法&lt;[15] &gt; evaltime_meta module end 场景4：py evaltime_meta.py 123456789101112131415161718192021222324&gt;&gt;&gt; py evaltime_meta.py&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[4] &gt; ClassFour body&lt;[6] &gt; ClassFive body&lt;[500] &gt; MetaAleph.__init__&lt;[9] &gt; ClassSix body&lt;[500] &gt; MetaAleph.__init__&lt;[11] &gt; ClassThree tests ..............................&lt;[300] &gt; deco_alpha: inner_1&lt;[12] &gt; ClassFour tests ..............................&lt;[5] &gt; ClassFour.method_y #没有直接依附装饰器的 ClassFour 类不受影响&lt;[13] &gt; ClassFive tests ..............................&lt;[7] &gt; ClassFive.__init__&lt;[600] &gt; MetaAleph.__init__: inner_2&lt;[14] &gt; ClassSix tests ..............................&lt;[7] &gt; ClassFive.__init__&lt;[600] &gt; MetaAleph.__init__: inner_2 #ClassSix 类没有直接引用 MetaAleph 类， 但是却受到了影响， 因为它是 ClassFive 的子类， 进而也是 MetaAleph 类的实例， 所以由 MetaAleph.__init__ 方法初始化。&lt;[15] &gt; evaltime_meta module end 定制描述符的元类替代 @entity 装饰器： 1234567891011121314151617181920212223class EntityMeta(type): """元类， 用于创建带有验证字段的业务实体""" def __init__(cls, name, bases, attr_dict): # 在超类（在这里是 type） 上调用 __init__ 方法 super().__init__(name, bases, attr_dict) for name, attr in attr_dict.items(): # 与 @entity 装饰器的逻辑一样 if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, name)# 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类class Entity(metaclass=EntityMeta): """带有验证字段的业务实体"""import line_item as modelclass LineItem(model.Entity): desc = model.NonBlank() weight = model.Quantity() price = model.Quantity() pass 元类的特殊方法 prepare在某些应用中， 可能需要知道类的属性定义的顺序。type 构造方法及元类的 __new__ 和 __init__ 方法都会收到要计算的类的定义体， 形式是名称到属性的映射。 然而在默认情况下， 那个映射是字典； 也就是说，元类或类装饰器获得映射时， 属性在类定义体中的顺序已经丢失了。 1234567891011121314151617181920212223242526class EntityMeta(type): """元类， 用于创建带有验证字段的业务实体""" @classmethod def __prepare__(cls, name, bases): return collections.OrderedDict() def __init__(cls, name, bases, attr_dict): super().__init__(name, bases, attr_dict) cls._field_names = [] # 非私有属性 # 这里的 attr_dict 是那个OrderedDict 对象， 由解释器在调用 __init__ 方法之前调用 __prepare__ 方法时获得（prepare-&gt;new-&gt;init） # 因此， 这个 for 循环会按照添加属性的顺序迭代属性 for key, attr in attr_dict.items(): if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key) cls._field_names.append(key)# 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类class Entity(metaclass=EntityMeta): """带有验证字段的业务实体""" @classmethod def field_names(cls): for name in cls._field_names: yield name 调用： 12for name in LineItem.field_names(): print(name) __prepare__：这个特殊方法只在元类中有用， 而且必须声明为类方法（即使用@classmethod 装饰器定义） 。 解释器调用元类的 __new__ 方法之前会先调用 __prepare__ 方法， 使用类定义体中的属性创建映射。 __prepare__ 方法的第一个参数是元类， 随后两个参数分别是要构建的类的名称和基类组成的元组， 返回值必须是映射。 元类构建新类时，__prepare__ 方法返回的映射会传给 __new__ 方法的最后一个参数， 然后再传给 __init__ 方法。 框架和库会使用元类协助程序员执行很多任务， 例如： 验证属性 一次把装饰器依附到多个方法上 序列化对象或转换数据 对象关系映射 基于对象的持久存储 动态转换使用其他语言编写的类结构 类作为对象Python 数据模型为每个类定义了很多属性，除了 __mro__ 、 __class__ 和 __name__ 属性之外，还有： cls.__bases__：由类的基类组成的元组 cls.__qualname__：其值是类或函数的限定名称， 即从模块的全局作用域到类的点分路径。例如：内部类ClassTwo 的 __qualname__ 属性， 其值是字符串 ‘ClassOne.ClassTwo’， 而 __name__ 属性的值是 ‘ClassTwo’ cls.__subclasses__()：包含类的直接子类。 这个方法的实现使用弱引用， 防止在超类和子类（子类在 __bases__ 属性中储存指向超类的强引用） 之间出现循环引用。 这个方法返回的列表中是内存里现存的子类 cls.mro()：超类元组 dir(…) 函数不会列出本节提到的任何一个属性。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编程：从入门到实践_注释笔记]]></title>
    <url>%2F2018%2F07%2F30%2FPython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符串1234567name.title() # 首字母大写name.upper() name.lower() # 转换大小写name.rstrip() name.lstrip()name.strip() # 删除右边/左边/两边的空格"age" + 12 # 会报错，应使用str()方法将数字转换成字符串 列表元素操作123456list.append(item) # 新增list.insert(0,item) # 插入del list[1] # 删除某索引元素list.pop() # 删除列表末尾元素，并返回它list.pop(2) # 弹出列表中某索引的元素，并返回它list.remove('alan') # 根据值来删除元素，只删除第一个符合的 组织列表1234list.sort() # 永久排序，改变自身sorted(list) # 临时排序，不改变列表list.reverse() # 按索引反转列表，改变自身len(list) # 计算列表长度 操作列表遍历12for item in list: pass 创建数值列表1range(1,5) # 左闭右开，1,2,3,4 简单统计123min(list)max(list)sum(list) 列表推导式1squares = [item**2 for item in range(1,11)] # 返回从1-10的平方的列表 切片123list[0:3] # 返回索引为0-2的元素列表，左闭右开list[:3] # 冒号左边缺省则默认从0，右边缺省则默认列表的lengthlist[:] # 浅复制整个列表 元组tuple = (30,100)不可变的列表称为元组遍历元组同列表一样，元组元素不可修改，但是可以重新定义整个元组变量 字典dict = {} 12345678910111213141516171819dict['name'] = 'alan' # 新增/更新del dict['name'] # 删除dict.pop('name') # 删除并返回items() # 返回由字典每一对键值构成的元组的列表keys() # 返回字典所有键组成的列表values() # 返回值的列表for key,value in dict.items(): # 遍历 passfor key in sorted(dict.keys()): # 按字符顺序遍历 passfor value in set(dict.values()): # 获取唯一不重复的值 passif 'name' in dict.keys(): # 判断键值是否存在 pass while循环假值123456d = &#123;&#125;l = []set1 = set()t = tuple()i = 0str1 = '' 假值转换为bool时为False,如if not set1:/while l: 移动元素12345arr1 = ['str1', 'str2', 'str3']arr2 = []while arr1: arr2.append(arr1.pop()) 删除特定元素1234arr1 = ['str1', 'str2', 'str3', 'str1']while 'str1' in arr1: arr1.remove('str1') 函数定义1234567891011121314151617181920def funcname(p1, p2='dog'): # 可选参数 passfuncname('123', p2='cat') # 通过关键字传递实参funcname( arr[:] ) # 传递列表副本，避免被函数内部修改def make(name,*args): # 可传递任意数量的实参，必须放在其他形参之后 print(args) # 创建一个参数组成的元组make('a1','a2','3') make() # 空元组 def make(name, **kwargs): # 传递任意数量的关键字实参 profile = &#123;'name': name&#125; for key, value in kwargs.items(): profile[key] = value return profileprint make('alan', age=20, gender='male') 导入123import make as m # 设置别名from make import remake # 导入特定函数from make import * # 导入所有函数，调用时不再需要模块名前缀 类定义类和方法123456789class Dog(): # python 3.x def __init__(self, name): # self代表实例自身的引用 self.name = name def sit(self): print(self.name+"is sitting")class Dob(object): # python 2.7 pass 继承12345678910111213141516171819202122232425262728# car.py"""this is a car module"""class Car(): def __init__(self, model): self.model = model def fill_gas(self): print('filling')class ElectricCar(Car): def __init__(self, model): super().__init__(model) def fill_gas(self): print('not need gas')from car import ElectricCarc = ElectricCar('ss')c.fill_gas()from car import Car,ElectricCar # 导入模块中的多个类import car # 导入整个模块from car import * # 导入模块中的所有类 Python标准库123456789# OrderedDictfrom collections import OrderedDictdict = OrderedDict()dict['sarah'] = 'c'dict['jen'] = 'python'dict['phil'] = 'ruby'print(dict) 有序字典，保留数据初始时的顺序 编码风格：类名：驼峰命名法，首字母大写，不使用下划线实例名和模块名：小写，单词之间加下划线模块和类都要包含一个文档字符串空行的使用：类中使用一个空行分隔方法，模块中使用两个空行来分隔类导入模块时，先导入标准库模块，再添加一个空行，然后导入自己编写的模块 文件和异常文件读取1234567891011with open('test.txt') as txt: # 一次读取一行 for row in txt: print(row.strip()) # 读取全部内容 print(txt.read()) # 加载到list中 lines = txt.readlines() # list 写入123with open('test.txt','w') as txt: txt.write()('123123\n') txt.write()('abcabc\n') 参数说明：r - 读取模式r+ - 读取和写入w - 写入模式a - 附加模式w和a模式，当文件不存在时则创建 异常ZeroDivisionError：除以0时抛出FileNotFoundError：文件未找到时抛出 1234567try: --skip--except FileNotFoundError as e: #发生异常 pass else: #未发生异常时 --skip-- 存储数据json存储和读取12345678import jsondic = &#123;'name': 'alan', 'age': 12&#125;with open('text.txt', 'a') as txt: json.dump(dic, txt) # 存储with open('text.txt', 'r') as txt: re = json.load(txt) #读取 print(type(re)) #dict，自动转换类型 单元测试12345678910111213141516import unittestfrom car import Carclass TestCarMethod(unittest.TestCase): #测试用例，包含多个单元测试 def setUp(self): self.c = Car() #setUp方法，初始化下面要用到的数据 def test_set(self): re = self.c.set_wheels(5) self.assertFalse(re) #断言方法，表达式是否为False def test_get(self): wheels = self.c.get_wheels() self.assertIn(wheels, range(1, 5)) #值是否包含于列表中unittest.main() 运行测试用例时，每完成一个单元测试，通过时打印一个句点。引发错误时打印一个E，断言失败时打印F]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级程序设计_注释笔记]]></title>
    <url>%2F2018%2F02%2F04%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本概念解释型和编译型语言的区别 编译型 需要编译器。把高级语言编译为机器码文件，编译期代码检查，执行速度更快，一次编译处处执行，可移植性更好。如：Java，C#等。 解释性 需要解释器。解释器直接读入源代码，边解释（编译）边执行。错误只能等到解释器执行的有关代码时才能被发现，再次运行，需要重新解释，速度较慢。如：JS，Python等。 完整的JavaScript的三个部分 核心（ECMAScript） 与Web浏览器没有依赖关系，是基础。定义了： 语法，类型，语句，关键字，保留字，操作符，对象 文档对象模型（DOM） 针对XML但经过扩展用于HTML的API。 DOM1级，包括DOM核心（DOM Core）和DOM HTML。 浏览器对象模型（BOM） 处理浏览器和框架 严格模式&quot;use strict&quot; 编译指示，为了不破坏ECMAScript 3语法，一些不确定的行为将得到处理，对于某些不安全的操作也会抛出错误。 局部域定义全局变量123function test()&#123; msg = "hi"; // 全局变量&#125; 并不推荐，很难维护。相应变量不会马上就有定义导致混乱。 数据类型undefined,null,boolean,number,string typeof 操作符未定义 - undefined布尔值 - boolean字符串 - string数值 - number对象或null - object函数 - function 从技术上来讲，函数在ECMAScript中是对象，不是一种数据类型。然后函数有一些特殊的属性，typeof得到的值也不同于对象 undefined类型12345var v1; //声明之后默认取得undefined值alert(v1); //"undefined"alert(v2); //引用错误alert(typeof v1) //"undefined"alert(typeof v2) //"undefined" null类型typeof null //返回 object 适用于，准备将变量用于保存对象，那么最好将变量初始化为null，而不是其他值。使用 if(obj != null)来判断是否已经保存对象的引用。 undefined值派生自null值，所以null == undefined 返回ture。 boolean类型123456if (true) &#123; //通过，区分大小写 alert(1)&#125;if (True) &#123; //不通过，不是Boolean值，只是标识符 alert(1)&#125; Boolean()函数，传入任何参数总会返回Boolean值。规则如下： 类型 返回true 返回false Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined N/A（不适用） undefined 不传参数，返回false。 if()语句，自动执行Boolean()函数。 Number类型 整数值： 整数值可以以十进制，八进制，十六进制来表示。 1234var num=070; //前导0，十进制的56var num=079; //无效，前导0被忽略，解析为79var num=0xA; //前导0x，十进制的10var num=0x1z //无效，报错 浮点数值： 12345var num=1.; //解析为整数，1var num=10.0; //解析为整数，10简写：var num=3.12e7; //3.12乘以10的7次方var num=3.12e-7; //3.12乘以0.1的7次方 PS：0.1+0.2 == 0.3 返回false，因为ECMAScript的浮点运算基于IEEE754，存在二进制和十进制的小数点转换问题，并非独此一家。 数值范围 12345alert(Number.MAX_VALUE + Number.MAX_VALUE) //返回Infinityalert(-1 * (Number.MAX_VALUE + Number.MAX_VALUE)) //返回-InfinityNumber.POSITIVE_INFINITY //保存着InfinityNumber.NEGATIVE_INFINITY //保存着-InfinityisFinite() //判断是否是有穷的，Infinity返回false，MAX_VALUE返回ture，MAX_VALUE+1返回ture NaN 任何涉及NaN的计算，返回都是NaN。 NaN与任何值都不相等，包括NaN本身。NaN == NaN ，返回false。 12345isNaN(NaN) //trueisNaN(10) //falseisNaN("10"/"") //false ，可被转换成数值10/0isNaN("blue") //true，不能转换isNaN(ture/false) //false，可别转换成数值1 数值转换 Number()，用于任何数据类型 规则： Boolean，ture和false分别转换为1和0 数字，直接返回 null，返回0 undefined，返回NaN 字符串：整数，浮点数，对应的十进制。有效的十六进制，等值的十进制整数。空字符串，0；包含其他字符，NaN 对象，先调用valueOf()方法，然后按照前面的规则转换返回的值，如果结果为NaN。再调用toString()方法。然后转换返回的字符串 parseInt()，parseFloat()，转换字符串。 String类型123var num=10;num.toString() //'10'num.toString(2) //'1010' 2/8/10/16，转换成相应的进制 Object类型常用属性/方法： Constructor：保存着用于创建当前对象的构造函数。 hasOwnProperty(name)：检查给定的属性在当前对象实例中是否存在。 toString() valueOf()，返回对象的字符串，数值或布尔值表示 BOM和DOM中的对象，属于宿主对象。可能不会集成Object。 操作符乘法有一个数是NaN，结果是NaN。Infinity与0相乘，结果是NaN。Infinity与非0相乘，结果是Infinity或-Infinity，取决于操作数的符号。如果是Infinity与Infinity相乘，结果是Infinity。如果一个不是数值，则调用Number()转换为数值后再相乘。 除法一个数是NaN，结果NaN。Infinity被Infinity除，结果是NaN。0被0除，结果NaN。非零有限数被0除，结果是Infinity或-Infinity，取决于符号。(-1/0)Infinity被非零数除，结果是Infinity或-Infinity，取决于符号。一个操作数不是数值，同乘法。 加法123Infinity+Infinity=Infinity-Infinity-Infinity=-InfinityInfinity-Infinity=NaN 如果一个操作数是字符串，调用他们的toString()得到字符串（undefined和null调用String()返回字面量），然后拼接。两个都是字符串，则直接拼接。没有字符串，则先调用Number()转换为数值，再进行加法。 减法1234Infinity-Infinity=NaN-Infinity+Infinity=NaNInfinity+Infinity=Infinity-Infinity-Infinity=-Infinity 如果一个操作数是字符串，布尔值，null或undefined，则先调用Number()函数转换为数值，再根据规则进行减法。如果转换为NaN，则结果是NaN。 +/- 操作符对非数值应用一元操作符时，会先执行Number()函数转换，然后在转为正/负数。 123456+"01" //1-"01" //-1+"z" //NaN-"z" //NaN+false //0-false //0 比较操作符两个字符串，比较两个字符串对应的字符编码值。一个数值，一个非数值，先进行数值转换。一个对象，则调用valueOf()方法，没有则调用toString()方法。再比较。 12345"a" &gt;/&lt; 3 //false，先进行转换"a"-&gt;NaN"a" &gt; "3" //true"23" &lt; "3" //true"23" &gt; 3 //true任何数与NaN比较，结果都是false 相等和不相等默认先进行强制转型，再比较。字符串/布尔，先转换，再比较。一个对象，一个不是，则调用对象的valueOf方法。两个都是对象，则比较是不是同一个对象。null和undefined是相等的，且比较时都不会执行转换。 特殊情况： 1234567891011null == undefined //trueundefined == 0 //falsenull == 0 //false"NaN" == NaN //falseNaN == 5 //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //false"5" == 5 //true 语句for-in语句可以用来枚举对象的属性1234for (var prop in window) &#123; var element = window[prop]; console.log(prop + ' ' + element)&#125; switch语句可以使用任何数据类型，case的值可以是常量，变量，或者表达式123456789101112var num = 12;switch (true) &#123; case num &gt; 10: alert("&gt;") break; case num &lt; 10: alert("&lt;") break; default: alert("=") break;&#125; 函数定义时不必制定是否返回值。 严格模式下，不能把函数/参数命名为eval或arguments，不能有连个同名参数。 参数ECMAScript函数不介意传递进多少个参数，不也在乎参数类型。定义和实际传递的参数没有个数与对应关系的限制。因为，参数在内部是用一个类似数组的对象（Arguments对象，并不是真的数组）来表示的。而不关心数组中包含哪些参数。12345name(1) //length 为1name(1,2) //length 为2function name() &#123; alert(arguments[0]) &#125; 命名参数只提供便利，但不是必须的。解析器不会验证命名参数。1234function add(num1,num2)&#123; arguments[1]=10; alert(arguments[0]+num2);&#125; 修改了arguments[1]的值，也就修改了num2，他们的值都会改变。不过它们的内存空间是独立的，但它们的值会同步。 arguments.callee返回的是当前执行的函数。 js的函数没有重载，重复定义的函数不论参数列表，后定义的函数会覆盖前面的函数。但可以使用arguments对象来模拟实现。 变量、作用域和内存基本类型和引用类型传递参数ECMAScript所有函数的参数都是按值传递。对于引用类型(对象)来说，不会改变原始引用，只会根据引用改变对象的成员。12345678910var p = &#123; name: 'bily' &#125;;set(p);alert(p.name)①function set(p) &#123; p = &#123;&#125;; p.name = 'alan';&#125;②function set(p) &#123; p.name = 'alan';&#125; ①，弹出bily。②，弹出alan。 检测类型12345678910111213141516171819typeof：var s = "Nicholas";var b = true;var i = 22;var u;var n = null;var o = new Object();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //Booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof o); //objectinstanceof： 检测对象的具体类型alert(&#123;&#125; instanceof Object); //所有对象，都返回turealert([] instanceof Array); alert(/^.$/ instanceof RegExp); 执行环境与作用域 每个函数都有自己的执行环境和作用域，但js没有块级作用域。例如if和for等语句。但是也有例外，例如catch和with语句。 查询标识符在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。从作用域链的前段开始，向上逐级查询。局部找到，则搜索停止。否则一直向上追溯到全局环境的变量对象，如果都没有找到，则意味着该变量未声明。 垃圾回收 引用类型Object类型Array类型创建12345var colors = ["red", "blue", "green"];colors[colors.length] = "black"; //结尾添加colors[99] = "black";alert(colors.length); //100alert(colors[50]); //undefined 检测arr instanceof Array //true/false 假定单一的全局执行环境，如果网页包含多个框架，则可能出现问题。为了解决这个问题，ECMAScrit新增了能检测iframes的方法 Array.isArray(arr) //true/false IE9+ 转换方法12345var colors = ["red", "blue", "green"]; alert(colors.toString()); //red,blue,greenalert(colors.valueOf()); //red,blue,greenalert(colors); //red,blue,green。自动执行toString()方法alert(colors.join("||")); //red||green||blue。改变分隔符。 栈方法：LIFO123456var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); var item = colors.pop(); //弹出末端最后的元素 alert(item); //"black"alert(colors.length); //2 队列方法：FIFO1234567891011121314var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); alert(count); //3var item = colors.shift(); //移除头部第一个元素alert(item); //"red"alert(colors.length); //2//反向的队列：var colors = []; var count = colors.unshift("red", "green"); // 0,1 count = colors.unshift("black"); //从头部插入，成为第一个元素，索引为0var item = colors.pop(); alert(item); //"green" 排序方法1234var values = [0, 1, 5, 10, 15];values.sort(); //正向 0,1,10,15,5 //sort方法默认会调用每项的toString()转型方法，然后比较得到的字符串。values.reverse(); //反向 自定义排序1234567function compare(value1, value2) &#123; return value2-value1;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);values.reverse(compare); 操作方法：增，减，替换 concat 返回新构建的数组副本 1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]); alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice 返回当前数组截取的副本 12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice 删除，插入，替换数组元素。返回删除项组成的数组，直接影响原数组 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); alert(colors); //green,bluealert(removed); //red (数组)removed = colors.splice(1, 0, "yellow", "orange"); alert(colors); //green,yellow,orange,bluealert(removed); //空数组removed = colors.splice(1, 1, "red", "purple"); alert(colors); //green,red,purple,orange,bluealert(removed); //yellow(数组) 数组的迭代方法 every()，对每一项运行给定函数，如果该函数对每一项都返回ture，则返回ture some()，对每一项运行给定函数，如果该函数对任一项返回ture，则返回ture filter()，对每一项运行给定函数，返回该函数会返回ture的项组成的数组 map()，对每一项运行给定函数，返回每次函数调用的结果组成的数组 forEach()，对每一项运行给定函数。无返回值。 1234567891011121314151617181920var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(someResult); //truevar filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3]var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 缩小方法接受4个参数，前一个值，当前值，当前索引，数组对象。函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight从反方向执行。 Date类型创建1234567var now = new Date() //新创的对象自动获得当前日期时间。var someDate = new Date(Date.parse("May 25, 2004"));var someDate = new Date("May 25,2004"); //默认调用Date.parse()var y2k = new Date(Date.UTC(2000, 0));var y2k = new Date(2000, 0);var allFives = new Date(2005, 4, 5, 17, 55, 55); 格式化 RegExp类型正则表达式模式 12var pattern=/[bc]at/i;var pattern=new RegExp("[bc]at","i"); 实例属性 exec()12345678910var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text); //返回包含第一个匹配项信息和额外信息的数组。alert(matches.index); //0alert(matches.input); //"mom and dad and baby"alert(matches[0]); //"mom and dad and baby"alert(matches[1]); //" and dad and baby"alert(matches[2]); //" and baby" [0]，与整个模式匹配的字符串[1][2]，与模式中的捕获组（？）匹配的字符串。没有捕获组则不存在。模式g，不设置则多次调用exec()将始终返回第一个匹配项的信息。设置则每次调用exec()都会在字符串中继续查找剩余的新匹配项。 构造函数属性123456789101112var text = "this has been a short summer";var pattern = /(.)hort/g;if (pattern.test(text))&#123; //可换成exec()，不反回ture/false。返回一个数组 alert(RegExp.input); //this has been a short summer alert(RegExp.leftContext); //this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); //short alert(RegExp.lastParen); //s alert(RegExp.multiline); //false 。IE，Chrome等不支持 alert(RegExp.$1); //$1~$9，自动存储匹配的捕获组，exec()和test()方法时自动填充。&#125; Function类型定义“函数是对象，函数名是指针”每个函数都是Function类型的实例，具有属性和方法。函数名不与某个函数绑定，只是一个指向函数对象的指针。 function sum(){…} 等于 var sum=function(){…}所以JS没有重载，声明同一个函数两次，函数名指向最后赋值的函数对象。 函数声明与函数表达式12345678910111213①alert(sum(10,10)); //20function sum(num1, num2)&#123; return num1 + num2;&#125; //不会报错。解析器会进行函数声明提升的过程，率先读取函数声明，并使其在执行任何代码之前可访问。②alert(sum(10,10)); var sum = function(num1, num2)&#123; return num1 + num2;&#125;; //报错，解析器进行到表达式时，sum才被保存对函数的引用。 作为值的函数12345678910111213141516171819202122function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var data = [&#123;name: "Zachary", age: 28&#125;, &#123;name: "Nicholas", age: 29&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //Nicholasdata.sort(createComparisonFunction("age"));alert(data[0].name); //Zachary 函数内部属性arguments.callee，指向拥有arguments对象的函数12345678910111213function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) ; //如果return num*factorial(num-1);，则代码和函数名紧耦合 &#125;&#125;var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;;alert(trueFactorial(5)); //120。代码执行不因函数名的指向而改变。 this，引用的是函数所在的执行环境。全局作用域中调用函数时，this引用的是window12345678window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redo.sayColor = sayColor;o.sayColor(); //blue caller，保存着调用当前函数的函数的引用，全局作用域中调用当前函数，它为null1234567function outer()&#123; inner();&#125; function inner()&#123; alert(arguments.callee.caller); //或inner.caller&#125;outer(); 函数属性和方法length，函数定义的命名参数的个数。function sum(num1,mum2){…} //length为2 apply()和call()，每个函数都包含两个非继承而来的方法，用途都是在特性的作用域中调用函数，可以设置函数体内this对象的值。apply(obj,[ … ])接收数组参数，call(obj,arg1,arg2…)接收连续参数 bind()创建一个函数的实例，this值绑定到传递给bind()函数的参数值。 12345678910function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); //this为window对象。arguments对象 //或者 sum.apply(this, [num1, num2]) //或者 sum.call(this,num1,num2)&#125;alert(callSum1(10,10)); //20 扩充函数赖以运行的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //bluevar objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型12var s1 = "text"; //string 是基本类型var s2 = s1.substring(2); //基本类型并不具有此方法 每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。相当于下面的过程 12345678s1 = new String('text');var s2 = s1.substring(2);s1 = null; //即刻销毁var o = new Object('text');alert(o instanceof Object); //truealert(o instanceof String); //turealert(typeof o); //object Boolean类型123456789var falseObject = new Boolean(false);var falseValue = false;var result = falseObject &amp;&amp; true;alert(result); //truealert(typeof falseObject); //objectalert(typeof falseValue); //booleanalert(falseObject instanceof Boolean); //truealert(falseValue instanceof Boolean); //false Number类型1234567891011121314151617var numberObject = new Number(10);var numberValue = 99;alert(numberObject.toString(2)); //"1010"alert(numberObject.toString(16)); //"a"alert(numberObject.toFixed(2)); //outputs "10.00"alert(numberObject.toExponential(2)); // 1.00e+1numberObject = new Number(99);alert(numberObject.toPrecision(1)); //"1e+2"alert(numberObject.toPrecision(2)); //"99"alert(numberObject.toPrecision(3)); //"99.0" alert(typeof numberObject); //objectalert(typeof numberValue); //numberalert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false String类型1234567var stringObject = new String("hello world");var stringValue = "hello world";alert(typeof stringObject); //"object"alert(typeof stringValue); //"string"alert(stringObject instanceof String); //truealert(stringValue instanceof String); //false 字符方法x.charAt()，x.charCodeAt() //字符编码，x[n]。 字符串操作方法concat()接受任意个参数，拼接返回新字符串1234567891011121314var stringValue = "hello world";alert(stringValue.slice(3)); //"lo world" 总长度作为结束位置alert(stringValue.slice(3, 7)); //"lo w"alert(stringValue.substring(3)); //"lo world"alert(stringValue.substring(3,7)); //"lo w"alert(stringValue.substr(3)); //"lo world"alert(stringValue.substr(3, 7)); //"lo worl" 第二个参数指定长度alert(stringValue.slice(-3)); //"rld" 将负的参数与总长度相加alert(stringValue.slice(3, -4)); //"lo w" alert(stringValue.substring(-3)); //"hello world" 将所有负参数转为0alert(stringValue.substring(3, -4)); //"hel" (3,0)=&gt;(0,3 )alert(stringValue.substr(-3)); //"rld" 将第一个负的参数与总长度相加alert(stringValue.substr(3, -4)); //"" 将第二个负的参数转为0 字符串位置方法12345var stringValue = "hello world";alert(stringValue.indexOf("o")); //4alert(stringValue.lastIndexOf("o")); //7alert(stringValue.indexOf("o", 6)); //7。从第二个参数往后搜索alert(stringValue.lastIndexOf("o", 6)); //4。从第二个参数往前搜索 trim()返回去除字符串两端空格的副本。 大小写转换12alert(stringValue.toUpperCase()); //"HELLO WORLD"alert(stringValue.toLowerCase()); //"hello world" 字符串的模式匹配方法 match()，本质上与调用RegExp的exec()方法相同。唯一参数，正则表达式。 1234567var text = "cat, bat, sat, fat"; var pattern = /.at/;var matches = text.match(pattern); alert(matches.index); //0alert(matches[0]); //"cat"alert(pattern.lastIndex); //0 search()，由开头向后查找，返回字符串中第一个匹配项的索引，如果没找到，返回-1。唯一参数，正则表达式。 var pos = text.search(/at/); //1 replace()，第一个参数，正则表达式或字符串，第二个参数字符串或者一个函数。 第一个参数为字符串，只替换第一个匹配项 12var result = text.replace("at", "ond");alert(result); //"cond, bat, sat, fat" 全局替换，使用正则表达式 12result = text.replace(/at/g, "ond");alert(result); //"cond, bond, sond, fond" 第二个参数为字符串，还可以使用一些特殊的字符序列 12result = text.replace(/(.at)/g, "word ($1)");alert(result); //word (cat), word (bat), word (sat), word (fat) $n，匹配的第n个捕获组 第二个参数，为函数。 split()第一个参数，分隔符字符串或RegExp。第二个参数，结果数组的大小。1234var colorText = "red,blue,green,yellow";var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]var colors2 = colorText.split(",", 2); //["red", "blue"]var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""] localeCompare()比较两个字符串在字母表中的位置。1234var stringValue = "yellow"; alert(stringValue.localeCompare("brick")); //1alert(stringValue.localeCompare("yellow")); //0alert(stringValue.localeCompare("zoo")); //-1 fromCharCode()接受一或多个字符编码。转换成一个字符串。 alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot; 单体内置类型Global对象URI编码encodeURI()，不会对本属于URI的特殊字符进行编码，如冒号，正斜杠问号和井号。encodeURIComponet()，对任何非标准字符进行编码。1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.htm#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"alert(encodeURIComponent(uri)); URI解码decodeURI()，只对非URI特殊字符解码。decodeURIComponet()，解码所以非标准字符。1234567var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri)); //http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); eval()像是一个完整的ECMAScript解析器，只接受一个参数。传入的参数当做实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码，被认为是包含调用的执行环境的一部分，因此被执行代码具有该执行环境相同的作用域链。但在eval()中创建的任何变量或函数都不会被提升。 eval(&quot;var msg=&apos;hello world&apos;;&quot;); alert(msg); //严格模式中会导致错误 Global对象的属性 window对象Web浏览器都是将Global对象作为window对象的一部分加以实现的。因此全局作用域中声明的所有变量和函数都成为了window对象的属性。 Math对象 min()和max()1234567var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3//想要直接传递数组，可以使用下面的技巧var arr=[3, 54, 32, 16];var max = Math.max.apply(Math,arr); 舍入方法12345alert(Math.ceil(25.1)); //26alert(Math.floor(25.9)); //25alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25 random()123456789function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10); //2-10的整数var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];var color = colors[selectFrom(0, colors.length-1)]; 对象理解对象属性类型ECMAScript中属性分两种：数据属性和访问器属性。“特性”描述了属性的各种特征，只为了实现JS引擎，不能直接访问。 数据属性 123456789var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, //只读属性 value: "Nicholas"&#125;);alert(person.name);person.name = "Michael"; //严格模式下，抛出错误alert(person.name); //Nicholas 一旦把属性定义为不可配置的，就不能再把它便回可配置了。再调用Object.defineProperty()修改除writable之外的特性，都将导致错误。 访问器属性不包含数据值，包含一对getter和setter函数。都不必需，可创建只读，只写属性。 123456789101112131415161718192021var book = &#123; _year: 2004, edition: 1&#125;; Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 定义/修改多个属性12345678910111213141516var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, //其他特性默认为false，undefined edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125; &#125;); 读取属性的特性123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //"undefined"var descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //"function" 创建对象构造函数模式1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; //弊端，每个对象的此属性指向不同方法对象 alert(this.name); &#125;; &#125;var person1 = new Person("Nicholas", 29, "Software Engineer");person1.sayName(); //"Nicholas"alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person1.constructor == Person); //true new 操作符，执行步骤：1，创建1个新对象。2，将构造函数的作用域赋给新对象，this就指向了这个新对象3，执行构造函数中的代码。4，返回新对象 如果直接调用构造函数，则和普通函数一样。 Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); //adds to window window.sayName(); //&quot;Greg&quot;。通过this，赋值给了window对象。 原型模式理解原型对象 每一个函数都有一个prototype属性，是一个指针，指向通过构造函数而创建的那个对象实例的原型对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。通过原型，可以把需要定义在构造函数中的实例信息，转移到原型对象中。 1234567function Person()&#123; &#125; Person.prototype.name = "Nicholas";Person.prototype.sayName = function()&#123; //每个实例的此属性指向同一方法 alert(this.name);&#125;; var person1 = new Person();person1.sayName(); //"Nicholas"。通过查找对象属性得过程来实现查找调用 确定对象间是否存在原型关系 alert(Person.prototype.isPrototypeOf(person1)); //true 取得[[Prototype]]的值 alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(person1.constructor.prototype == Person.prototype); //true 屏蔽原型属性 person1.name = &quot;Greg&quot;; alert(person1.name); //&quot;Greg&quot; 读取实例的属性时，先搜索实例本身，然后搜索原型对象。 删除实例属性，解除屏蔽。 delete person1.name; 检测属性是否存在于实例中 alert(person1.hasOwnProperty(&quot;name&quot;)); 原型与in操作符in操作符会在通过对象能够访问给定属性时返回ture，无论属性存在于实例或原型中 1234567var person1 = new Person(); alert(person1.hasOwnProperty("name")); //falsealert("name" in person1); //truefunction hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; //判断属性是否存在于原型中 使用for-in循环时，返回的是所有能通过对象访问的，可枚举（[[Enumerable]]）的属性。其中既包括实例中的属性和原型中的属性。屏蔽原型中不可枚举属性得实例属性也会在for-in循环中返回。 Object.keys()。接收一个对象，返回一个只包含在此实例中的所有可枚举属性的字符串数组。 12345var keys = Object.keys(Person.prototype);alert(keys); //"name,age,job,sayName"var p=new Person();var keys = Object.keys(p);alert(keys); //"" Object.getOwnPropertyNames()。接收一个对象，返回一个只包含在此实例中的无论是否可枚举的属性的字符串数组。 1234var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor,name,age,job,sayName"var keys = Object.getOwnPropertyNames(p);alert(keys); //"" 更简单的原型语法1234567function Person()&#123; &#125; Person.prototype = &#123; name : "Nicholas", sayName : function () &#123; alert(this.name); &#125;&#125;; 重写了prototype对象。因此constructor属性变成了Object构造函数，不在指向Person函数12345var friend = new Person(); alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //false。实际访问的是原型对象的constructor属性alert(friend.constructor == Object); //true 重设constructor属性 Person.prototype = { constructor: Person, ... }; 缺点：导致constructor属性的枚举特性为ture。改良如下： Object.defineProperty(Person.prototype，&quot;constructor&quot;，{ enumerable：false, value：Person })； 原型的动态性因为实例和原型之间的连接是一个指针，而非一个副本。创建实例后，对原型对象做的任何修改都能立即从实例上反应出来。如果先创建实例，又重写了其原型对象，则切断了新原型对象与实例的关系。实例指向的仍是原来的原型对象。 原生对象的原型123456alert(typeof Array.prototype.sort); //"function"alert(typeof String.prototype.substring); //"function"String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;; //给原生引用类型增加扩展方法（不推荐，容易引起冲突） 组合构造函数模式和原型模式组合两种模式，创建自定义类型。构造函数用于定义实例不同的属性，原型模式用于定义方法和共享的属性。 继承原型链 确定原型和实例之间的关系123456instance instanceof Object; //trueinstance instanceof SuperType; //trueinstance instanceof SubType; //trueObject.prototype.isPrototypeOf(instance); //trueSuperType.prototype.isPrototypeOf(instance); //trueSubType.prototype.isPrototypeOf(instance); //true 原型链的问题12345678910function SuperType()&#123; this.colors = ["red", "blue", "green"];&#125;function SubType()&#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"。所有子类型实例共享一个原型对象var instance2 = new SubType();alert(instance2.colors); //"red,blue,green,black"。所有子类型实例都受影响 组合继承1234567891011121314151617function SuperType(name)&#123; //父类型 私有属性 this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; //父类型 私有方法 alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //子类型 借用父类型构造函数，生成自己的私有属性（与父类型一致） this.age = age; //子类型 私有属性&#125;SubType.prototype = new SuperType(); //父类型实例作为子类型的原型，继承父实例原型的方法和实例属性。父实例的私有属性将被子实例相同的私有属性覆盖，而不再被子实例共享，避免篡改。SubType.prototype.sayAge = function()&#123; //子类型 私有方法 alert(this.age);&#125;;var instance1 = new SubType("Nicholas", 29); //拥有：父类型原型方法，子类型原型方法，子实例私有属性 优点：重用了父类型的方法，避免二次定义与父类型相同的属性缺点：实例了两次相同的属性，子实例覆盖了父实例创建的私有属性 原型式继承123456789101112function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; var person = &#123; //原型（基础）对象 name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = object(person); //传递父类型（非实例）进行浅复制，创建了2个副本，拥有相同的原型对象var yetAnotherPerson = object(person);anotherPerson.prototype.sayHello=function()&#123; ... &#125; //对子类型的扩展，并不影响父类型 ECMAScript 5 规范了原型式继承12345var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = Object.create(person); 寄生组合式继承1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); //创建一个中间层，继承了父类型的原型方法。 prototype.constructor = subType; //增强 subType.prototype = prototype; //子类型的原型引用此中间层，对子类型的扩展应用在此层上，并不影响父类型。&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //借用，避免二次定义相同的属性 this.age = age;&#125;inheritPrototype(SubType, SuperType); //应用中间层，继承父类型原型方法，且并不实例化父类型，避免实例后覆盖带来的浪费 SubType.prototype.sayAge = function()&#123; //扩展子类型 alert(this.age);&#125;; 函数表达式闭包一个函数，有权访问其他函数作用域变量对象的函数。 创建时，创建一个预先包含全局变量对象及外层变量对象的作用域链（根据函数是否引用外层函数的变量来决定是否加入外部函数的变量对象，未引用则外部函数的变量对象销毁），保存在内部的[[ Scope ]]属性中。 调用时，为此函数创建一个执行环境。 复制函数的[[ Scope ]]属性中的对象（指针）构建执行环境的作用域链。 创建次函数的活动对象（在此作为变量对象）并被推入执行环境作用域链的前端。 作用域链本质上是一个指向变量对象的指针列表。 闭包与变量12345678910111213141516function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; //创建，作用域链引用createFunctions的变量对象 return i; &#125;; &#125; //不存在块级作用域，变量i仍然存在，最终的值为10 return result;&#125; //被引用createFunctions的变量对象未销毁var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; document.write(funcs[i]() + "&lt;br /&gt;"); //调用函数，全部都返回createFunctions变量对象中的i变量，10&#125; 关于this对象this对象在运行时基于函数的执行环境绑定的。当函数作为某个对象的方法被调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。1234567891011121314var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function() &#123; ① return this.name; ③ var that=this; ② return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 作为对象的方法调用，this等于此对象。”My Obeject” 匿名函数，此时this表示window。”The Window” 。（内部函数搜索this和arguments变量时，只会搜索到其活动对象位置，不可能直接访问到外部函数中的这连个变量。） 把外部作用域中的this对象保存在一个闭包能够访问 到的变量，就可以让闭包访问此对象了。 特殊情况，123alert(object.getName()); //"My Object"alert((object.getName)()); //"My Object"alert((object.getName = object.getName)()); //"The Window" 非严格模式 第三行的赋值表达式等于函数本身，this没有得到保持，等于window对象。 闭包导致的内存泄漏IE9之前的版本对JS对象和COM对象使用不同的垃圾收集例程。BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。 123456function assign() &#123; var ele=document.getElementById('id'); ele.onclick=function()&#123; alert(ele.id); &#125;&#125; 循环引用，导致内存泄漏解决方案12345678function assign()&#123; var ele=document.getElementById('Id'); var id=ele.id; ele.onclick=function()&#123; alert(id); &#125; ele=null;&#125; 模仿块级作用域JS没有块级作用域的概念，在for或if中定义的变量，实际上是在包含函数中而非语句中创建的。 12345678function outputNumbers(count)&#123; (function () &#123; //内部为块级作用域 for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //出错&#125; 私有变量1234567891011function Person()&#123; //私有变量 var name; //特权方法 this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125; 静态私有变量1234567891011121314151617(function()&#123; var name = ""; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person("Nicholas"); var person2 = new Person("Michael");alert(person1.getName()); //"Michael"alert(person2.getName()); //"Michael" 模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); //初始化 return &#123; //匿名对象 getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125; &#125;;&#125;(); 增强模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); var app = new BaseComponent(); //属于某种类型 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125;; return app;&#125;(); BOMwindow对象全局作用域window对象扮演着Global对象的角色。定义在全局作用域中的变量都会成为window对象的属性区别： 123456var age = 29; //[[Configurable]]特性为falsewindow.color = "red";delete window.age; //false &lt;IE 9报错delete window.color; //true alert(window.age); //29alert(window.color); //undefined 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中（通过从0开始的数值索引或者框架名称来访问对应的window对象）。 top.frames[0] //top始终指向最高层的框架，也就是浏览器窗口 parent对象 //当前对象直接上层框架，如果没有框架的话。parent=top=window 窗口位置浏览器在屏幕左边和上边的位置。12var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY; 窗口大小页面大小，不包括工具栏等浏览器本身。123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS1Compat")&#123; //是否是标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 间歇调用和超时调用JS是单线程语言，一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JS任务队列，这些任务会按照它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行。否则它就要等前面的代码执行完了之后再执行。 系统对话框window.print() //调用打印窗口 window.find(&apos;xx&apos;) //查找页面是否包含&apos;字符串&apos;，返回ture/false location对象位置操作1234567location.hash = "sec1"; // http://..../#sec1 不刷新页面，跳转到页内锚记location.search = "q=22"; // http://..../?q=22#sec1 location.hostname = "www.yahoo.com"; // http://www.yahoo.com/?q=22#sec1 location.pathname = "mydir"; // http://..../mydir/t1/dd/?q=22#sec1location.port = 8080; // http://...:8080/mydir/t1/dd/?q=22#sec1location.replace("http://www.wrox.com/"); //不会产生历史记录，不能回到前一个页面location.reload([true]); //true，忽略浏览器缓存，强制从服务器重新加载 navigator对象浏览器及客户端系统相关信息 screen对象表示客户端的能力，包括浏览器窗口外部的显示器信息，如像素宽度和高度等。 history对象因history也是window对象的属性，因此每个浏览器窗口，每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 12345history.go(-1)history.go(1)history.go("www.baidu.com") //跳转到最近的baidu页面，可能前进，也可能倒退history.back()history.forward() DOM节点层次Node类型每个节点都有一个childNodes属性，保存着NodeList对象。NodeList是一种类数组对象，动态实时更新，使用时最好先缓存起来，可以通过索引[i]或者item(i)访问，也有length属性，但并不是Array的实例。可以通过 var arr=Array.protptype.slice.call(some.childNodes，0); 来进行转换成数组。 Node之间的关系 操作节点1234567var retNode=someNode.appendChild(someNode.firstChild)； //成为第二个节点var retNode=someNode.insertBefore(newNode,null); //插入为最后一个节点var retNode=someNode.insertBefore(newNode,someNode.firstChild); //插入成为第一个节点var retNode=someNode.replaceChild(newNode,someNode,firstChild); //替换第一个节点。该节点的所有关系指针都会被替换。var retNode=someNode.removeChild(someNode.firstChild); //移除第一个子节点var deepList=myList.cloneNode(true); //复制节点及整个子节点数var shallowList=myList.cloneNode(false); //只复制节点本身 Document类型包括HTML元素，HTML声明等。12345var html=document.documentElement; //HTML元素html==document.childNodes[0]; //truehtml==document.firstChild; //truevar body=document.body; //body的引用var doctype=document.doctype; //&lt;!DOCTYPE&gt;的引用 在jQuery的$(function(){ … });页面加载事件里，this对象引用的即为Document对象。且直接通过var 声明的变量不会成为Document对象的属性(与全局作用域不同，如全局声明var变量，此变量即成为window对象的属性)。 文档信息1234567document.title='new title';var url=document.url;var domain=document.domain;var referrer=document.referrer;images.nemedItem('name'); 或iamges["name"] //取得HTMLCollection对象中name为'name'的元素 特殊集合1234document.anchores，带name的a元素document.links，带href的a元素document.forms，所有form元素document.images，所有img元素 一致性检测document.implementation对象，DOM1级只为此对象规定了一个方法，hasFeature()。传入两个参数，要检测的DOM功能名称和版本号。 var hasXmlDom=document.implementation.hasFeature(&apos;XML&apos;,&apos;1.0&apos;); Element类型特征1234nodeType //1nodeName/tagName //标签名nodeValue //nullparentNode HTML元素HTMLElement，所有HTML元素都是HTMLELment活它的子类型表示。继承了Element的属性，新增了部分属性：id，title，lang，dir(语言方向,类似text-align)，className(所有class)。 操作特性1234var div=document.getElementById('my');div.getAttribute('id');div.setAttribute('class','123');div.removeAttribute('name'); 直接通过属性名访问和getAttribute()方法得到的结果不一样的两种特性：style，get得到的CSS文本，属性访问得到对象，用于访问元素样式。事件，onclick等，get访问代码文本，属性访问得到function对象。 attributes属性包含一个NamedNodeMap“动态”集合，拥有下列方法：1234getNamedItem(name) //返回指定nodeName(tagName)的节点removedNamedItem(name) //从列表移除指定nodeNamesetNamedItem(node) //向列表添加节点item(id) //返回位于数字id处的节点 取值 ele.attributes[&apos;age&apos;].nodeValue 创建元素1234var div = document.createElement("div");div.id = "myNewDiv";div.className = "box";document.body.appendChild(div); 动态创建的元素特点：不能通过表单reset，与已有同name单选框无关系。 元素的子节点ele.childNodes 除了IE，其他浏览器会把各子元素之间的回车等空白也计算为一个节点。所以需要遍历子元素时，需要判断元素类型。123if(chiEle.nodeType==1)&#123; //do some&#125; Text类型特征123456nodeType //3nodeName //#textnodeValue //节点文本parentNode //Element没有子节点length属性 方法123appendData(txt)，deleteData(offset,count)，insertData(offset,count,text)，replaceData(offset,count,text)，splitText(offset)，substringData(offset,count) 创建document.createTextNode(&apos;&lt;strong&gt;Hello&lt;/strong&gt;&apos;); Comment类型特征12345nodeType //8nodeName //'#comment'nodeValue //注释的内容parentNode //Document或Element无子节点 CDATASection类型特征123456只针对XML文档，CDATA区域。与Comment类似，继承自Text类型nodeType //4nodeName //#cdata-sectionnodeValue //CDATA区域的内容parentNode //Document或Element无子节点 DocumentType类型很少有浏览器支持。表示文档类型，对应&lt;!DOCTYPE&gt;等。 Attr类型元素的特性 DOM操作技术动态脚本页面加载时不存在，将来通过修改DOM动态添加的脚本。 外部引用 1234567function addScript()&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.text = "function sayHi()&#123;alert('hi');&#125;"; document.body.appendChild(script); sayHi();&#125; 行内方式 12345678910function loadScriptString(code)&#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; //IE特定，不支持对Script添加子节点 &#125; document.body.appendChild(script);&#125; 动态样式 外部引用 1234567function addStyle()&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;)); //error in IE var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 嵌入方式 1234567891011function loadStyleString(css)&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex)&#123; style.styleSheet.cssText = css; //IE &#125; var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 选择符API使用CSS选择符查询匹配的DOM元素。 querySelector()接受一个CSS选择符，返回与该模式匹配的第一个元素，没找到则返回null。 1234var body = document.querySelector("body");var myDiv = document.querySelector("#myDiv");var selected = document.querySelector(".selected");var img = document.body.querySelector("img.button"); querySelectorAll()返回所有匹配的元素，一个NodeList实例（此方法返回的实际上是一组元素的快照，避免不断动态查询带来的性能影响）。没有匹配则返回一个空的NodeList。1234var ems = document.getElementById("myDiv").querySelectorAll("em");var selecteds = document.querySelectorAll(".selected");var strongs = document.querySelectorAll("p strong");var s1=strongs[0]; matchesSelector()如果调用元素与该选择符匹配，返回ture，否则返回false。123if (matchesSelector(document.body, "body.page1"))&#123; alert("It's page 1!");&#125; 支持不完善，需要做跨浏览器兼容。12345678910111213function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error("Not supported."); &#125;&#125; 元素遍历对于元素见得空格，IE9及之前版本不会返回文本节点，其他浏览器都会返回文本节点。子节点查询的元素版：childElementCount属性，子元素（不含文本和注释节点啊）个数。firstElementChild，lastElementChild，previousElementSibling，nextElementSiblingchildren属性，HTMLCollection实例，只包含元素子节点。childNodes的元素版。 跨浏览器兼容123456789101112if (document.body.firstElementChild)&#123; var i, len, child = document.body.firstElementChild; while(child != document.body.lastElementChild)&#123; document.write("&lt;p&gt;" + child.tagName + "&lt;/p&gt;"); child = child.nextElementSibling; &#125;&#125; else &#123; document.write("&lt;p&gt;Element Traversal API not supported.&lt;/p&gt;");&#125; HTML5document.head，head部分引用document.charset，字符集 类的扩充getElementsByClassName() 所有元素都可调用12345classList //DOMTokenListadd(value) //添加或忽略contains(value) //是否包含remove(value) //删除toggle(value) 滚动scrollIntoView() 任何元素可调用，出现在视口中。传入true或不传，顶部与视口对齐。传入false，底部对齐。 DOM2和DOM3变化Node类型localName，不带命名空间前缀的节点名称namespaceURI，不带命名空间前缀的节点名称prefix，命名空间或者null Document类型新增了带NS后缀的方法，表示特定命名空间下的操作，比如：createElementNS(ns,tagName)：创建属于ns命名空间的元素createAttributeNS(ns,attr)：使用给定attr创建一个ns命名空间的新特性getElementsByTagNameNS(ns,tagName)：返回特定命名空间的元素NodeList 元素大小偏移量 某个元素在页面上的偏移量计算：12345678910function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 客户区大小 元素内部空间大小，因此滚动条占用的空间不计算。确定浏览器视口大小： document.documentElement.clientWidth //document.body代表body，document.documentElement //代表html标签 滚动大小scrollHeight，没有滚动条的情况下，元素总高度scrollWidth，同上，元素内容总宽度scrollLeft，被隐藏在内容区域左侧的像素数。设置可以改变元素滚动位置scrollTop，上方的元素，设置可以改变元素滚动位置(需要设置overflow属性才能滚动) 确定文档的总高度时，必须获得scrollHeight/clientHeight中的最大值，才能跨浏览器得到准确的结果。 Math.max(ducment.documentElement.scrollHeight,document,documentElement.clientHeight) 遍历TreeWalker12345678910111213141516function makeList() &#123; var div = document.getElementById("div1"); var filter = function(node)&#123; return (node.tagName.toLowerCase() == "li") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;; var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false); var output = document.getElementById("text1"); var node = walker.nextNode(); while (node !== null) &#123; output.value += node.tagName + "\n"; node = walker.nextNode(); &#125;&#125; NodeFilter.FILTER_SKIP，跳过节点前进道子树种的下一个节点NodeFilter.FILTER_REJECT，跳过节点及该节点整个子树。walker可以眼任何方向移动 walker.firstChild(); walker.nextSibling(); walker.currentNode，当前节点。 范围 事件事件流 事件处理程序需DOM0级事件处理程序1234bar btn=document.getElementById('my');btn.onclick=fuction()&#123; alert(this.id);&#125;; DOM0级方法指定的事件处理程序被认为是元素的方法，在元素的作用域中运行，this引用当前元素。 DOM2级事件处理程序1234var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); false，冒泡阶段调用，true，捕获阶段调用。作用域同DOM0级方法一样。好处是，可以添加多个事件处理程序，且按添加顺序执行。 通过此方法添加的事件只能使用removeEventListener()移除，传入的参数与添加时使用的参数相同(同一个函数对象)，所以通过addEventListener()添加的匿名函数将无法移除。 事件对象所有事件都会有的成员 12345document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById("myBtn")); //true&#125;; 事件类型 UI事件 在window上发生的任何事件都可以在body元素上通过相应的特性来指定，因为HTML无法访问window元素，为了向后兼容例：window的load事件， unload事件兼容性很不好，chrome不会显示文本，IE显示乱码12345EventUtil.addHandler(window, "beforeunload", function(event) &#123; var msg = "will you leave？"; event.returnValue = msg; return msg;&#125;); scroll事件document.body.scrollTop获取滚动高度。火狐使用document.documentElement.scrollTop。 焦点事件 鼠标与滚轮事件 客户区(可视)坐标 event.clientX和event.clientY 页面坐标 event.pageX，event.pageY 屏幕坐标 event.screenX，event.screenY 修改键 e.shiftKey，e.ctrlKey，e.altKey，e.metaKey。布尔值，代表是否按下了相应按键，支持同时按。 关联元素 e.relatedTarget，只对mouseover和mouseout事件才包含值，代表与target发生关系的元素。 鼠标按钮 e.button，按下或释放的按钮。0，主按钮，1，滚轮，2，次按钮。 滚轮事件 mousewheel，任何元素上出发，最终会冒泡到document或window对象。event对象包含一个特殊的wheelDelta属性，向前滚动wheelDelta是120的倍数，向后滚动wheelDelta是-120的倍数。 触摸设备 键盘与文本事件keydown，按下键盘上任意键时触发，按住不放会重复触发。keypress，按下奸商上字符键时触发，按住不放会重复触发。keyup，释放键盘上的键时触发keydown-&gt;keypress-&gt;keyup。支持4个修改键。键码，event.keyCode，表示触发keydown或keyup事件特定的键，如回车-13，空格-32。字符编码，event.key，事件产生的相应文本字符或键名。 文本事件textInput。按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发。event.data，实际输入的字符文本。event.inputMethod，代表文本是如何输入到控件中的，从而验证有效性（只有IE支持）。 HTML5事件contextmenu事件windows中，右键单击。Mac，Ctrl+单击。冒泡，可以为document指定一个事件处理程序自定义右键菜单。 12345678910document.oncontextmenu=function(event)&#123; event.preventDefault() var menu = document.getElementById("myMenu"); menu.style.left = event.clientX + "px"; menu.style.top = event.clientY + "px"; menu.style.visibility = "visible";&#125;;document.addEventListener('click',function()&#123; document.getElementById("myMenu").style.visibility = "hidden"; //隐藏右键菜单&#125;); beforeUnload事件必须添加给window对象。firefox和opera不支持。chrome不显示message。123456EventUtil.addHandler(window, "beforeunload", function(event)&#123; event = EventUtil.getEvent(event); var message = "I'm really going to miss you if you go."; event.returnValue = message; return message;&#125;); DOMContentLoaded事件DOM树加载完毕之后触发，不理会图片，js，css等。 pageShow，pageHide事件必须添加给window对象。pageShow在load后触发，pageHide在unload之前触发。兼容性不好。 hashchange事件必须添加给window对象。url发生变化时触发，包含oldURL和newURL两个属性。 设备事件只在移动设备上实现。 orientationchange事件横向纵向查看模式。只有Safari支持 deviceorientation事件123456EventUtil.addHandler(window, "deviceorientation", function(event)&#123; var output = document.getElementById("output"); var arrow = document.getElementById("arrow"); arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)"; output.innerHTML = "Alpha=" + event.alpha + ", Beta=" + event.beta + ", Gamma=" + event.gamma + "&lt;br&gt;";&#125;); devicemotion事件12345678EventUtil.addHandler(window, "devicemotion", function(event)&#123; var output = document.getElementById("output"); if (event.rotationRate !== null)&#123; output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" + event.rotationRate.beta + ", Gamma=" + event.rotationRate.gamma; &#125;&#125;); 触摸和手势事件触摸事件都会冒泡。 Touch对象包含：identifier，唯一ID，clientX/Y，pageX/Y，screenX/Y，target，触摸的DOM节点。 12345678910111213141516171819202122function handleTouchEvent(event)&#123; //只触发一次 if (event.touches.length == 1)&#123; var output = document.getElementById("output"); switch(event.type)&#123; case "touchstart": output.innerHTML = "Touch started (" + event.touches[0].clientX + "," + event.touches[0].clientY + ")"; break; case "touchend": output.innerHTML += "&lt;br&gt;Touch ended (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; case "touchmove": event.preventDefault(); //阻止滚动 output.innerHTML += "&lt;br&gt;Touch moved (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; &#125; &#125;&#125;document.addEventListener("touchstart", handleTouchEvent, false);document.addEventListener("touchend", handleTouchEvent, false);document.addEventListener("touchmove", handleTouchEvent, false); 模拟事件模拟鼠标事件1234var event = document.createEvent("MouseEvents");event.initMouseEvent("click", true, true, document.defaultView, 0, 100, 0, 0, 0, false, false, false, false, 0, btn2);btn.dispatchEvent(event); 模拟键盘事件1234567891011121314151617181920212223242526EventUtil.addHandler(btn, "click", function(event)&#123; var event; //DOM Level 3 if (document.implementation.hasFeature("KeyboardEvent", "3.0"))&#123; event = document.createEvent("KeyboardEvent"); event.initKeyboardEvent("keydown", true, true, "a", 0, "Shift"); &#125; else &#123; try &#123; //Firefox event = document.createEvent("KeyEvents"); event.initKeyEvent("keydown", true, true, document.defaultView, false, false, true, false, 65, 65); &#125; catch (ex)&#123; //others event = document.createEvent("Events"); event.initEvent("keydown", true, true); event.view = document.defaultView; event.altKey = false; event.ctrlKey = false; event.shiftKey = false; event.metaKey = false; event.keyCode = 65; event.charCode = 65; &#125; &#125; textbox.dispatchEvent(event);&#125;); 表单脚本选择框脚本：HTMLOptionElement对象，属性有：index，label，selected，text，value。 取得选择的option，select.options[select.selectedIndex];选择，select.option[0].selected = true; 对其他option无影响。select.selectedIndex = 0，影响多选框其他option。 JSONJSON序列化：1234567891011121314151617181920var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == "releaseDate")&#123; return undefined; &#125; else &#123; return value; &#125;&#125;);var jsonText = JSON.stringify(book, ["title", "edition"], 4); //只序列化字段，格式化缩进个数var jsonText = JSON.stringify(book, null, "--"); //缩进占位符var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON: function()&#123; return this.title; &#125; &#125;; AjaxXHR默认头部信息 发送请求通过setRequestHeader()设置自定义头部，jQuery方式：12345678910$.ajax(&#123; type: "GET", url: "...", beforeSend: function(request) &#123; request.setRequestHeader("Test", "content"); &#125;, success: function(result) &#123; alert(result); &#125;&#125;); XHR2级FormData1234567891011121314151617181920212223242526272829var data = new FormData();data.append("file" , files[i]);var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(event)&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "FileAPIExample06Upload.php", true);xhr.send(data);var formData = new FormData();var upload = document.getElementById('file');if (upload.files.length &gt; 0) &#123; formData.append('upload', upload.files[0]); $.ajax(&#123; url: '/Customers/Import', method: 'POST', data: formData, contentType: false, processData: false, cache: false, success: function (data) &#123;&#125; &#125;);&#125; 进度事件123456789var xhr = createXHR();xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize + " bytes"; &#125;&#125;;xhr.open("get", "altevents.php", true); xhr.send(null); 跨域XHR对象，默认只能访问与它同一个域中的资源。CORS：发送请求时，需要添加一个额外的Origin头部，Origin：http://www.xxx.com。服务器如果任何请求，就在Access-Control-Allow-Origin头部中挥发相同的源（如果不需要跨域保护，可会回发 *），例如Access-Control-Allow-Origin：http://www.xxx.com大部分浏览器默认实现CORS的原声支持，访问时，使用绝对URL即可。但跨域XHR对象也有一些限制：不能自定义头部，不能发送和接受cookie，获取自定义头部总会返回空 其他跨域技术图像Ping，JSONP，Comet，Web sockets。 WebSockets在一个单独的持久链接上提供全双工、双向通信。第一次取得服务器响应后，建立的链接会从HTTP协议升级成Web Socket协议（需要服务器支持）。 Web Sockets协议：’ws://‘和’wss://‘（加密）。1234567891011121314151617var socket = new WebSocket('ws://www.xxx.com/handler'); // 不受同源策略影响，可以跨域// readState 属性：WebSocket.CONNECTING(0) / OPEN(1) / CLOSING(3) / CLOSED(2)socket.send('xxx'); //只能发送纯文本，发送复杂数据结构，需要先序列化socket.onmessage = function(event)&#123; // 获取服务器消息 var data=event.data; &#125;socket.close() //关闭链接 ，状态由2到3WebSocket事件：不支持DOM2级事件侦听器，必须使用DOM0级语法定义事件。socket.onopen = function()&#123;&#125;;socket.onerror = function()&#123;&#125;;socket.onclose = function(e)&#123; // e.wasClean 是否明确关闭 // e.code 服务器返回码 // e.reason 服务器发回的消息&#125;; 高级技巧高级函数安全的类型检测检测是否为数组/函数/正则表达式： Object.prototype.toString.call(obj) == &apos;[object Array]&apos;/&apos;[object Function]&apos;/&apos;[object RegExp]&apos;; 作用域安全的构造函数假设一个构造函数没有搭配new 关键词而调用，那么this默认绑定到window对象，则可能导致意外的错误。123456789function Person(name, age, job)&#123; if (this instanceof Person)&#123; //判断是否为指定类型的对象，再进行操作 this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125; 函数绑定绑定后返回一个函数，无论再对此函数调用什么apply或call改变this的引用，都不会改变执行结果handleClick.bind(obj)。123456function bind(context)&#123; var fn=this; return function()&#123; return fn.apply(context, arguments); &#125;;&#125; 柯里化使用闭包创建一个已经设置了部分参数的函数。123456789101112131415function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments), finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125;function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); //8 bind的柯里化实现123456789var handler = &#123; message: "Event handled", handleClick: function(name, event)&#123; alert(this.message + ":" + name + ":" + event.type); &#125;&#125;;var btn = document.getElementById("my-btn");EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler, "my-btn")); //第一个参数是绑定的this，第二个参数开始是预设置的参数。 防篡改对象不可扩展1234var person = &#123; name: "Nicholas" &#125;;Object.preventExtensions(person);alert(Object.isExtensible(person)); //falseperson.age = 29; 静默失败undefined，严格模式抛出异常 密封不可扩展，[[Configurable]]特性被设置为false，不能删除属性和方法。但是属性值是可以修改的。1234567var person = &#123; name: "Nicholas" &#125;;Object.seal(person);alert(Object.isSealed(person)); //trueperson.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas" 冻结最严格。及不可扩展，又是密封的，对象的[[Writable]]特性被设置为false，如果定义了[[Set]]，则访问器属性仍是可写的。1234567891011var person = &#123; name: "Nicholas" &#125;;Object.freeze(person);person.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas"person.name = "Greg";alert(person.name); //"Nicholas"alert(Object.isExtensible(person)); //falsealert(Object.isSealed(person)); //truealert(Object.isFrozen(person)); //true 分隔执行过程当执行数据量过大，为避免造成JS线程一直在进行中，导致UI线程被卡住。推荐对数据分割处理123456789101112131415161718var data = [12,123,1234,453,436,23,23,5,4123,45,346,5634,2234,345,342];function chunk(array, process, context)&#123; // context可选的 setTimeout(function()&#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0)&#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100); // 100毫秒 给线程一个协调的时间&#125;function printValue(item)&#123; var div = document.getElementById("myDiv"); div.innerHTML += item + "&lt;br&gt;"; &#125;chunk(data.concat(), printValue); // 不想改变原数组的数据，可以使用concat或slice创建一个副本 函数节流一些会被反复执行的事件，如果频率太高容易导致浏览器挂起或崩溃。需要对该函数进行节流适用于resize事件或over事件等。123456789101112131415function throttle(method, scope) &#123; // 可选的scope return function() &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(scope); &#125;, 100); &#125;&#125;function resizeDiv() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;window.onresize = throttle(resizeDiv); 自定义拖动功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function DrapDrop() &#123; var drag var dragging = null; var diffLeft, diffTop, diffRight, diffBottom; var count = 0; function handlerEvent(event) &#123; var target = event.target; switch (event.type) &#123; case 'mousedown': if ($(target).hasClass('draggable')) &#123; dragging = target; diffLeft = event.clientX - target.offsetLeft; diffTop = event.clientY - target.offsetTop; diffRight = target.clientWidth - diffLeft; diffBottom = target.clientHeight - diffTop; console.log(event.clientX, target.offsetLeft) &#125; break; case 'mousemove': if (dragging != null) &#123; var parentWidth = target.offsetParent.clientWidth; var parentHeight = target.offsetParent.clientHeight; var left, top; if (event.clientX - diffLeft &lt;= 0 || event.clientX + diffRight &gt;= parentWidth) &#123; if (event.clientX - diffLeft &lt;= 0) left = 0; if (event.clientX + diffRight &gt;= parentWidth) left = parentWidth - target.clientWidth; &#125; else &#123; left = event.clientX - diffLeft; &#125; if (event.clientY - diffTop &lt;= 0 || event.clientY + diffBottom &gt;= parentHeight) &#123; if (event.clientY - diffTop &lt;= 0) top = 0; if (event.clientY + diffBottom &gt;= parentHeight) top = parentHeight - target.clientHeight; &#125; else &#123; top = event.clientY - diffTop; &#125; dragging.style.left = left + 'px'; dragging.style.top = top + 'px'; &#125; break; case 'mouseup': dragging = null; break; &#125; &#125; return &#123; enable: function() &#123; document.addEventListener('mousedown', handlerEvent) document.addEventListener('mousemove', handlerEvent) document.addEventListener('mouseup', handlerEvent) &#125;, disable: function() &#123; document.removeEventListener('mousedown', handlerEvent) document.removeEventListener('mousemove', handlerEvent) document.removeEventListener('mouseup', handlerEvent) &#125; &#125;&#125; 离线应用和客户端存储离线应用离线检测navigator.onLine 离线事件123456EventUtil.addHandler(window, "online", function()&#123; document.getElementById("status").innerHTML = "Online";&#125;);EventUtil.addHandler(window, "offline", function()&#123; document.getElementById("status").innerHTML = "Offline";&#125;); 数据存储cookie限制：存在客户端计算机上，每个域最多几十个。只能保存单一文本，总共最大尺寸4k。 属性：key，名称，必须经过URL编码value：值，必须经过URL编码域：在某些域下才有效并携带发送到服务器。（.baidu.com对baidu.com的所有子域都有效）路径：指定路径有效并携带。（http://www.baidu.com/news/，跟路径则不会发送cookie）失效时间：时间戳，什么时候删除cookie。安全标志：secure（非名值对儿），只有在SSL链接下才发送。 Set-Cookie: name=value; domain= .wrox.com; path=/; secure Http专有cookie可以从浏览器和服务器设置，但是只能从服务器端读取，JS无法获取。 Web StorageStorage类型clear()：清空所有值getItem(name)：获取name的值key(index)：获取index处值的名称removeItem(name)：删除setItem(name,value)：设置PS：只能存储字符串 sessionStorage对象会话存储，存储某个特定会话的数据，保持到浏览器关闭。sessionStorage中的数据只能由最初设置的页面访问，不能跨页面 localStorage对象限制：同一来源有效，即同一个域（子域名无效），同一种协议，同一个端口。每个来源2~5MB大小限制。有效期：一直存在，直到JS删除或用户清楚缓存 IndexedDB替代了Web SQL Database API。保存结构化数据的一种数据库。操作完全是异步进行，因此，大多数操作会以请求的方式进行，异步返回成功结果或失败错误。限制：不能跨域，必须同源（域，协议，端口），大小5MB左右。 获取：（因为浏览器厂商提供的API都有前缀） var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778(function() &#123; var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB, // 消除厂商差异 IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction, // 定义事务的访问模式 IDBCursor = window.IDBCursor || window.webkitIDBCursor, IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange, request, store, database, users = [&#123; username: "007", firstName: "James", lastName: "Bond", password: "foo" &#125;, &#123; username: "ace", firstName: "John", lastName: "Smith", password: "bar" &#125;, &#123; username: "foobar", firstName: "Michael", lastName: "Johnson", password: "secret" &#125;]; request = indexedDB.open("example"); request.onerror = function(event) &#123; alert("Something bad happened while trying to open: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; database = event.target.result; initializeDatabase(); &#125;; function initializeDatabase() &#123; if (database.version != "1.0") &#123; // 默认无版本，最好先定义版本，避免产生不同的版本 request = database.setVersion("1.0"); request.onerror = function(event) &#123; alert("Something bad happened while trying to set version: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; store = database.createObjectStore("users", &#123;keyPath: "username"&#125;); // 定义对象存储空间和主键 users.forEach(function(user) &#123; store.add(user); // 如果主键重复了，add返回错误，put直接覆盖。 // get取得值，delete删除对象，clear删除所有对象 &#125;); outputValues(); &#125;; &#125; else &#123; outputValues(); &#125; &#125; function outputValues() &#123; // 事务组织所有的操作 var store = database.transaction("users", IDBTransaction.READ_WRITE).objectStore("users"), index = store.createIndex("username","username",&#123;unique:false&#125;); // 取得索引 sotre.index("username") range = IDBKeyRange.bound("007", "ace", false, false), // 指定游标范围。下界，上界，是否跳过下，上 request = store.openCursor(range, IDBCursor.PREV); // 指定游标的方向。NEXT/NEXT_NO_DUPLICATE request.onsuccess = function(event) &#123; var cursor = event.target.result; if (cursor) &#123; // 必须要检查 console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value)); cursor.value.password = 'xxx'; var updateRequest = cursor.update(cursor.value); // 请求更新 // cursor.delete() 删除当前项 cursor.continue(); // 移动到下一项，可以指定key // cursor.advance(count) 移动指定位数 &#125; else &#123; console.log("Done!"); &#125; &#125;; request.onfailure = function(event) &#123; console.error("Iteration did not succeed."); &#125;; &#125;&#125;)(); 最佳实践性能优化避免不必要的属性查找访问数组元素是一个O(1)的操作，访问对象的属性则是O(n)的操作。避免多次查找统一属性，可以先存储起来。 优化循环 减值迭代，从最大值到0，更高效。 简化终止条件，避免属性查找或O(n)的操作。比如：i&lt;arr.length。 简化循环体。 使用do-while，避免最初的终止条件计算。 Duff装置仅在处理大数据集时使用，更加高效。12345678910111213141516171819var arr = []var iterations = Math.floor(arr.length / 8);var leftover = arr.length % 8;var i = 0;if (leftover &gt; 0) &#123; do &#123; process(arr[i++]); &#125; while (--leftover &gt; 0);&#125;do &#123; process(arr[i++]); //循环再开，比单纯的循环调用更加高效 process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]);&#125; while (--iterations &gt; 0); 最小化语句数多个声明合一，更高效： var count=5, color=&apos;red&apos;, arr=[1,2,3]; 初始化数组和对象时使用字面量var arr=[1,2,3]; var obj={age:20}; 优化DOM交互 最小化更新DOM次数。 使用innerHTML，一次性更新。 使用事件代理，利用事件冒泡，在祖先节点上处理事件。减少事件绑定数量。 减少使用HTMLCollection对象 getElementByxxx()，childNodes，attributes，document.forms，document.images等都会返回HTMLCollection，每次访问它的属性时都会在文档上进行实时的查询，开销昂贵。 其他 原生方法更快 switch语句更快 位运算符更快 新兴的API这些API都不在H5的规范中，只是与H5相关。 Page Visibility API探测页面是否最小化或者隐藏在其他标签后面。方便资源的暂停。 var isHide = document.hidden || document.msHidden || document.webkitHidden; document.visibilityState：4种表示不同状态的值 visibilitychange事件EventUtil.addHandler(document, &quot;msvisibilitychange&quot;, handleVisibilityChange); EventUtil.addHandler(document, &quot;webkitvisibilitychange&quot;, handleVisibilityChange); Geolocation API获得用户当前地理位置，需要用户授权。12345678910111213navigator.geolocation.getCurrentPosition(function(position)&#123; // position.coords对象有以下属性：latitude 维度，longitude 经度，accuracy 单位 &#125;, function(error)&#123; // error.message &#125;);var id = navigator.geolocation.watchPosition(function(position) &#123; // 方法第一次会取得当前位置，然后在系统发生位置改变时被调用&#125;, function(error) &#123; //&#125;);clearWatch(id); //取消追踪 File APIFileReaderFile类型，包含name,size,type属性。event.files12345678910111213141516171819202122232425262728293031323334353637var filesList = document.getElementById("files-list");EventUtil.addHandler(filesList, "change", function(event)&#123; var info = "", output = document.getElementById("output"), progress = document.getElementById("progress"), files = EventUtil.getTarget(event).files, type = "default", reader = new FileReader(); if (/image/.test(files[0].type))&#123; reader.readAsDataURL(files[0]); type = "image"; &#125; else &#123; reader.readAsText(files[0]); type = "text"; &#125; reader.onerror = function()&#123; output.innerHTML = "Error code :" + reader.error.code; //1,未找到。2,安全错误。3,读取中断。4,文件不可读。5,编码错误 &#125;; reader.onprogress = function(event)&#123; if (event.lengthComputable)&#123; progress.innerHTML = event.loaded + "/" + event.total; &#125; &#125;; reader.onload = function()&#123; var html = ""; switch(type)&#123; case "image": html = "&lt;img src=\"" + reader.result + "\"&gt;"; break; case "text": html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;); 部分读取返回blob类型（file的父类型）12345678910111213function blobSlice(blob, startByte, length)&#123; if (blob.slice)&#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice)&#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice)&#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125;var blob = blobSlice(files[0], 0, 32); 对象URLbloblURL，指向一块内存地址1234567891011function createObjectURL(blob)&#123; if (window.URL)&#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL)&#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125;var url = createObjectURL(files[0]);output.innerHTML = "&lt;img src=\"" + url + "\"&gt;"; 文件拖放并上传1234567891011121314151617181920212223242526272829303132333435var droptarget = document.getElementById("droptarget");function handleEvent(event)&#123; var info = "", output = document.getElementById("output"), data, xhr, files, i, len; EventUtil.preventDefault(event); if (event.type == "drop")&#123; data = new FormData(); files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; data.append("file" + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open("post", "xxx", true); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; alert(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, "dragenter", handleEvent);EventUtil.addHandler(droptarget, "dragover", handleEvent);EventUtil.addHandler(droptarget, "drop", handleEvent); //取消dragenter、dragover和drop的默认行为 Web workers使用worker使用后台线程/进程执行复杂的运行实现异步。如加/解密，图片处理等 123456789var data = [23,4,7,9,2,14,6,651,87,41,7798,24],worker = new Worker("WebWorkerExample01.js");// 下载js文件，但并不立即执行worker.onmessage = function(event)&#123; console.log(event);&#125;;worker.postMessage(data); // 可以传递文本，也可以传递对象（副本）worker.terminate(); // 终止worker worker中12345678910111213self.onmessage = function(event)&#123; var data = event.data; data.sort(function(a, b)&#123; return a - b; &#125;); self.postMessage(data);&#125;;self.onerror = function(event)&#123; // event.filename // event.lineno // event.message&#125;self.close(); // 停止工作 全局方法importScripts(&quot;com1.js&quot;,&quot;com2.js&quot;); // 异步加载。按顺序执行。 worker全局作用域worker单独一个作用域，不能访问DOM元素和标签。this引用的是worker对象。限制版本的navigator对象。制度的location对象。setTimeout()、setInterval()、clearTimeout()、clearInterval()方法XMLHttpRequest函数。 工具 链接 描述 client.js 浏览器及版本检测工具 EventUtil.js 跨浏览器事件处理工具 CookieUtil.js cookie操作工具 EventTarget.js 自定义事件操作工具 richtext.html 自制富文本编辑器]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通C#_注释笔记]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%B2%BE%E9%80%9AC_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言，然而，IL却包含一些抽象概念(比如：类、异常)，这也是这种语言被称为中间语言的原因。IL被打包在DLL或EXE文件中，而DLL和EXE在.NET中的主要区别就是：只有EXE可以直接被运行，而二者都可被某个正在执行的进程动态装载。由于机器的CPU只能执行本地汇编语言，而不是IL，进一步将IL编译成汇编语言的工作(也就是第二阶段)需要在运行时进行，这个过程由即时编译器(JIT)完成。 高级语言在初次被编译时，编译器做两件事：首先把编译得到的IL存储在DLL或EXE中，然后为类的每个方法创建一个stub函数，此函数会调用即时编译器，并将自身的地址作为参数传给编译器。即时编译器则从DLL或EXE中获取相应的IL，编译成机器语言，并将内存中的原零时调用函数替换成机器语言。这个过程的思想，是用已编译的方法调用未编译的方法，实质上被调用的是stub函数；stub函数再调用编译器，将自身编译为本地机器语言；最后，.NET会重新调用该方法，方法此时才被真正地执行。函数被反复调用时，机器指令会被直接执行，而只由编译器对方法进行初次编译需要花费时间。至于那些没有被调用的方法，则不会被编译。 当编译器生成一个EXE文件后， 该程序的入口函数为Main() 方法。装载器将这个EXE 文件载入，探测到该这是一个托管EXE，于是又载入 .NET运行时库文件(包括即时编译器)， 接着调用了EXE 的Main() 方法。这将触发对Main()方法的即时编译， Main()方法在内存中被替换为本地机器语言，于是 .NET应用程序开始运行。在被编译为本地语言后，应用程序便可以自由调用本地代码了。当程序中止时，本地代码从内存中释放，所以在下次运行时，IL需要被即时编译器重新编译。 CTS类型规范，规定了类型必须如何定义才能被CLR承载。內建的CTS数据类型： CLS不同的语言有不同的表示，理想情况是所有支持.NET的语言都有一个可遵循的基准。描述了支持.NET的编译器必须支持的最小的和完全的特征集。以生成可由CLR承载的代码。 mscoree.dll工作流 .NET命名空间举例 Microsoft根命名空间包含的类型用于和那些只属于Windows操作系统的服务进行交互 .NET SKD配置Path或者 开始-所有程序-Vs-VS Tools-开发人员命令提示 csc /t:exe[/target:exe] 1.cs csc 1.cs（默认） csc /t:library 1.cs（输出dll） 响应文件外部引用 /r:System.Windows.Forms.dll 输出 /target:exe /out:TestApp.exe *cs 默认响应文件csc.rsp（与csc.exe同目录），包含大部分常用程序集引用。默认被csc.exe引用。可以简写为： csc /out:TestApp.exe *.cs ## 第二/三部分：C#核心编程结构/C#面向对象编程char的静态方法char.IsDigit 是否为数字char.IsLetter 是否为字母char.IsWhiteSpace 是否为空白char.IsPunctuation 是否为标点char.IsLower 是否为小写char.IsUpper 是否为大写 改变枚举底层存储类型enum EmpType { Manager, Grunt, Contractor, VicePresident } 可以节省内存。但小心溢出可以定义未核心系统类型（byte,short,int或long） PS：获取底层存储类型 Enum.GetUnderlyingType(typeof(EmpType)) -&gt; System.Int32 获取名值对 var ret = Enum.GetValues(typeof(EmpType)); foreach (var item in ret) { Console.WriteLine(&quot;{0}，{0:D}&quot;, item); } System.ValueType枚举，结构都隐式派生自此类型。分配在栈上运行 浅/深复制当一个值类型中包含一个引用类型。如结构中包含对象引用，直接等号赋值时会有两个独立的结构，内部生成一个引用的副本，指向内存中同一个对象的引用。（浅复制） 默认访问修饰符类型成员（变量，方法），是隐式【私有】的。类型（对象）是隐式【内部】的。 class Radio //内部 { Radie(){} //私有 } Const,readonly,staticconst(常量)=readonly(只读)+static(静态)编译期确定 运行期确定都不可再更改 ## 第四部分：高级C#编程结构delegate关键字使用此关键字创建委托时，就间接声明了一个派生自MulticastDelegate的类。不会直接派生自这些基类，但这个类“是”MulticastDelegate 委托一个委托对象维护一个可调用方法的列表，而不是一个单独的方法。添加方法，使用+=即可。编译器会将+=转换为Delegate.Combine()方法调用。+=更简洁-=则转换为Delegate.Remove() event事件事件会扩展为两个隐藏的公共方法，一个add_xx，一个remove_xx。调用者仅需使用+=和-=操作符（操作符将在后台触发正确的add_xx和remove_xx方法，来对原委托进行操作）。 EventHanlder自定义EventArgs的泛型委托 class My { public event EventHandler&lt;MyEventArgs&gt; Display; public void Do(MyEventArgs msg) { if (Display != null) { Display(this, msg); } } } 不再需要定义一个自定义委托类型 操作符重载的思考通常仅在构建原子数据类型时才有用。文本，点，举行，分数等都是操作符重载的很好候选。人，经理，汽车，数据库连接等却不是。如果一个重载操作符会使用户更难于理解该类型的功能，那就别用它。 Try catch的CIL实现对一个实现了IDispose对象的using{}语句块会被CIL解析为一个try{}finally{}块。确保Dispose的执行。 new关键字的CIL实现使用new时，等同于CIL指令newobj：执行：1，计算分配对象需要总内存数2，检查托管堆，如果空间足够，则调用类型构造函数，最终将内存中新对象的应用返回给调用者。它的地址恰好是下一个对象的上一个位置。如果空间不足，则执行一次垃圾回收来尝试是否内存。3，返回引用之前，移动下一个对象的指针，指向托管堆上的下一个可用的位置。 自动属性的CIL实现自动属性的get;set;标记会在元数据中被编译器映射成一个私有字段Name和两个方法get_Name(),set_Name()。 应用程序根根(root)就是一个存储位置，保存着对托管堆上对象的引用。垃圾回收时，CLR判读托管堆上的对象，判断应用程序是否仍然可访问它们(是否还有根)。为此，CLR建立一个对象图。不可访问的对象被标记为终结(finalize，垃圾)，它们就会从内测中清除。此时，堆上剩余的空间被压缩调整，引起CLR修改活动应用程序根的集合，指向正确的内存位置。下一个对象的指针被重新调整指向下一个可用位置。 对象的代设计思路：对象在堆上存在的时间越长，他就更可能应该保留。(WinForm主窗口)最近才放在堆上的对象可能很快就不可访问了。(一个方法中创建的对象)。第0代：从没有被标记为回收的新分配对象。第1代：在上一次垃圾回收中没有被回收的对象(曾被标记为回收，但因为已经从其他对象获取了足够的堆空间而没有被删除)第2代：在一次以上的垃圾回收后仍然没被回收的对象。 通过给对象赋一个表示代的值，尽快的删除一些较新的对象(本地变量)，而不会经常打扰一些旧对象(主窗体) 强制垃圾回收GC.Collect(); //强制回收所有代 //GC.Collect(1, GCCollectionMode.Forced); //回收0-1代 GC.WaitForPendingFinalizers(); //挂起线程，等待回收结束 适用：1，程序将进入一段代码，后者不希望被可能得垃圾回收中断。2，刚刚分配分厂多的对象，想尽可能多地删除已获得的内存。 GC测试 //输出堆上估计得字节数 Console.WriteLine(GC.GetTotalMemory(false)); //目前最高代 Console.WriteLine(GC.MaxGeneration); //某对象处于多少代 object obj = new object(); Console.WriteLine(GC.GetGeneration(obj)); //测试数组 object[] objs = new object[500000]; for (int i = 0; i &lt; 500000; i++) objs[i] = new object(); //输出堆上估计得字节数 Console.WriteLine(GC.GetTotalMemory(false)); //回收第1代 GC.Collect(0, GCCollectionMode.Forced); GC.WaitForPendingFinalizers(); Console.WriteLine(GC.GetGeneration(obj)); //看一下9000是否还活着 if (objs[9000] != null) Console.WriteLine(&quot;活着：处于&quot; + GC.GetGeneration(objs[9000]) + &quot;代&quot;); else Console.WriteLine(&quot;死了&quot;); //某代被回收次数 Console.WriteLine(&quot;0代：{0}，1代：{1}，2代：{2}&quot;, GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2)); //跳过对象的终结阶段，通知CLR不在调用对象的析构函数 GC.SuppressFinalize(this); 资源包装器引用托管或非托管宝贵的资源(数据库，文件句柄等)时，希望尽可能快的释放资源。而不能依靠GC的回收。 class MyResourceWrapper : IDisposable { //判断Dispose()是否被调用过 private bool disposed = false; //用户忘了Dispose()，垃圾回收器会调用这个方法 ~MyResourceWrapper() { //调用辅助方法，指定false表示GC触发了清理 CleanUp(false); } //用户可以主动调用，来尽快清除资源 public void Dispose() { //调用辅助方法，指定true表示用户触发了清理 CleanUp(true); GC.SuppressFinalize(this); } private void CleanUp(bool disposing) { if (!disposed) { //如果disposing为true，释放所有托管资源。如果disposing为false，不确定托管资源是否还在内存中，不执行释放。 if (disposing) { //释放托管的资源 } //在这里释放非托管的资源 } disposed = true; } } 测试： ~MyResourceWrapper() { Console.Beep(); //命令行一声响声 CleanUp(false); } static void Main(string[] args) { MyResourceWrapper m = new MyResourceWrapper(); m.Dispose(); MyResourceWrapper m1 = new MyResourceWrapper(); //此时会响一声 } Lazy 延迟加载class Program { static void Main(string[] args) { MP3 m = new MP3(); //不使用Lazy，此句加载SDCard，然后初始化Song[] var r = m.Card; var v = r.Value; //使用Lazy，此句加载SDCard，然后初始化Song[] //或 var c = m.GetCard(); Console.ReadKey(); } } class Song { public string FileName { get; set; } public string FileLength { get; set; } } class SDCard { public decimal Price { get; set; } private Song[] allSongs = new Song[100000]; public SDCard() { Console.WriteLine(&quot;装满歌曲&quot;); } } class MP3 { //public void Play() //播放 //public void Pause() //暂停 //public void Stop() //停止 public Lazy&lt;SDCard&gt; Card = new Lazy&lt;SDCard&gt;(() =&gt; //不传参或传一个Lambda表达式 { var newCard = new SDCard { Price = 50 }; return newCard; }); public SDCard GetCard() { return Card.Value; } } 第五部分：用.NET程序集编程.NET程序集的作用1，促进代码重用。一个代码库(.dll或.exe)被打包后，可以被外部应用程序调用。.NET平台允许我们以语言无关的方式来重用其中的类型，如C#创建，其他.NET语言调用。2，确定类型便捷。类型的完全限定名需要加上类型所在程序集。如两个不同程序集中命名空间相同的类，被认为是不同的。3，可版本化的单元。每个程序集被分配一个...的四部分数字版本号(默认1.0.0.0，默认VS项目设置)。版本号加上可选的公钥值(即程序集强名)使一个程序集的不同版本可在同一台机器共存而不冲突 。通过强名，CLR保证客户端调用程序能加载正确版本的程序集。4，自描述。程序集记录了清单数据(自身运行需要的外部程序集)，还包含了一些元数据(程序集包含的每一个类型的组成，成员名称，接口，基类，构造等)。由于信息被详细的记录了，CLR不需要访问注册表来解析程序集的位置(区别于与微软原来的COM编程模型)5，可配置的。程序集可“私有”或“共享”。私有：与调用它的客户端应用程序处于同一个目录或子目录下，共享：被部署在全局程序集缓存（GAC）的特定目录中。通过编写XML的配置文件，CLR可以指定位置朝赵，加载指定版本的程序集。查阅本地，网络或URL上的任意目录。 程序集和托管模块一个团队（程序集），是一个逻辑单位。里面有很多成员（托管模块）成员分2类：普通成员（托管模块，后缀.netModule。持有元数据和CIL代码）领导成员（主模块，后缀.exe或.dll。持有程序集清单），了解每个成员一般与这个团队（程序集）沟通或合作是面向它的领导（主模块），同样以领导名称来称呼这个团队。 C#生成的程序集一般为单模块程序集（只有主模块）。 .NET程序集的格式(.dll或.exe)包含：1，Windows文件首部：可被Windows操作系统加载，标识了应用程序以什么类型（控制台，图形用户界面还是*.dll代码库）驻留于Windows操作系统中。2，CLR文件首部使CLR了解托管文件的布局，位置和强名等3，CIL代码独立于平台和CPU的中间语言，运行时才被JIT变异成特定平台和CPU的指令。4，类型元数据内含类型和外部应用类型的格式。5，程序集清单记录了每一个模块，版本和引用的外部程序集。6，可选的嵌入资源图标，图像，声音，字符串表。卫星程序集(附属程序集)可构建国际化软件系统。 代码中的每个字符串字面量都记录在元数据的User Strings 标记下所以不能储存敏感信息。 私有程序集应用程序添加外部程序集引用的时候，把副本文件放在本地bin文件夹下。调用时，CLR只是加载本地的副本。并不查询系统注册表。 配置私有程序集：Test.exe //一个Console控制台程序Carlib.dll //控制台会调用的程序集 以下三种情况会正常运行：1，把Test.exe和Carlib.dll放在同一个文件夹下2，找不到Carlib.dll的文件，会查找同一个文件夹下具有相同友好名称的可执行程序集.exe文件3，找与程序集同名的文件夹下是否有此程序集。如Carlib/Carlib.dll4，如果有Test.exe.config配置文件，CLR会根据配置的“规则”探测指定文件夹下是否有此程序集。例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;probing privatePath=&quot;CarLibChg/&quot; /&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt; 如果还是找不到，会引发FileNotFoundException异常 PS：VS的App.config会在编译的时候，把App.config的数据复制到bin/debug/文件下，并改一个合适的名称。如Test.exe.config，FrontWeb.dll.config 共享程序集例如mscorlib.dll，旨在多个项目中服用的类型的集合，共享程序集的一个副本可供一台机器上的多个应用程序使用，是机器级别的类库（machine wide）。 全局程序集缓存：.NET 3.5以前的位置在，C:\Windows\assembly下4.0以上的在C:\Windows\Microsoft.NET\assembly\GAC_MSIL下的v4.0_major.minor.build.revision_publicKeyTokenValue子文件夹下。例如：v4.0_4.0.0.0__b77a5c561934e089。 强名称1，需要.NET的sn.exe工具生成公钥/私钥对。生成一个.snk（Strong Name Key）文件。C#编译器确定.snk文件的位置后，会在编译时把公钥值记录在程序集清单的.publickey标记中。2，产生一个基于整个程序集内容（CIL代码，元数据等）的散列值（某一固定输入的独一无二的数值输出，如果更改了程序集的内容，就算只一个字符，陈胜的讲师完全不同的散列码）。散列码结合私钥组成数字签名，并把它嵌入到程序集的CLR首部数据中。 用命令行生成强名：developer Command Prompt下 sn -k 文件名.snk 再在AssemblyInfo.cs文件中指定位置 [assembly: AssemblyKeyFile(@&quot;C:\MyTestKeyPair.snk&quot;)] 编译时，公钥被压缩成散列值加入到清单中 .publicKeyToken标记 用VS生成强名：Properties -&gt; 签名 -&gt;新建便会在根目录下生成一个*.snk文件 在GAC中安装强名称的程序集使用Developer Command Prompt定位到*.dll所在目录（bin\debug）使用 gacutil -i test.dll/test.exe //安装 gacutil -l test //核实 gacutil -u test //卸载 VS引用程序集时，如果清单中含有.publickey值时，VS会嘉定这个具有强名称的程序集以备部署到GAC中，那么引用的属性窗口中的，复制本地就为false。不会对该程序集进行复制到本地debug文件夹中的工作。 配置共享程序集发布了1.0.0.0版本后，添加了一些新的功能，产生了2.0.0.0版本。如果客户端应用程序想要使用2.0.0.0版本的新功能，可以把2.0.0.0版本发布到目标机器，让2和1版本和平共处。需要的时候修改*.config文件，动态的定向到2.0.0.0版本。这一切并不需要重新编译和部署。 动态重定向到共享程序集： &lt;dependentAssembly&gt; &lt;assemblyIdentity name=&quot;System.Web.Mvc&quot; publicKeyToken=&quot;31bf3856ad364e35&quot; /&gt; &lt;bindingRedirect oldVersion=&quot;0.0.0.0-5.2.3.0&quot; newVersion=&quot;5.2.3.0&quot; /&gt; &lt;/dependentAssembly&gt; 定义了程序清单当前指向的版本(oldVersion)和GAC中的替代版本(newVersion) 元素用于指示CLR探测位于任意位置（网络重点，其他本地目录）的依赖程序集。当指向远程计算机时，相关程序集会下载到GAC的下载缓存中。通过此元素加载的程序集必须具有强名称。 例： &lt;codeBase version=&quot;2.0.0.0&quot; href=&quot;http://www.MySite.con/Assemblies/CarLibrary.dll&quot; /&gt; Type类型Car c = new Car(); Type t1 = c.GetType(); //编译器获得Type实例，需要类型实例 Type t2 = typeof(Car); //同上，不需类型实例 Type t3 = Type.GetType(&quot;ConsoleApplication2.Person&quot;, false, true); //完全限定名（不抛出异常，忽略大小写） Type t4 = Type.GetType(&quot;ConsoleApplication2.Person+Sex&quot;, false, true); //获得类型中的嵌套类型，加“+” Type t5 = Type.GetType(&quot;CarLib.Car,CarLib&quot;, false, true); //引用外部程序集类型，加“,” Type t6 = Type.GetType(&quot;System.Collections.Generic.List`1&quot;, false, true); //对于泛型，加“`”+数字（类型参数的个数） Console.ReadKey(); 动态加载程序集Assembly asm = Assembly.Load(&quot;Carlib&quot;); //需要保证程序集二进制文件在Debug文件夹下 asm = Assembly.LoadFrom(@&quot;C:\Code\Carlib.dll&quot;); //绝对路径，以编程的形式提供&lt;codeBase&gt;值 asm.GetTypes().ToList().ForEach(Console.WriteLine); 反射共享程序集string displayName = @&quot;System.Windows.Form.dll,Version=4.0.0.0,PublicKeyToken=b77a5c561934e089,Culture=&quot;&quot;&quot;; //显示名称：标识一个程序集的一组术语 //加载共享程序集必须指定公钥标记值 AssemblyName asmName = new AssemblyName(); asmName.Version = new Version(4, 0, 0, 0); //或者使用面向对象的类来传递Version,PublicKeyToken等参数 Assembly asm = Assembly.Load(displayName); asm = Assembly.Load(asmName); 晚期绑定Assembly asm = Assembly.Load(&quot;CarLib&quot;); //无需引用，只需把程序集文件放在Debug文件夹下 Type car = asm.GetType(&quot;CarLib.Car&quot;); object obj = Activator.CreateInstance(car); //建立一个晚期绑定类型的实例，类型为object。 object obj1 = Activator.CreateInstance(&quot;CarLib&quot;, &quot;CarLib.Car&quot;).Unwrap(); MethodInfo mi = car.GetMethod(&quot;Run&quot;); //无法转换类型，使用反射调用实例方法。默认搜索公共方法成员 mi.Invoke(obj, null); //调用无参方法 MethodInfo mi2 = car.GetMethod(&quot;Stop&quot;, BindingFlags.Instance | BindingFlags.NonPublic); //指定私有成员包含在搜索内 mi2.Invoke(obj, new object[] { &quot;停车&quot; }); //指定参数列表 关键在于，在没有某个程序集清单数据的情况下，创建程序集的类型实例。 特性用于类型，成员，程序集或模块的代码注解。把更多的元数据嵌入到程序集中。 程序集级别特性使用[assembly:]标签，给特定程序集所有类型应用特性。例：[assembly: CLSCompliant(true)]强制所有程序集中的公共类型符合CLS 构建可扩展的应用程序比如VS，开发的时候允许其他软件提供商向IDE开发环境中插入各种“钩子”（自定义模块），一个可能得思路如下： 1，可扩展的应用程序必须提供一些输入手段，允许用户指定被插入的模块。这需要动态加载2，必须要确定模块是否支持正确的功能（一组需要的接口）。这需要反射3，必须获取一个需要的基础架构的引用（例如接口类型）并调用成员触发底层功能。这经常需要晚期绑定。 1，构建每个插件对象需要实现的类型定义应用于插件对象和承载应用程序。保证功能统一 namespace CommonSnappableTypes { public interface IAppFunctionality { void DoIt(); } [AttributeUsage(AttributeTargets.Class)] public sealed class CompanyInfoAttribute : Attribute { public string CompanyName { get; set; } public string CompanyUrl { get; set; } } } 2，构建C#插件 namespace CSharpSnapIn { [CompanyInfo(CompanyName = &quot;JetBrains&quot;, CompanyUrl = &quot;www.xxx.com&quot;)] public class CSharpModule : IAppFunctionality { void IAppFunctionality.DoIt() //显示的接口实现，DoIt方法没有在CSharpModule中公开 { Console.WriteLine(&quot;使用了自定义插件&quot;); } 或 public void DoIt() { Console.WriteLine(&quot;使用了自定义插件&quot;); } } } 3，构建承载的应用程序 namespace ConsoleApplication2 { class Program { static void Main(string[] args) { string path = &quot;...&quot;; //可以从WinForm等应用程序中选择程序集文件 Assembly asm = Assembly.LoadFrom(path); //注意非空判断 //得到程序集中所有兼容IAppFunctionality的类 var types = asm.GetTypes().Where(m =&gt; m.IsClass &amp;&amp; m.GetInterface(&quot;IAppFunctionality&quot;) != null); foreach (var item in types) { IAppFunctionality app = (IAppFunctionality)asm.CreateInstance(item.FullName, true); //用晚期绑定获得实例 或 IAppFunctionality app1 = (IAppFunctionality)Activator.CreateInstance(item); app.DoIt(); } Console.ReadKey(); } } } dynamic允许我们在类型安全的强类型世界里使用校本化的行为。可以认为dynamic关键字是一个特殊形式的System.Object。但提供了更多特性，并且动态数据不是强类型的，或者说动态数据不是静态类型。 作用范围：字段，属性，返回值，参数 调用动态声明的数据成员动态数据不属于静态类型，和js一样，直到运行时你才会直到所调用的动态数据是否支持指定的成员，参数以及成员的拼写是否无误等。编译时不能触发智能感知提示。 dynamic实际用途构建一个需要大量使用后期绑定（通过反射）的.NET应用程序时。或者构建一个需要与遗留的COM库（如Office）进行交互的.NET应用程序。使用dynamic可以大大减少打字时间，简化代码。但代价是失去了类型的安全性。 DLR(dynamic language runtime，动态语言运行时)的特性1，机器灵活的代码库，重构时不需要频繁修改数据类型2，不同平台和语言所构建的对象类型之间进行互操作非常简便。3，可以在运行时为内存中的类型添加或移除成员。 使用dynamic简化晚期绑定Type type=...; 1，通过反射 object obj=Activator.CreateInstance(type); MethodInfo mi=tpe.GetMethod(&quot;Run&quot;); object[] param=10,20; mi.Invoke(obj,param); 2，通过dynamic dynamic obj=Activator.CreateInstance(type); obj.Run(10,20); 简化了查询程序集元数据和打包参数等操作。 互操作程序集IDE以COM库为基础生成的全新程序集，包含了COM元数据的.NET描述和一小部分将COM事件转换为.NET事件的代码。封装，避免了内部COM的复杂性。 CLR（如果使用dynamic就是DLR）自动对.NET数据类型和COM类型进行映射，因此可以直接在C#代码中使用互操作程序集。在后台，使用RCW（Runtime Callable Wrapper，一个动态生成的代理）对数据进行封送，使其在.NET和COM应用程序之间交互。 主互操作程序集许多COM库供应商提供了一个“官方”的互操作程序集，成为主互操作程序集，简称PIA。PIA是优化的互操作程序集，比通过IDE添加COM库引用生成的代码更整洁，也更具扩展性。PIA存在的情况下，添加应用一个COM库，VS会使用提供的PIA，而不是生成一个新的互操作程序集。 嵌入互操作元数据添加COM库（PIA或其他）时，IDE会自动将该库的“嵌入互操作类型”置为true。这样，必要的互操作元数据（你真正使用的那部分，而不是全部）已经硬编码到.NET程序中，我们就不必在.NET应用程序中携带互操作程序集的副本了。减少了安装包的尺寸，客户端计算机也不必包含改互操作程序集的副本。 表达式树当使用DLR进行处理动态数据时，自动创建的“表达式树”将被传递给正确的动态语言帮顶起。帮顶起解析表达式树并传递给正确的对象成员。 进程一个正在运行的应用程序的固定的安全的边界。用来描述一组资源（外部代码库和主线程）和程序运行所必须的内存分配。 应用程序域：对该进程的逻辑细分。一个应用程序域进一步被细分成多个上下文边界，用来分组目的相似的.NET对象。 进程，应用程序域，上下文的关系： 线程：进程中的独立的基本的执行单元。每一个进程都有一个（在可执行入口处创建的）主线程和其他包含以编程方式创建的额外线程。 进程和线程的关系：当一个线程的时间片用完的时候，会被挂起，以便执行其他线程。线程把挂起前的情况写到线程本地存储中（Thread Local Storage，TLS），并且它们还要获得一个独立的调用栈（call stack） Process类using System.Diagnostics; var procs = Process.GetProcesses(&quot;.&quot;); procs.OrderBy(m =&gt; m.Id).ToList().ForEach(m =&gt; Console.WriteLine(&quot;{0}：{1}&quot;, m.Id, m.ProcessName)); var proc = Process.GetProcessById(4); //进程不存在则引发异常 //PID为0的System Idle Prcess，表示系统核心虚拟出来的表示CPU空闲的状态。输入会出错。 Console.WriteLine(proc.Id + &quot;：&quot; + proc.ProcessName); //ProcessThread并不用于操作线程，只是用户获取运行进程中线程的诊断信息 foreach (ProcessThread item in proc.Threads) { Console.WriteLine(&quot;{0}：{1}：{2}：{3}&quot;, item.Id, item.PriorityLevel, item.StartTime, item.ThreadState); } 查看进程中的模块var proc = Process.GetProcessById(10284); var modls = proc.Modules; foreach (ProcessModule item in modls) { Console.WriteLine(&quot;{0}：{1}&quot;, item.ModuleName, item.ModuleMemorySize); } 编程方式启动或结束进程var proc = Process.Start(&quot;Chrome&quot;, &quot;www.baidu.com&quot;); Console.WriteLine(&quot;启动：&quot; + proc.ProcessName + &quot;，PID：&quot; + proc.Id); Console.ReadKey(); proc.Kill(); //如果进程已关闭，或附加到别的进程上。则此处会抛出异常 ProcessStartInfo启动进程ProcessStartInfo info = new ProcessStartInfo { FileName = &quot;Chrome&quot;, Arguments = &quot;www.baidu.com&quot;, WindowStyle = ProcessWindowStyle.Hidden }; var proc = Process.Start(info); 应用程序域传统的非托管程序直接承载在进程上，而.NET可执行程序承载在进程的一个逻辑分区中，即应用程序域（AppDomain）。运行在某个应用程序域中的应用程序将无法访问其他应用程序域中的数据（无论是全局变量还是静态字段），除非使用分布式编程协议（如WCF）好处在于：1，应用程序域是.NET平台操作系统独立性的关键特性。将不同操作系统表现加载可执行程序的差异抽象化了。2，和一个完整的进程相比，应用程序域的CPU和内存占用都有小的多。因此CLR加载和卸载应用程序域比起来完整的进程来说也快得多，并且可以快速提升服务器应用程序的可扩展性。3，应用程序域为承载的应用程序提供了深度的隔离。如果进程中一个应用程序域失败了，剩余的应用程序域也能保持正常。 .NET平台不允许从内存中卸载指定的程序集。已编程方式卸载库的唯一方式是使用Unload()方法销毁承载的应用程序域。 默认程序域一个.NET可执行文件启动时，CLR会自动将其放置到宿主进程的默认应用程序域中。访问当前线程的应用程序域 AppDomain app = AppDomain.CurrentDomain; Console.WriteLine(&quot;{0}：{1}：{2}：{3}&quot;,app.FriendlyName,app.Id,app.IsDefaultAppDomain(),app.BaseDirectory); //BaseDirectory，程序集解约程序用它来探测程序集 应用程序域中加载的.NET程序集AppDomain app = AppDomain.CurrentDomain; var asms = app.GetAssemblies(); foreach (Assembly item in asms) { Console.WriteLine(item.GetName().Name + &quot;：&quot; + item.GetName().Version); } 接收程序集加载通知AppDomain app = AppDomain.CurrentDomain; app.AssemblyLoad += (o, s) =&gt; { Console.WriteLine(s.LoadedAssembly.GetName().Name); }; 创建新的应用程序域AppDomain app = AppDomain.CreateDomain(&quot;Second&quot;); foreach (Assembly item in app.GetAssemblies()) { //只加载了mscorlib。如果调试的话还会加载用于调试的额外程序集 Console.WriteLine(item.GetName().Name); } app.Load(&quot;CarLib&quot;); //向自定义应用程序域中加载程序集，此时加载的程序集多了一个 AppDomain.Unload(app); //卸载自定义应用程序域 上下文边界给定对象“特定的家”一个进程定义了默认的应用程序域，每个应用程序域都有一个默认的上下文（总是第一个创建），也成为上下文0（context 0）。用于组合那些对上下文没有具体的或唯一性需求的.NET对象（大多数对象）。 不需要指定特定上下文的.NET类型称为上下文灵活（context-agile）对象，可以从应用程序域的任何位置访问，与对象的运行时需求没有关系。需要指定特定上下文的对象称为上下文绑定（context-bound）对象，只能在其被创建的那个上下文中正常运行。必须派生自System.ContextBoundObject基类 定义上下文绑定对象自动线程安全的类 using System.Runtime.Remoting.Contexts; using System.Threading; [Synchronization] public class ContextObject : ContextBoundObject { public void Do() { for (int i = 0; i &lt; 10; i++) { Console.WriteLine(i + &quot;：当前线程-&quot; + Thread.CurrentThread.ManagedThreadId); } } } static void Main(string[] args) { ContextObject obj = new ContextObject(); Task.Run(() =&gt; obj.Do()); Task.Run(() =&gt; obj.Do()); } 研究上下文using System.Runtime.Remoting.Contexts; using System.Threading; [Synchronization] public class ContextObjectBound : ContextBoundObject { public ContextObjectBound() { Context ctx = Thread.CurrentContext; Console.WriteLine(this + &quot; 在上下文中： &quot; + ctx.ContextID); foreach (var item in ctx.ContextProperties) { Console.WriteLine(item.Name); } } } public class ContextObject { public ContextObject() { Context ctx = Thread.CurrentContext; Console.WriteLine(this + &quot; 在上下文中： &quot; + ctx.ContextID); foreach (var item in ctx.ContextProperties) { Console.WriteLine(item.Name); } } } static void Main(string[] args) { ContextObject obj = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObject obj1 = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObjectBound objTs = new ContextObjectBound(); //1，LeaseLifeTimeServiceProperty，Synchronization Console.ReadKey(); } CIL.NET平台语言（C#，VB，F#等）的母语，某个语言相关联的编译器会把源代码翻译成CIL CIL标记分为3类1，CIL指令以.前缀，例如：.namespace、.class、.pulickeytoken、.method、.assembly2，CIL特性例如：public，extends（指定这个类型的基类），implements（支持的一系列接口）3，CIL操作码例如：ldstr（LoadString，定义一个字符串变量），实际上是操作码的助记符。真正的操作码是二进制码。add - 0x58，sub - 0x59，newobj - 0x73 CIL基于栈的本质CIL不允许直接访问一个数据（本地变量、参数变量或属性）。而是通过虚拟执行栈来访问。string myMessage=”Hello”; //分为1-3Console.WriteLine(myMessage); //分为4-5 1，.locals init ([0] string myMessage)定义一个本地字符串变量（在Call Stack本地变量索引0处）2，ldstr “Hello”将字符串的引用放在了Envaluation Stack中，而真正的字符串放在了Managed Heap中3，stloc.0将Envaluation Stack中的值保存到 Call Stack中索引为0的本地变量中（V0，栈低已存在args[最底]和return address），因为Envaluation Stack中存放的是“hello”字符串的地址，所以变量中存放的也是字符串的地址。4，ldloc.0把Call Stack中索引0处变量的的值（引用地址），加载到Envaluation Stack中5，call void [mscorlib]System.Console::WriteLine(string)从 Evaluation Stack 中取出一个值，此值为 Reference Type，调用方法 PS：1，Managed Heap（托管堆）：这是动态配置（Dynamic Allocation）的记忆体，由GC在执行时自动管理，整个 Process 共用一个 Managed Heap，可以理解为引用类型的东西都放在这个Managed Heap中。2，Call Stack（调用栈）：CLR在执行时自动管理的记忆体，每个Thread都有自己的Call Stack堆栈。每调用一次method，就会使得Call Stack上多了一个Record Frame；调用完毕之后，此Record Frame会被丢弃。一般来说，Record Frame内记录着method参数（Parameter）、返回位址（Return Address）、以及局部变量（Local Variable）。CLR使用零基索引的方式来识别局部变量。3，Evaluation Stack（虚拟执行栈）：这是由 CLR在执行时自动管理的记忆体，每个Thread都有自己的Evaluation Stack。压入的到Evaluation Stack的值，当方法调用结束时必须保持这个堆栈的平衡（清空），这里面存放例如局部变量值，以及引用类型的地址。如果忘记清空，ilasm仍然会编译成功。可以用peverify.exe工具诊断。peverify test.dll4，ld，加载，用于压栈到虚拟执行栈5，st，存储，用于弹栈虚拟执行栈顶的值到内存调用栈中 CIL的代码标签例如：IL_0001：，IL_000c大多数标签是可选的，完全可以移除。只有编写有多个分支和循环结构的CIL代码时，通过这些标签指定逻辑流转到哪里的时候，才是必需的。 使用ilasm.exe编译CIL代码ilasm /exe Hello.il /output=NewAssembly.exe -?查看选项参数 CIL指令和特性1，指定外部应用程序集 .assembly extern mscorlib { .publickeytoken=(B7 7A 5C 56 19 34 E0 89) .ver 4:0:0:0 } 2，定义当前程序集 .assembly CILTypes { .ver 1:0:0:0 } .module CILTypes.dll //单模块程序集 3，定义命名空间 .namespace MyNamespance{} .namespace Myconpany.MyNamespace{} 4，定义类类型 .namespace MyNamespace { .class public MyBaseClass extends [BaseEntity]BaseEntity.AuditEntityBase{} //CIL要求使用完整的名字 } 5，定义和实现接口 .class public interface IMyInterface{} .class public MyBaseClass{} .class public MyDerivedClass extends MyNamespace.MyBaseClass implements MyNamespace.IMyInterface{} //同一程序集下可以省略“[]”前缀。 //extends在前，implements在后，多个接口用“，”分隔 //接口派生接口使用implements 6，定义结构 .class public sealed MyStruct extends [mscorlib]System.ValueType{} 简化： .class public sealed value MyStruct{} 7，定义枚举 .class public sealed MyEnum extends [mscorlib]Sytem.Enum{} 简化： .class public sealed enum MyEnum{} 8，定义泛型C#： List&lt;int&gt; myIntes=new List&lt;int&gt;(); CIL： newobj instance void class [mscorlib]Sytem.Collections.Generic.List`1&lt;int32&gt;::.ctor() 9，定义数据字段 .class public sealed enum MyEnum { .field public static literal valuetype MyNamespace.MyEnum A=int32(0) .field public static literal valuetype MyNamespace.MyEnum B=int32(1) } 私有成员 .class public MyBaseClass { .filed private string stringField=&quot;hello!&quot; .filed private int32 intField=int32(42) } 10，定义属性 .class public MyBaseClass { .method public hidebysig specialname instance string get_TheString() cil managed { //实现 } .method public hidebysig specialname instance void set_TheString(string &apos;value&apos;) cil managed { //实现 } .property instance string TheString() { .get instance string MyNamespace.MyBaseClass::get_TheString() .set instance void MyNamespace.MyBaseClass::set_TheString(string) } } 11，定义构造函数 .class public MyBaseClass { .fileld private int32 intField .method public hidebysig specialname rtsspecialname instance void .ctor(string s,int32 i) cil managed { //实现 } //.ctor指令和instance特性结合使用 //cil managed标识出这个方法包含的是CIL代码而不是非托管代码 } 12，定义参数C#： public static void MyMethod(int inputInt,ref int refInt,ArrayList ar,out outputInt) { outputInt=0; } CIL： .method public hidebysig static void MyMethod(int32 inputInt, int32&amp; refInt, class [mscorlib]System.Collections.ArrayList ar, [out] int32&amp; outputInt) cil managed { //... } .NET 基础类库、C#和CIL数据类型的映射 .maxstack指令确定一个在方法执行阶段可以被压入栈中的最大变量数目。默认值是8 在CIL中映射参数到本地变量C#： public static int Add(int a,int b) { return a+b; } CIL：//已简化 .method public hidebysig static int32 Add(int32 a,int32 b) cilmanaged { .maxstack 2 ldarg.0 //加载&apos;a&apos;到栈中 ldarg.1 //加载&apos;b&apos;到栈中 add //从栈中弹出这2个值，并求和，并将计算结果存回栈中 ret //将和弹出栈，并通过ret操作码返回到调用者 } this隐式引用虚拟执行栈索引是从0开始。在使用CIL代码时，任何非静态函数在接收传入参数时都自动隐式地接受了一个附加参数，即当前对象的引用（this）。C#： public int Add(int a,int b) { return a+b; } CIL：//伪代码，this是隐式的接受的 .method public hidebysig static int32 AddTwoInt(MyClass_HiddenThisPointer this,int32 a,int32 b) cil managed { ldarg.0 //加载MyClass_HiddenThisPointer到虚拟执行栈上 ldarg.1 //加载&apos;a&apos; ldarg.2 //加载&apos;b&apos; } 循环结构C#： public static void CountToTen() { for(int i=0;i&lt;10;i++); } CIL： .method public hidebysig static void COuntToTen() cil managed { .maxstack 2 .locals init ([0] int32 i) //初始化本地变量&apos;i&apos; IL_0000: loc.i4.0 //压栈&apos;0&apos;到栈中 IL_0001: stloc.0 //弹栈&apos;0&apos;，并存储这个值到调用栈变量索引&apos;0&apos; IL_0002: br.s IL_0008//跳转到IL_0008 IL_0004: ldloc.0 //压栈索引0的值 IL_0005: ldc.i4.1 //压栈&apos;1&apos; IL_0006: add //两值弹栈，相加，结果压栈 IL_0007: stloc.0 IL_0008: ldloc.0 //压栈索引0的值 IL_0009: ldc.i4.s 10 //压栈&apos;10‘ IL_000b: blt.s IL_0004 //两值弹栈，比较。小于10？如果是，跳转IL_0004 IL_oood: ret // } 动态程序集静态程序集：存在于磁盘的.NET二进制文件 动态程序集：运行中通过使用System.Reflection.Emit命名空间提供的类型在内存中创建程序集及其模块，类型定义以及CIL实现逻辑。并可以保存到磁盘上生成一个新的静态程序集。 用处： 构建需要根据用户输入来生成程序集文件的.NET开发工具 构建需要在运行时通过元数据来生成远程类型的代理的程序 加载静态程序集并能动态插入新类型到二进制图像中。 System.Reflection.Emit命名空间的成员 ILGenerator注入CIL操作码到一个给定的类型成员 产生动态程序集，保存并实现延迟绑定class Program { static void Main(string[] args) { CreateMyAm(AppDomain.CurrentDomain); Assembly asm = Assembly.Load(&quot;MyAssembly&quot;); Type type = asm.GetType(&quot;MyAssembly.HelloWorld&quot;); var mi = type.GetMethod(&quot;SayHello&quot;); object obj = Activator.CreateInstance(type, &quot;123&quot;); mi.Invoke(obj, null); mi = type.GetMethod(&quot;GetMsg&quot;); Console.WriteLine(mi.Invoke(obj, null)); Console.ReadKey(); } static void CreateMyAm(AppDomain app) { //建立通用程序集特征 AssemblyName asmName = new AssemblyName { Name = &quot;MyAssembly&quot;, Version = new Version(1, 0, 0, 0), KeyPair = new StrongNameKeyPair(File.ReadAllBytes(@&quot;C:\test.snk&quot;)) //产生强名，才可以直接引用，并使用using }; //在当前应用程序域中创建一个新的程序集 AssemblyBuilder asm = app.DefineDynamicAssembly(asmName, AssemblyBuilderAccess.Save); //因为是单文件程序集，模块的名字就是程序集的名字 ModuleBuilder module = asm.DefineDynamicModule(&quot;MyAssembly&quot;, &quot;MyAssembly.dll&quot;); //定义一个公共类 TypeBuilder myClass = module.DefineType(&quot;MyAssembly.HelloWorld&quot;, TypeAttributes.Public); //定义一个私有字符串成员变量 FieldBuilder strField = myClass.DefineField(&quot;theMessage&quot;, typeof(string), FieldAttributes.Private); //创建自定义的构造函数 ConstructorBuilder ctor = myClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] { typeof(string) }); ILGenerator ilCtor = ctor.GetILGenerator(); ilCtor.Emit(OpCodes.Ldarg_0); ConstructorInfo superCtor = typeof(object).GetConstructor(new Type[0]); ilCtor.Emit(OpCodes.Call, superCtor); //调用基类构造函数 ilCtor.Emit(OpCodes.Ldarg_0); //压栈对象的this指针 ilCtor.Emit(OpCodes.Ldarg_1); //压栈参数 ilCtor.Emit(OpCodes.Stfld, strField); //存储在this的strField ilCtor.Emit(OpCodes.Ret); //创建默认构造函数 myClass.DefineDefaultConstructor(MethodAttributes.Public); //创建GetMsg()方法 MethodBuilder getMsg = myClass.DefineMethod(&quot;GetMsg&quot;, MethodAttributes.Public, typeof(string), null); ILGenerator ilMethod = getMsg.GetILGenerator(); ilMethod.Emit(OpCodes.Ldarg_0); ilMethod.Emit(OpCodes.Ldfld, strField); ilMethod.Emit(OpCodes.Ret); //创建SayHello()方法 MethodBuilder sayHello = myClass.DefineMethod(&quot;SayHello&quot;, MethodAttributes.Public); ilMethod = sayHello.GetILGenerator(); ilMethod.EmitWriteLine(&quot;Hello World!&quot;); ilMethod.Emit(OpCodes.Ret); //创建类Hello World myClass.CreateType(); //保存程序集 asm.Save(&quot;MyAssembly.dll&quot;); } } 第六部分：.NET基础类库应用程序域和线程一个应用程序域可以承载多个线程，线程可以跨越不同的应用程序域 AppDomain ad=Thread.GetDomain(); 获取正在承载当前线程的应用程序域 Context ctx=Thread.CurrentContext; 获取当前操作线程所处的上下文 委托的异步性class Program { public delegate int MyMethod(int x, int y); private static bool isDone = false; static void Main(string[] args) { Console.WriteLine(&quot;Main，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId); MyMethod m = Add; IAsyncResult ar = m.BeginInvoke(10, 10, AddComplete, &quot;R U Ok?&quot;); //开启异步，使用的是线程池的工作者线程（后台线程） //轮询方式 //while (!ar.AsyncWaitHandle.WaitOne(1000,true)) //{ // Console.WriteLine(&quot;Working...&quot;); //} //回调方式 while (!isDone) { Thread.Sleep(1000); Console.WriteLine(&quot;Working...&quot;); } Console.ReadKey(); } static int Add(int x, int y) { Console.WriteLine(&quot;Add，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(3000); return x + y; } static void AddComplete(IAsyncResult result) { Console.WriteLine(&quot;Complete，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId + &quot;，Msg&quot; + result.AsyncState); AsyncResult ar = (AsyncResult)result; MyMethod m = (MyMethod)ar.AsyncDelegate; Console.WriteLine(&quot;Result：&quot; + m.EndInvoke(result)); isDone = true; } } Threading命名空间 AutoResetEvent类线程同步的通知类 public static AutoResetEvent waitHandle = new AutoResetEvent(false); //阻塞一个线程，直到收到通知 waitHandle.WaitOne(); //通知一个或多个线程事件终止，允许继续 waitHandle.Set(); TimerCallBack定时任务 static void Main(string[] args) { Timer t = new Timer(Print, &quot;时间：&quot;, 0, 1000); Console.ReadKey(); } static void Print(object state) { Console.Clear(); Console.WriteLine(state + DateTime.Now.ToLongTimeString()); } ThreadPool的好处1，减少了线程创建、开始和停止的次数，这提高了效率2，能够使我们将注意力放到业务逻辑上而不是多线程架构上 某些情况仍应优先使用手工线程管理：1，需要前台线程或设置优先级别，线程池中的线程总是后台线程，优先级是默认的。无法修改2，需要一个带有固定标识的线程便于退出、挂起或通过名字发现它。 Parallel类class Program { private static CancellationTokenSource cts = new CancellationTokenSource(); static void Main(string[] args) { string filePath = @&quot;C:\Pictures&quot;; string[] files = Directory.GetFiles(filePath, &quot;*.jpg&quot;, SearchOption.TopDirectoryOnly); string newPath = @&quot;C:\Pictures\new&quot;; if (!Directory.Exists(newPath)) { Directory.CreateDirectory(newPath); } //并行方式 ParallelOptions option = new ParallelOptions { CancellationToken = cts.Token, MaxDegreeOfParallelism = System.Environment.ProcessorCount }; try { //主线程仍然被阻塞，等待其他线程完成工作 Parallel.ForEach(files, option, m =&gt; { option.CancellationToken.ThrowIfCancellationRequested(); string fileName = Path.GetFileName(m); using (Bitmap map = new Bitmap(m)) { map.RotateFlip(RotateFlipType.RotateNoneFlipX); //左右翻转 map.Save(Path.Combine(newPath, fileName)); Console.WriteLine(&quot;Id：&quot; + Thread.CurrentThread.ManagedThreadId); } }); } catch (Exception e) { //处理 } Console.WriteLine(&quot;等待中...（最后才显示）&quot;); Console.ReadKey(); } } Parallel.Invoke(() =&gt; { var ret = DoSomething(); }, () =&gt; { var ret = DoAnthor(); }); 次线程访问UI线程的控件this.Invoke((Action)delegate { this.Text=....; }); WinForm中，线程创建的控件具有“线程相关性”。次线程不能直接访问主线程（UI线程）创建的控件，可以通过此方法传递异步委托执行。 async await关键字class Program { static void Main(string[] args) { Console.WriteLine(&quot;Main Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 new Program().Entry(); Console.WriteLine(&quot;等待中...&quot;); //先出现 Console.WriteLine(&quot;Main Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 Console.ReadKey(); } public async Task&lt;string&gt; DoItAsync() //约定以Asynv后缀 { Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 var r = await Task.Run(() =&gt; //开启新线程，主线程在执行完await标记的代码（Task.Run创建新线程部分，不包含内部的委托部分）后跳出 { Thread.Sleep(3000); Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 return &quot;haha&quot;; }); Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 return r; } public async void Entry() { Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 string ret = await DoItAsync(); //await 负责提取包含在Task对象中的内在返回值。 //主线程把具有await标记的DoIt() 执行完毕之后，跳出此方法到调用处继续执行。 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 Console.WriteLine(ret); } } 返回void的异步方法返回非泛型的Task类，并忽略return private asynv Task MethodVoidAsync() { await Task.Run(() =&gt; { //... } } 多个await的异步方法public async void Entry() { //调用者线程 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //调用者跳出返回，开启新线程1 await Task.Run(() =&gt; Thread.Sleep(3000)); //新线程1 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程1销毁，开启新线程2 await Task.Run(() =&gt; Thread.Sleep(3000)); //下同 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); await Task.Run(() =&gt; Thread.Sleep(3000)); Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); } System.IO 获取计算机上驱动器的细节DriveInfo[] drives = DriveInfo.GetDrives(); StreamWriter和StreamReaderusing (StreamWriter writer = File.CreateText(&quot;1.txt&quot;)) { writer.WriteLine(&quot;hahaha&quot;); writer.WriteLine(&quot;hahaha&quot;); writer.Write(writer.NewLine); } 等于 using (StreamWriter writer=new StreamWriter(&quot;1.txt&quot;)) { } using (StreamReader reader = File.OpenText(&quot;1.txt&quot;)) { string buffer; while ((buffer = reader.ReadLine()) != null) { Console.WriteLine(buffer); } } 等于 using (StreamReader reader=new StreamReader(&quot;1.txt&quot;)) { } BinaryWriter类允许我们从基层流中以简洁的二进制格式读取或写入离散数据类型 using (BinaryWriter bw=new BinaryWriter(File.OpenWrite(&quot;1.txt&quot;))) { Console.WriteLine(&quot;Type：&quot;+bw.BaseStream); bw.Write(&apos;1&apos;); bw.Write(&quot;123&quot;); bw.Write(123); bw.Write(12.3); } using (BinaryReader br=new BinaryReader(File.OpenRead(&quot;1.txt&quot;))) { Console.WriteLine(br.ReadString()); //只有&quot;123&quot; } 文件监视FileSystemWatcher watcher = new FileSystemWatcher { Path = Directory.GetCurrentDirectory(), Filter = &quot;*.txt&quot;, NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName }; watcher.Changed += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Created += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Deleted += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Renamed += (o, e) =&gt; Console.WriteLine(e.OldFullPath + &quot;\t&quot; + e.FullPath); watcher.EnableRaisingEvents = true; 对象序列化[Serializable] class Program { public string Name { get; set; } static void Main(string[] args) { Program p = new Program { Name = &quot;Main&quot; }; BinaryFormatter format = new BinaryFormatter(); using (var stream = File.OpenWrite(&quot;1.txt&quot;)) { format.Serialize(stream, p); } using (var stream = File.OpenRead(&quot;1.txt&quot;)) { Program p1 = (Program)format.Deserialize(stream); Console.WriteLine(p1.Name); } Console.ReadKey(); } } 对象图 持久化对象的格式using System.Runtime.Serialization.Formatters.Binary; using System.Xml.Serialization; using System.Runtime.Serialization.Formatters.Soap; XmlSerializer和SoapFormatterXmlSerializer:持久化为XML文档，只会保存公有已赋值字段或公共属性。可以保存偏好设置（颜色，文字大小等）SoapFormatter:持久化为一个SOAP消息（传递消息到Web服务或从Web服务传递消息的标准XML格式） static void Main(string[] args) { List&lt;Picture&gt; list = new List&lt;Picture&gt; { new Picture{ Id=0,Url=&quot;1.jpg&quot;}, new Picture{ Id=1,Url=&quot;2.jpg&quot;} }; XmlSerializer format = new XmlSerializer(typeof(List&lt;Picture&gt;), &quot;Carousels&quot;); 或 SoapFormatter format = new SoapFormatter(); using (var stream = File.OpenWrite(&quot;config.xml&quot;)) //从头覆盖内容，不会重建文件 或 using (var stream = new FileStream(&quot;config.xml&quot;, FileMode.Create, FileAccess.Write, FileShare.None)) //重建文件 { format.Serialize(stream, list); } using (var stream = File.OpenRead(&quot;config.xml&quot;)) { List&lt;Picture&gt; p1 = (List&lt;Picture&gt;)format.Deserialize(stream); p1.ForEach(m =&gt; Console.WriteLine(&quot;/images/&quot; + m.Url)); } Console.ReadKey(); } [Serializable] public class Picture { private int size; //XmlSerializer不会包含 public string Name = &quot;轮播图&quot;; public int Id { get; set; } public string Url { get; set; } } 格式化程序中的类型保真BinaryFormatter，持久化对象图中对象的字段数据，和每个类型的完全限定名城和定义程序集的完整名称（强名）。这些数据使跨越.NET应用程序机器边界传递对象成为理想的选择。SoapFormatter，XmsSerializer，没有序列化完整的.NET类型元数据（完全限定名称或程序集），可用于标准的.NETWeb服务，可被任何平台中的客户端调用（Windows、MAC OS X和Linux）。 控制生成的XML数据static void Main(string[] args) { Picture pic = new Picture { Id = 1, Url = &quot;2.jpg&quot;, Date = DateTime.Now.ToShortDateString(), Details = new List&lt;string&gt; {&quot;遍&quot;, &quot;历&quot; } }; XmlSerializer format = new XmlSerializer(typeof(Picture)); using (var stream = new FileStream(&quot;config.xml&quot;, FileMode.Create, FileAccess.Write, FileShare.None)) { format.Serialize(stream, pic); } using (var stream = File.OpenRead(&quot;config.xml&quot;)) { Picture p1 = (Picture)format.Deserialize(stream); } Console.ReadKey(); } [Serializable, XmlType(TypeName = &quot;SinglePicture&quot;)] public class Picture { public int Id { get; set; } public string Url { get; set; } [XmlEnum] public List&lt;string&gt; Details; [XmlAttribute] public string Date { get; set; } } 生成的XML部分如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;SinglePicture xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; Date=&quot;2017/4/15&quot;&gt; &lt;Details&gt; &lt;string&gt;遍&lt;/string&gt; &lt;string&gt;历&lt;/string&gt; &lt;/Details&gt; &lt;Id&gt;1&lt;/Id&gt; &lt;Url&gt;2.jpg&lt;/Url&gt; &lt;/SinglePicture&gt; 使用特性定制序列化[Serializable] public class Picture { public int Id { get; set; } public string Url { get; set; } public string Name { get; set; } [OnSerializing] private void OnSerializing(StreamingContext context) { Name += &quot; Date:&quot; + DateTime.Now.ToShortDateString(); } [OnDeserialized] private void OnDeserialized(StreamingContext context) { Url = Url.ToLower(); Name = Name.ToUpper(); } }]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#高级编程_注释笔记]]></title>
    <url>%2F2017%2F04%2F04%2FC-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Type类型var i = 2.0; var t1 = i.GetType(); var t2 = i.GetTypeCode(); Console.WriteLine(&quot;类型：&quot; + t1 + &quot;，类型码：&quot; + t2 + &quot;，类型码的值：&quot; + (int)t2); 输出：类型：System.Double，类型码(enum)：Double，类型码的值：14 var t = typeof(Person); Console.WriteLine(t.Assembly); Console.WriteLine(t.Attributes); Console.WriteLine(t.BaseType); Console.WriteLine(t.FullName); Console.WriteLine(t.GetProperties()[0].Name); Console.WriteLine(t.GUID); Console.WriteLine(t.Name); Console.WriteLine(t.Namespace); Person p1 = new Person(); if (p1.GetType()==t) Console.WriteLine(&quot;Ok&quot;); Type的成员方法GetConstructor[s]() //返回ConstructorInfo GetEvent[s]() //返回EventInfo GetField[s]() //返回FieldInfo Get[Default]Member[s]() //返回MemberInfo GetMethod[s]() //返回MethodInfo GetProperty[s]() //返回PropertyInfo Assembly和TypeAssembly ass = Assembly.Load(&quot;ConsoleApplication1&quot;); Type t = typeof(Book); var b = ass.CreateInstance(t.FullName); var b1 = ass.CreateInstance(&quot;ConsoleApplication1.Book&quot;); 程序集dll，逻辑单元。包含模块，资源等。程序集强名：共享程序集使用强名唯一地标识该程序集，保证全局唯一，包括： 程序集本身的名称 版本号。不同版本可以共存于一个进程。 公钥。保证独一无二。 文化 应用程序域图解 不同域加载程序集namespace AssemblyA { // [Serializable]//只序列化，则仍由调用应用域访问 public class Demo : MarshalByRefObject //继承这个基类（已序列化），才能通过另一个应用程序域来访问。 { public Demo() { } public Demo(int val1, int val2) { Console.WriteLine(&quot;domain：{0}中带有参数{1}和{2}的构造函数被调用&quot;, AppDomain.CurrentDomain.FriendlyName, val1, val2); } public void DoSome() { Console.WriteLine(&quot;domain：{0}调用方法DoSome&quot;, AppDomain.CurrentDomain.FriendlyName); } } class Program { static void Main(string[] args) { Console.WriteLine(&quot;domain：{0}的主函数被调用&quot;, AppDomain.CurrentDomain.FriendlyName); } } } namespace AssemblyB { class Program { static void Main(string[] args) { Console.WriteLine(&quot;当前域：&quot; + AppDomain.CurrentDomain.FriendlyName); AppDomain firstDomain = AppDomain.CreateDomain(&quot;First AppDomain&quot;); firstDomain.ExecuteAssemblyByName(&quot;AssemblyA&quot;); //需要添加引用或复制程序集，执行exe形式的程序集 firstDomain.ExecuteAssembly(&quot;AssemblyA.exe&quot;); //上方主函数被调用 AppDomain secondDomain = AppDomain.CreateDomain(&quot;Second AppDomain&quot;); var ret = secondDomain.CreateInstance(&quot;AssemblyA&quot;, &quot;AssemblyA.Demo&quot;, true, BindingFlags.CreateInstance, null, new object[] { 7, 3 }, null, null); //上方Demo类构造函数被调用 var obj = (Demo)ret.Unwrap(); //解除包装 obj.DoSome(); //实例化程序集中的类的示例 Demo demo = (Demo)secondDomain.CreateInstanceAndUnwrap(&quot;AssemblyA&quot;, &quot;AssemblyA.Demo&quot;); demo.DoSome(); //显示：Second AppDomain调用方法DoSome //适用：如果程序集是动态加载的，用完后卸载。 //主应用程序域中，无法删除已加载程序集。但可以终止应用程序域，该域中加载的程序集会从内存中清楚。 AppDomain.Unload(secondDomain); //string fullName = namespaceName + &quot;.&quot; + Controller + &quot;Controller&quot;; //object obj = Assembly.Load(assemblyName).CreateInstance(fullName); //result = (ServerController)obj; Console.ReadKey(); } } } 当前域加载程序集//动态加载程序集，创建实例 //配合接口降低耦合，也可以逆向引用调用对象方法 string fullName = &quot;AssemblyA.Demo&quot;; object obj = Assembly.Load(&quot;AssemblyA&quot;).CreateInstance(fullName); var result = (Demo)obj; result.DoSome(); 方法和函数函数&gt;方法。函数包括：方法，非数据成员：索引器，构造函数，析构函数，属性。 构造函数初始化器public Car(string des) : this(des , 4) { //... } public Car(string des,int wheel) { //... } 实现构造函数之间的重用: this 或: base 之后的构造函数先执行，然后再执行此构造函数。 partial关键词编译时，两个不分类的属性，XML注释，接口，泛型类型的参数属性，特性和成员会合并。 泛型中的default关键字初始化泛型参数T时，可以使用detault(T)。在不知道T是引用类型还是值类型的情况下，分别赋予引用类型null或者值类型0 委托类似于C++中的函数指针（但类型不安全，参数和返回值未知）面向对象编程，没有方法是孤立的。如果要传递方法， 就要把方法细节（签名和返回类型）封装在一种新类型对象中，即委托。委托是一种特殊对象，普通对象都包含数据，而委托包含的只是一个或多个方法的地址（指针）。 委托的定义和使用：（面向对象的角度） 定义一个委托（类似定义一个类）private delegate string GetAString(); 实例化一个GetAString的委托实例（实例化一个对象）。委托语法上总是接收一个参数的构造函数。GetAString me=new GetAString(x.ToString);或者委托推断：GetAString me=x.ToString; me();或者me.Invoke();编译器会用me.Invoke()；代替me()； 浅表复制，深度复制浅表复制，成员对象，直接复制引用。成员值，创建值副本。深度复制，成员对象，创建副本。成员值，创建值副本。[Serializable] //可被序列化，实现深度复制 public class CloneDemo // : ICloneable，可继承接口，实现方法复制 { public int State { get; set; } public StateObject innerObj { get; set; } [Serializable] public class StateObject { public int InnerState { get; set; } } public CloneDemo() { State = 1; innerObj = new StateObject { InnerState = 1, }; } //浅表复制 public CloneDemo ShadowClone() { return this.MemberwiseClone() as CloneDemo; } //深度复制 public CloneDemo DeepClone() { using (var stream = new MemoryStream()) { var formatter = new BinaryFormatter(); formatter.Serialize(stream, this); stream.Seek(0, SeekOrigin.Begin); return formatter.Deserialize(stream) as CloneDemo; } } } class Program { static void Main(string[] args) { var demo = new CloneDemo(); var shadow = demo.ShadowClone(); var deep = demo.DeepClone(); Console.WriteLine(&quot;demo：属性State = {0}，引用innerObj.State = {1}&quot;, demo.State, demo.innerObj.InnerState); Console.WriteLine(&quot;shadow：属性State = {0}，引用innerObj.State = {1}&quot;, shadow.State, shadow.innerObj.InnerState); Console.WriteLine(&quot;deep：属性State = {0}，引用innerObj.State = {1}&quot;, deep.State, deep.innerObj.InnerState); demo.State = -1; demo.innerObj.InnerState = -1; Console.WriteLine(&quot;====================\n分别对属性和引用赋值...\n====================&quot;); Console.WriteLine(&quot;demo：属性State = {0}，引用innerObj.State = {1}&quot;, demo.State, demo.innerObj.InnerState); Console.WriteLine(&quot;shadow：属性State = {0}，引用innerObj.State = {1}&quot;, shadow.State, shadow.innerObj.InnerState); Console.WriteLine(&quot;deep：属性State = {0}，引用innerObj.State = {1}&quot;, deep.State, deep.innerObj.InnerState); Console.ReadKey(); } } Array抽象类Type t=...; Array intArr=Array.CreateInstance(typeof(t),5); intArr.SetValue(33,2); intArr.GetValue(2); 事先不知类型，可由此创建数组。 Array.Sort(数组,IComparer 比较器); EnumeratorGetEnumerator()方法用IEnumerable接口定义。foreach语句并不真的需要集合实现这个接口。有一个名为GetEnumerator()的方法，返回实现了IEnumerator接口的对象就行了。 IEnumerator接口定义了Reset()方法，以与COM交互操作。 foreach解析为下面的代码段： var enumerator = list.GetEnumerator(); while (enumerator.MoveNext()) { var item = enumerator.Current; if (item != null) { Console.WriteLine(item.Name); } } yield语句包含yield语句的方法或属性也成为迭代块。必须声明为返回IEnumerator或IEnumerable接口。可包含yield return或yeild break，不能有return语句。使用迭代块，编译器会生成一个yield类型，包含一个状态机。记录了迭代的当前位置。foreach访问迭代器，一次访问一个。无需一次加载完所有数据。 可以把yeild类型看作内部类Enumerator。 class My { public class Enumerator : IEnumerator&lt;string&gt;, IEnumerator, IDisposable { private int state; public string Current { get; private set; } public void Dispose() {...} public bool MoveNext() {...} public void Reset() {...} object IEnumerator.Current {get{return Current;}} } } 默认迭代是：定义为返回Enumerator的GetEnumerator()方法，是foreach默认采用的方法。自定义命名迭代返回IEnumerable。 集合特性 IEnumerabel：GetEnumerator()，返回一个实现了IEnumerator接口的枚举。可以被foreach。 ICollection：由泛型集合实现。Count属性。CopyTo()方法（把集合复制到数组中）。Add()，Remove()，Clear()方法。 IList：派生自ICollection。定义了索引器，可通过指定位置，Insert()或RemoveAt()。 ISet：派生自ICollection。由集实现。合并，交集，并集。 IDictionary：键值集合。索引器。 ILookup：一个键包含多个值。 IComparer：比较器实现。Compare()对集合中的元素排序。 IEqualityComparer：比较器，数组，元祖实现。该比较器可用于字典中的键。 IProducerConsumerCollection：.NET4.0。支持新的线程安全的集合类。 IReadOnlyCollection，IReadOnlyList，IReadOnlyDictionary：初始化后不能修改的，只能检索。 IImmutableArray，IImmutableList，IImmutableQueue，IImmutableSet，IImmutableDictionary：初始化后不能修改。不可变接口定义了不可变集合的方法和属性。 队列先进先出（FIFO）容器。 Queue ，先进先出（FIFO）。Enqueue()，一端添加元素。Dequeue()，另一端读取和删除元素。Peek()，从头部读取一个元素，但不删除。 栈后进先出（LIFO）容器。 Push()，添加元素。Pop()获取最近添加的元素。Peek()，返回栈顶的元素，但不删除它。 Lookup类一键对多值 List&lt;Book&gt; list = new List&lt;Book&gt; { new Book() { Title = &quot;b1&quot;, Price = 1 }, new Book() { Title = &quot;b2&quot;, Price = 2 }, new Book() { Title = &quot;a2&quot;, Price = 2 } }; var bookLk = list.ToLookup(p =&gt; p.Price); foreach (var item in bookLk[2]) { Console.WriteLine(item.Title); } 集HashSet 不重复无序，SortedSet 不重复有序 aSet.Add() //是否成功添加了元素。 aSet.IsSubsetOf(bSet) //a是否是b的子集（b包含a所有元素） bSet.IsSupersetOf(aSet) //b是否是a的超集（b包含a所有元素） aSet.Overlaps(bSet) //a与b是否共享某元素。（重叠） aSet.UnionWith(bSet) //向a中加入b所有的元素。 aSet.ExceptWith(bSet) //从a中删除b拥有的元素 Immutable不可变集合，需要引用System.Collections.Immutable（.NET4.5） ImmutableList&lt;string&gt;.Add(&quot;&quot;) //每次返回一个新的不变集合，不改变本身。 var build=imList.ToBuild() //构建器。返回一个可变集合。可以进行.Add()，.Remove()等。 build.ToImmutable() //返回一个变动后的不可变集合。 并发集合 IProducerConsumerCollectionTryAdd(),和TryTake()。 ConcurrentQueue免锁定，内部链表。TryTake(),Enqueue(),TryDequeue(),TryPeek() ConcurrentStack链表。Push(),TryPeek(),TryPop(),TryPopRange() ConcurrentBag没有定义添加或提取项的任何顺序，线程映射到内部使用的数组，尝试减少锁定。 ConcurrentDictionary线程安全，非阻塞键值集合。TryGetValue(),TryRemove(),TryUpdate()。没有实现IProducerConsumerCollection。 BlockingCollection阻塞线程。Add(),Take()。 dynamic类型dynamic类型允许编写忽略编译期间的类型检查代码。var对象类型的确定会延迟，确定后不可变。dynamic类型可以改变多次。int-&gt;string-&gt;object async只能用于返回Task或void的方法。不能作为程序的入口点。 Task启动Task的3种方式： 1. Action act = () =&gt; { Console.WriteLine(&quot;任务开始&quot;); Thread.Sleep(2000); }; Task t = new Task(act); t.Start(); 2. Task t = Task.Factory.StartNew(act); 3. Task t = Task.Run(act); //对Factory的封装 //完成通知，回调 t.ContinueWith(task =&gt; { Console.WriteLine(&quot;完成状态&quot;); Console.WriteLine(&quot;IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}&quot;, task.IsCanceled, task.IsCompleted, task.IsFaulted); }); Task组合器 Task.WhenAll(t1,t2)等待，直到全部任务都完成。 Task.WhenAny(t1,t2)等待，直到其中一个任务完成就会返回。 应用CancellationTokenSource，取消Taskstatic void Main(string[] args) { var cts = new CancellationTokenSource(); Task&lt;int&gt; t = new Task&lt;int&gt;(() =&gt; Add(cts.Token), cts.Token); t.Start(); t.ContinueWith(TaskEnded); Console.ReadKey(); cts.Cancel(); Console.ReadKey(); } static void TaskEnded(Task&lt;int&gt; task) { Console.WriteLine(&quot;完成&quot;); Console.WriteLine(&quot;IsCanceled:{0},IsCompleted:{1},IsFaulted:{2}&quot;, task.IsCanceled, task.IsCompleted, task.IsFaulted); ①Console.WriteLine(&quot;返回值：&quot; + task.Result); ②try { Console.WriteLine(&quot;返回值:&quot; + task.Result); } catch (AggregateException e) { var errs = e.InnerExceptions; //与组合器配合，获取所有任务异常。 e.Handle(err =&gt; err is OperationCanceledException); } } static int Add(CancellationToken token) { Console.WriteLine(&quot;任务开始&quot;); int result = 0; ①while (!token.IsCancellationRequested) { result++; Thread.Sleep(1000); } ②③while (true) { result++; Thread.Sleep(1000); ②token.ThrowIfCancellationRequested(); ③if (result == 5) { throw new Exception(&quot;error&quot;); } } return result; } PS：Task t=… ，有返回参数才有①t.Result属性。任务完成则,IsCompleted:true。不论是否异常。①进行逻辑判断，任务正常结束后，进入TaskEnded，结果：IsCanceled:false,IsFaulted:false②通过抛AggregateException异常，立即结束任务，进入TaskEnded，结果：IsCanceled:true,IsFaulted:false③通过抛自定义异常，立即结束任务，进入TaskEnded，结果：IsCanceled:false,IsFaulted:true 虚拟寻址系统32位处理器上的每个进程都可以使用4GB的内存，无论计算机实际有多少物理内存。（64位更大）。包含了：可执行代码，dll，变量等 栈（stack）栈指针指向为栈保留的内存块末尾。栈实际上是向下填充的。即从高内存地址向低内存地址填充。数据入栈后，指针调整，始终指向下一空闲存储单元。数据释放（变量超出作用域），指针向上递增。变量的生存期总是嵌套的，保证了栈指针是有序的。 堆（heap）堆上的内存是向上分配的。空闲空间在已用空间的上面。 垃圾回收gc运行时，会从堆中删除不再引用的所有对象。只要释放了能释放的所有对象，它就把其他对象移动回堆的端部。再次形成一个连续的内存块。因此，堆可以确定在什么地方存储新对象。对象移动后，需要新地址更新引用，gc会处理更新问题。 大对象堆不同于主堆，存储使用大于85000个字节对象。压缩大对象比较昂贵。故大对象对上的对象不执行压缩过程。 第二代和大对象堆上的回收放在后台线程执行，应用程序仅为第0代和第1代回收而阻塞，减少了暂停时间。 非托管资源文件句柄，网络连接，数据库连接等。 托管资源栈，堆上的数据。 析构函数C#不常使用，无法确定执行时机。有析构函数的对象需要两次处理才能销毁。析构函数运行时间长，非常耗性能。 IDisposable接口C#推荐IDisposable接口替代析构函数。声明Dispose()，释放非托管资源。控制更精准。如果显式调用需要try,catch,防止异常而没有执行。代替用using()语句，更简单。 unsafe代码块unsafe可以修饰 类成员方法等。标记为不安全代码，可以使用指针语法提高性能。但带来不安全性和不方便等。 指针语法int x=10; int* pX,pY; pX= &amp;x; pY=px; *pY=20; 结果：x内容改为20。pY与x中间没有任何关系，pY碰巧指向存储x的存储单元。//pX，pY也占用4个字节，因为32位处理器上，4个字节存储一个地址。&amp;表示取地址，把一个值类型转换为指针。*表示获取地址的内容，把一个指针转换为值类型。 强制转换： uint y=(uint)pX; int pD=(int)y; 自定义特性[FieldName(&quot;xxx&quot;)] //FieldNameAttribute，Attribute可以省略，自动添加。搜索指定名称的类，实例化。 [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, //引用在哪些元素上，或的关系 AllowMultiple=false, //是否可以多次应用在同一元素 Inherited=false)] //自动应用到派生类或接口，重写的方法等 public class FieldNameAttribute: Attribute { public string Comment {get;set;} private string name; public FieldNameAttribute(string name) { this.name=name; } } 使用： [FieldName(&quot;xxx&quot;,Comment=&quot;xxx&quot;)] public string Func { ... } Exception 属性Data，可以添加的额外信息字典。HelpLink，连接帮助文件上。InnerException，如异常在catch中抛出，则inner为把代码发送到catch块的异常对象。Source，导致异常程序或对象名。StackTrace，调用栈信息。TargetSite，抛出异常的方法的反射对象。 .ReflectedType获得类的Type对象。 调用者特性public class Book { public string Title { get; set; } public decimal Price { get; set; } public void Log([CallerLineNumber] int line = 0, [CallerFilePath] string path = &quot;&quot;, [CallerMemberName] string name = &quot;&quot;) { //Do with line,path,name... 包括调用者的信息 } } Book b = new Book(); b.Log(); ThreadPoolBook b = new Book() { Title = &quot;t&quot;, Price = 1 }; ThreadPool.QueueUserWorkItem(i =&gt; { Book b1 = i as Book; Console.WriteLine(&quot;书名&quot; + b1.Title + &quot;价格&quot; + b1.Price); }, b); 线程池的限制 线程池中的所有线程都是后台线程。并且不能把入池的线程改为前台线程。 不能设置池中线程的优先级或名称。 所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）线程。 入池的线程只能用于时间短的任务。如果需要一直运行（如word拼写检查），应创建Thread或Task使用LongRunning选项。 控制线程var t1 = new Thread(() =&gt; { }); t1.Priority = ThreadPriority.Highest; //优先级，优先调用。可能影响其他线程 t1.Abort(); //停止线程，抛出异常 t1.Join(2000); //阻塞 Interlocked类速度快，简单的同步问题。原子操作。 Interlocked.CompareExchange(); Interlocked.Increment(); Monitor类lock语句会被编译器解析成以下代码： object obj = new object(); Monitor.Enter(obj); try { //线程同步区域 } finally { Monitor.Exit(obj); } Monitor的好处是可以指定等待时间： bool lockToken = false; Monitor.TryEnter(obj, 500, ref lockToken); if (lockToken) { try { //线程同步区域 } finally { Monitor.Exit(obj); } } else { //做其他的事情 } 读写互斥锁class Program { private static List&lt;int&gt; items = new List&lt;int&gt;() { 0, 1, 2, 3, 4, 5, 6 }; private static ReaderWriterLockSlim rwl = new ReaderWriterLockSlim(); static void ReaderMethod(object reader) { try { rwl.EnterReadLock(); //如果该锁是读取模式，则读取线程直接进入。累计数+1 for (int i = 0; i &lt; items.Count; i++) { Console.WriteLine(&quot;reader {0},loop {1},item {2}&quot;, reader, i, items[i]); } } finally { rwl.ExitReadLock(); //读取线程退出，累计数-1。为0时退出读取模式 } } static void WriterMethod(object writer) { try { //Thread.Sleep(100); //如果写入线程等待，则全部读取的线程会先执行完。否则就抢 while (!rwl.TryEnterWriteLock(50)) //如果取得写入锁，则进入独占写入模式。 { Console.WriteLine(&quot;writer {0} 等待取写入锁&quot;, writer); Console.WriteLine(&quot;当前读者个数&quot; + rwl.CurrentReadCount); } Console.WriteLine(&quot;writer {0} 取得写锁&quot;, writer); for (int i = 0; i &lt; items.Count; i++) { items[i]++; Thread.Sleep(50); } Console.WriteLine(&quot;writer {0} 写入完毕&quot;, writer); } finally { rwl.ExitWriteLock(); //退出独占写入模式，读写线程开始抢锁 } } static void Main(string[] args) { var taskFac = new TaskFactory(TaskCreationOptions.LongRunning, TaskContinuationOptions.None); for (int i = 0; i &lt; 6; i++) { if (i==1 || i==4) { taskFac.StartNew(WriterMethod, i); } else { taskFac.StartNew(ReaderMethod, i); } } Console.ReadKey(); } }]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First设计模式_注释笔记]]></title>
    <url>%2F2017%2F02%2F27%2FHead-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[设计原则 把可能变化之处独立出来，以免影响固定代码。 针对接口编程，而不是针对实现编程 多用组合，少用继承 设计交互对象之间的松耦合 扩展-关闭原则：类应该对扩展开发，对修改关闭。 依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 好莱坞原则：高层组件对待低层组件的方式：别调用我们，我们会调用你。避免高层和低层出现明显的环装依赖 一个类应该只有一个引起变化的原因。高内聚，低耦合。（单一职责） 备注7： //采用 public int GetCount() { return target.GetCount(); //只认识target } //不采用 public int GetCount() { var obj=target.GetObj(); //多认识（依赖）了一个对象 return obj.GetCount(); } PS：如果某对象是调用其他方法的返回结果，不要调用它的方法。意味着，不清楚他的方法细节。并不认识此对象，也就不依赖它。 针对接口（超类型）编程针对实现： Dog d=new Dog(); d.bark(); 针对接口： Animal a=new Dog(); a.makeSound(); 运行时 Animal a=getAnimal(); a.makeSound(); 策略模式定义定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。 类图 观察者模式定义定义了对象间的一对多依赖（订阅），这样依赖，当一个对象改变时，它的所有依赖者都会受到通知并更新。Subject主题，Observer观察者。 类图 代码示例PS：另可以用多播委托实现此过程。 public class DeleteAction : IDisposable { private readonly Action _onDispose; public DeleteAction(Action onDispose) { _onDispose = onDispose; } public void Dispose() { _onDispose(); } } public class Msg { public string Name { get; set; } } public class Report : IObservable&lt;Msg&gt; { private List&lt;IObserver&lt;Msg&gt;&gt; os = new List&lt;IObserver&lt;Msg&gt;&gt;(); public void Notify(string msg) {os.ForEach(o =&gt; { o.OnNext(new Msg { Name = msg }); o.OnCompleted(); });} public IDisposable Subscribe(IObserver&lt;Msg&gt; observer) { os.Add(observer); return new DeleteAction(() =&gt; { os.Remove(observer); }); } public void Err() {os.ForEach(o =&gt; { o.OnError(new Exception(&quot;自定义错误！&quot;)); });} } public class Screen : IObserver&lt;Msg&gt; { public int Id { get; set; } public Screen(int id) { Id = id; } public void OnNext(Msg value) {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，信息为：&quot; + value.Name);} public void OnError(Exception error) {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，错误！信息：&quot; + error.Message);} public void OnCompleted() {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，完成！&quot;);} } class Program { static void Main(string[] args) { Report re = new Report(); Screen s1 = new Screen(1); Screen s2 = new Screen(2); var o1 = re.Subscribe(s1); var o2 = re.Subscribe(s2); re.Notify(&quot;哎呀&quot;); o1.Dispose(); re.Notify(&quot;少人&quot;); } } 装饰者模式定义动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 类图 代码示例public abstract class Phone { public abstract void Ring(); public abstract decimal GetPrice(); } public class Apple : Phone //被装饰者 { public override void Ring() { Console.WriteLine(&quot;这是苹果手机...&quot;); } public override decimal GetPrice() { return 4500; } } public abstract class Decorator : Phone //装饰者 { protected Phone p; //被装饰者引用 protected Decorator(Phone p) { this.p = p; } } public class Sticker : Decorator { public Sticker(Phone p) : base(p) { } public override void Ring() { p.Ring(); //被装饰者行为 AddSticker(); //新增行为/责任 } public override decimal GetPrice() {return p.GetPrice() + 1.5m;} public void AddSticker() {Console.WriteLine(&quot;加了贴膜！&quot;);} } static void Main(string[] args) { Phone m = new Apple(); m = new Sticker(m); m = new Sticker(m); //贴了2层 m = new Accessories(m); m.Ring(); Console.WriteLine(&quot;当前价格为：&quot; + m.GetPrice()); Console.ReadKey(); } 角色抽象构件（Phone）角色：给出一个抽象接口，以规范准备接受附加责任的对象。具体构件（AppPhone）角色：定义一个将要接收附加责任的类。装饰（Dicorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。具体装饰（Sticker和Accessories）角色：负责给构件对象 ”贴上“附加的责任。 理解优点：装饰者模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合装饰者模式有很好地可扩展性缺点：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。 适配器模式定义将一个类的接口，转换成客户（使用者）期望的另一个接口。适配器让原本不兼容的类可以合作无间。 类图 代码示例public interface IDuck { void Quack(); } public interface ITurkey { void SpecialQuack(); } public class Duck : IDuck //鸭子类 { public void Quack() { Console.WriteLine(&quot;鸭子叫！&quot;); } } public class Turkey : ITurkey //火鸡类 { public void SpecialQuack() { Console.WriteLine(&quot;火鸡叫！&quot;); } } public class Adapter : IDuck //适配器，把火鸡转换成鸭子 { private ITurkey t; //持有（包装）的火鸡引用 public Adapter(ITurkey t) { this.t = t; } public void Quack() { t.SpecialQuack(); } } class Program { static void Main(string[] args) { Adapter duckAdapter = new Adapter(new Turkey()); //使用适配器切换了接口 ShootDuck(duckAdapter); //原调用代码，不用更改。 Console.ReadKey(); } static void ShootDuck(IDuck d) { d.Quack(); } //原调用代码，不用更改。 } 理解系统A，原本某一块功能（如客户出入金）需要从一个提供商甲切换到提供商乙，不改变系统代码的情况下。可以创建适配器，封装乙的接口实现切换动作，让系统仍然像使用甲的接口那样，正常运作。过程不需修改代码，只需扩展适配器。处理遗留问题。 装饰者和适配器的异同适用条件的差别：装饰模式一般在下列情况使用：需要扩展一个类的功能或者给你个类增加附加责任；需要动态的给一个对象增加功能，这些功能可以再动态的撤销；需要增加有一些基本功能的排列组合而产生非常大量的功能，从而使得继承关系变得不现实。适配器模式一般使用的情况包括：系统需要使用现有的类，但此类已经不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的的类一起工作。适配器模式在系统升级的时候使用的频率很高，对旧系统的一些功能方法在新系统中引用。 单例模式定义确保一个类只有一个实例，并提供一个全局访问点。 代码示例线程安全 public class Singleton { private Singleton() { } private static Singleton singleton; public static Singleton GetInstance() { if (singleton == null) { lock (typeof(Singleton)) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 命令模式定义将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。 类图 代码示例public class Receiver { public void Action() { Console.WriteLine(&quot;Called Receiver.Action()&quot;); } } public abstract class Command { protected Receiver receiver; public Command(Receiver receiver) { this.receiver = receiver; } public abstract void Execute(); } public class ConcreteCommand : Command { public ConcreteCommand(Receiver receiver): base(receiver){} public override void Execute() { receiver.Action(); } } public class Invoker { private Command _command; public void SetCommand(Command command) { this._command = command; } public void ExecuteCommand() { _command.Execute(); } } static void Main(string[] args) { Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(); invoker.SetCommand(command); invoker.ExecuteCommand(); } 理解将请求者和执行者（接受者）解耦。如果执行者种类繁多，且不属于同一个体系，也没有统一执行接口。请求者请求命令，需要知道所有执行者的外露接口，耦合很高。命令模式，加入中间层：调用者，让请求者只认识调用者，向调用者发出指定执行者且接口固定的命令对象，调用者只执行指定命令对象的固定接口，命令对象包含执行者的引用和一组方法，知道如何完成操作。这种封装命令对象的模式，为命令模式。如待完成列表，可以在任何时间被执行。 外观模式定义提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易适用。 类图 代理模式定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。 类图 代理分类 远程代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。这样可以隐藏一个对象在不同地址空间的事实。例如：WebService，WCF 虚拟代理: 根据需要创建一个资源消耗较大的对象，通过它来存放实例化需要长时间的真实对象，使得此对象只在需要时才会被真正创建。 保护代理：用来控制真实对象的访问时的权限。如果需要，可以给不同的用户提供不同级别的使用权限。 智能代理：指当调用真实对象时，代理处理另外一些事。提供一些额外的操作，比如将对此对象调用的次数记录下来等。 同步（Synchronization）代理：多线程情况下，为主题提供安全的访问。 复杂隐藏（Complexity Hiding）代理：隐藏一个类的复杂集合的复杂度，有时候称为外观代理（Facade Proxy）。此代理控制访问，外观模式只提供另一组接口。 写入时复制（Copy-on-Write）代理：虚拟代理的变种。把复制（克隆）延迟到只有在客户端需要时，才真正采取行动。 缓存（Cache）代理：为开销大的运算结果提供临时的存储空间，以便多个客户端可以共享这些结果，以减少计算或网络延迟。 防火墙（Firewall）代理：控制网络资源的访问，不让恶意用户接近。 装饰者，外观，代理，适配器四种模式的比较 工厂方法模式定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 类图 抽象工厂模式定义提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指明具体类。 类图 模板方法模式定义在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 类图 代码示例public abstract class Beverage { public void Prepare() { BoilWater(); Brew(); PourInCup(); //钩子，可由子类视情况（是否覆盖），反控制基类中的算法（顺序或步骤） if (IsCondiments()) { AddCondiments(); } } protected abstract void AddCondiments(); //由子类实现部分算法 protected abstract void Brew(); //可有子类控制，推迟到子类中实现 protected virtual bool IsCondiments() { return false; } //钩子 private void PourInCup() { Console.WriteLine(&quot;倒入杯子&quot;); } //基类默认实现部分 private void BoilWater() { Console.WriteLine(&quot;烧水&quot;); } //同上 } public class Coffee : Beverage { protected override bool IsCondiments() { return GetResult(); } //根据结果是否覆盖使用此钩子 protected override void AddCondiments() { Console.WriteLine(&quot;加糖，加奶&quot;); } protected override void Brew() { Console.WriteLine(&quot;磨碎咖啡豆，泡咖啡粉...&quot;); } } static void Main(string[] args) { Beverage co = new Coffee(); co.Prepare(); } 模板方法模式的变种不使用继承，而使用组合。java中Arrays.sort(object[] arr)中的算法，进行两个对象之间的比较。 ... Comparable obj... //接口 obj.compareTo(obj2)... ... 算法待实现部分，不再交由子类负责实现（数组不可继承）。而是传入一个实现了Comparable接口的元素组成的数组，由此数组的元素负责。 模板方法模式和工厂方法模式，区别模板方法，指的是实现算法的方法，包含基类实现部分和待子类实现部分（抽象方法）。工厂方法，指的是可由子类继承实现的抽象方法，不同子类决定不同的功能。会由基类调用。 迭代器模式定义提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 类图 代码示例public class Item { public string Name { get; set; } public double Price { get; set; } public override string ToString() { return &quot;名称：&quot; + Name + &quot;，价格：&quot; + rice; } } public class MenuManager : IEnumerable //可被foreach迭代 { private Item[] items; private int Index { get; set; } public MenuManager() { items = new Item[10]; AddItem(&quot;煎饼&quot;, 2); AddItem(&quot;拉面&quot;, 7); AddItem(&quot;快餐&quot;, 10); } public IEnumerator GetEnumerator() { return new MenuEnumrator(items); } //继承实现，返回一个迭代器供foreach使用 public void AddItem(string name, double price) { Item i = new Item { Name = name, Price = price }; items[Index] = i; Index++; } public void ChgItem(string name, double price, int destIndex) { Item i = new Item { Name = name, Price = price }; items[destIndex] = i; } } public class MenuEnumrator : IEnumerator //迭代器接口 { private List&lt;Item&gt; list; private int index; public MenuEnumrator(IEnumerable&lt;Item&gt; arr) { list = arr.ToList(); index = -1; } public bool MoveNext() //继承实现，先后移动 { index++; bool result = list.Count &gt; index &amp;&amp; list[index].Price &lt; 3; //自定义条件 if (result) Current = list[index]; return result; } public void Reset() { index = -1; } //继承实现，重置索引 public object Current { get; private set; } //继承实现，当前项 } class Program { static void Main(string[] args) { MenuManager dm = new MenuManager(); dm.AddItem(&quot;汽水&quot;, 1); foreach (Item item in dm) { Console.WriteLine(item); } dm.ChgItem(&quot;干拌面&quot;, 9, 1); } } 组合模式定义允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 安全式和透明式组合模式：透明式：以单一责任设计原则换取透明性。减少客户代码，失去了一些安全性。可能会抛出异常。安全式：将责任区分开放在不同的接口中，符合单一责任原则。比较安全，但失去了透明性。客户代码必须判断类型，处理不同类型的节点。 类图 透明式的组合模式public class Graphics { protected string Name { get; set; } protected Graphics(string name) { this.Name = name; } public virtual void Draw() { throw new NotSupportedException(); } //默认抛出异常，避免叶对象或不合理的操作。 //简单图形（叶对象）Add或Remove方法没有任何意义 //如果客户端调用了将会抛出异常 public virtual void Add(Graphics g) { throw new NotSupportedException(); } public virtual void Remove(Graphics g) { throw new NotSupportedException(); } } public class Line : Graphics { public Line(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class Circle : Graphics { public Circle(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class ComplexGraphics : Graphics { public ComplexGraphics(string name) : base(name) { } private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() { foreach (var item in list) item.Draw(); } public override void Add(Graphics g) { list.Add(g); } public override void Remove(Graphics g) { list.Remove(g); } } class Program { static void Main(string[] args) { Graphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;); complexGraphics.Add(new Line(&quot;线段A&quot;)); Graphics l = new Line(&quot;线段B&quot;); complexGraphics.Add(l); Graphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;); CompositeCG.Add(new Circle(&quot;圆&quot;)); CompositeCG.Add(new Circle(&quot;线段C&quot;)); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine(&quot;复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成\n&quot;); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); } } 安全式的组合模式public abstract class Graphics { protected string Name { get; set; } protected Graphics(string name) { this.Name = name; } public abstract void Draw(); // 移除了Add和Remove方法 // 把管理子对象的方法放到了ComplexGraphics类中进行管理 // 因为这些方法只在复杂图形中才有意义，且符合单一责任原则。 } public class Line : Graphics { public Line(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class Circle : Graphics { public Circle(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class ComplexGraphics : Graphics { public ComplexGraphics(string name) : base(name) { } private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() { foreach (var item in list) item.Draw(); } public void Add(Graphics g) { list.Add(g); } public void Remove(Graphics g) { list.Remove(g); } } class Program { static void Main(string[] args) { ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;); complexGraphics.Add(new Line(&quot;线段A&quot;)); Line l = new Line(&quot;线段B&quot;); complexGraphics.Add(l); ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;); CompositeCG.Add(new Circle(&quot;圆&quot;)); CompositeCG.Add(new Circle(&quot;线段C&quot;)); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine(&quot;复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); } } 状态模式定义允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 类图 代码示例Machine： public class Machine { internal State SoldOutState { get; set; } //内部包装的状态 internal State NoCoinState { get; set; } internal State HasCoinState { get; set; } internal State SoldingState { get; set; } public int Count { get; internal set; } //对外暴露的显示 public int CoinCount { get; internal set; } internal State State { get; set; } public Machine(int count) { SoldOutState = new SoldOutState(this); NoCoinState = new NoCoinState(this); HasCoinState = new HasCoinState(this); SoldingState = new SoldingState(this); Count = count; CoinCount = 0; State = count &gt; 0 ? NoCoinState : SoldOutState; } public void Insert() { State.Insert(); } public void Eject() { State.Eject(); } public void Turn() //对外暴露的接口（按钮） { State.Turn(); //内部执行的动作，由状态类负责 if (CoinCount &gt; 0) State.Give(); } internal void SetState(State state) { State = state; } public void FillBall(int count) { Console.WriteLine(&quot;上货&quot; + count + &quot;个&quot;); Count += count; } internal void ReleaseBall() { Console.WriteLine(&quot;发放商品&quot;); if (Count != 0) Count--; } public override string ToString() { return &quot;\n============================\n自动售货机\n货物个数：&quot; + Count + &quot;\t当前状态：&quot; + State + &quot;\n============================\n&quot;; } } 状态类： internal abstract class State { public abstract void Insert(); public abstract void Eject(); public abstract void Turn(); public abstract void Give(); protected virtual void Error() { Console.WriteLine(&quot;错误操作&quot;); } } internal class NoCoinState : State { private Machine Mac { get; set; } public NoCoinState(Machine mac) { Mac = mac; } public override void Insert() { Console.WriteLine(&quot;投入硬币&quot;); Mac.CoinCount++; Mac.SetState(Mac.HasCoinState); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Error(); } public override string ToString() { return &quot;等待投入硬币...&quot;; } } internal class HasCoinState : State { private Machine Mac { get; set; } public HasCoinState(Machine mac){Mac = mac;} public override void Insert(){Error();} public override void Eject() { Console.WriteLine(&quot;硬币归还&quot;); Mac.CoinCount--; Mac.SetState(Mac.NoCoinState); } public override void Turn() { Console.WriteLine(&quot;转动&quot;); Mac.SetState(Mac.SoldingState); } public override void Give(){Error();} public override string ToString(){return &quot;有硬币，可以转动...&quot;;} } internal class SoldingState : State { private Machine Mac { get; set; } public SoldingState(Machine mac) { Mac = mac; } public override void Insert() { Error(); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Mac.ReleaseBall(); if (Mac.Count &gt; 0) Mac.SetState(Mac.NoCoinState); else { Console.WriteLine(&quot;已售罄&quot;); Mac.SetState(Mac.SoldOutState); } } public override string ToString() { return &quot;正在出货...&quot;; } } internal class SoldOutState : State { private Machine Mac { get; set; } public SoldOutState(Machine mac) { Mac = mac; } public override void Insert() { Error(); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Error(); } public override string ToString() { return &quot;已售罄...&quot;; } } 测试代码： class Program { static void Main(string[] args) { Machine mac = new Machine(5); Console.WriteLine(mac); mac.Eject(); mac.Turn(); mac.FillBall(1); mac.Insert(); Console.WriteLine(mac); mac.Eject(); mac.Insert(); mac.Insert(); mac.Turn(); mac.Turn(); Console.ReadKey(); } } 模式配对 模式分类]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#入门经典_注释笔记]]></title>
    <url>%2F2017%2F02%2F26%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[checked关键字：//检查赋值是否数据溢出//或者配置，项目-属性-生成-高级，检查上溢下溢 checked//unchecked 不检查 { destination = (int)source; } 委托：2种写法： 1，Calcul cal=new Calcul(Add); 2, Calcul cal=Add; 或 1,Calcul cal; cal=new Calcul(Add); 2,Calcul cal; cal=Add; ps:情况2自动初始化一个委托 二维数组：int[,] ints = new int[10,4]; ints[2, 2] = 1; ref out关键字ref out 等也可以改变函数的签名(命名+参数），从而实现重载 断点：可以设置中断条件和击中次数。如，a&gt;=100，次数=100 析构函数：class MyClass{ ~MyClass(){ } } ~ 析构函数，垃圾回收器回收时自动调用还将隐式调用基类的析构函数 隐藏基类方法，在子类中定义时加new public void Do(){ ... } 类型比较：myObj.GetType()==typeof(MyObjClass) 对对象类型的比较 myObj is objBasemyObj是objBase的子类，实现类，同类都为true 重载运算符： 例如：+需要再进行+运算的类内部定义ps:1，不能重载+=，-=。但如果重载它们对应的简单运算符，如+，则+=仍能像预期那样执行。2，不能重载=，因为它有基本用途3，不能重载&amp;&amp;和||，但同1理，重载&amp;和|就够了4，&lt;和&gt;，&lt;=和&gt;=必须成对重载 class Person { public int Age { get; set; } public decimal Price { get; set; } public string Name { get; set; } public static Person operator +(Person p1, Person p2) { return new Person { Age = p1.Age + p2.Age }; } public static bool operator &gt;(Person left, Person right) { return left.Age &gt; right.Age; } public static bool operator &lt;(Person left, Person right) { return left.Price &lt; right.Price; } } IComparable接口：定义在要比较的对象的类中实现，类要实现IComparable接口 public int CompareTo(object obj) { var person = obj as Person; if (person == null) throw new ArgumentException(&quot;参数错误&quot;); return Age - person.Age; } 重写隐式(implicit)，显式(explicit)转换：class Person1 { public int Age { get; set; } public static implicit operator Person2(Person1 p1) { Person2 p = new Person2 { Age = p1.Age }; return p; } } class Person2 { public double Age { get; set; } public static explicit operator Person1(Person2 p2) { Person1 p1 = new Person1(); checked { p1.Age = (int)p2.Age; } return p1; } } ps：同样可作用于泛型集合 父子类相互转换： 1会报错，2不会报错。不能把父类实例转换成子类实例，只能把父类变量类型转换成子类变量类型 1 Person p = new Person(); Man m = (Man)p; 2 Person p1 = new Man(); Man m1 = (Man) p1; 如果强转换成as 则都不会报错，1为null，2不为null ??运算符：int? val1 = null; int result = val1*5 ?? 10; int? result2=val1*5 ?? 10; ??等式的结果可以是int或int?，等式会自动进行转换 default关键字：如果T是引用类型，则输出null如果T是值类型，则输出默认值e.g. int -&gt; 0 Class MyClass&lt;T&gt;{ public MyClass(){ Console.WriteLine(default(T)); } } 约束类型class MyClass&lt;T1, T2&gt; : MyClassBase where T1 : class,new () where T2 : T1 { } ps:1，约束类型：struct值类型，class引用类型，base-class任意基类，interface接口，new()有一个公共无参构造函数2，多个约束之间用，分隔3，new()作约束必须是指定的最后一个4，约束必须出现在继承说明符的后面 协变和抗变：应用于泛型接口和委托，继承关系默认支持协变1，协变 List&lt;string&gt; liststr = new List&lt;string&gt;(); List&lt;object&gt; listobj = new List&lt;object&gt;(); listobj.AddRange(liststr); //参数为IEnumerable&lt;object&gt; 定义： public class List&lt;T&gt; : IEnumerable&lt;T&gt;... public interface IEnumerable&lt;out T&gt; : IEnumerable ps：1，使用关键字out，则类型参数T只能作为方法的返回值2，泛型类型参数可以从一个派生类隐式转化为基类，让一个带有协变参数的泛型接口（或委托）可以接收类型更加精细化，具体化的泛型接口（或委托）作为参数，可以看成OO中多态的一个延伸。 2，抗变（逆变） class MyComparer : IComparer&lt;object&gt; { public int Compare(object x, object y) { throw new NotImplementedException(); } } IComparer&lt;object&gt; comobj = new MyComparer(); liststr.Sort(comobj); //参数为IComparer&lt;string&gt; 定义： public interface IComparer&lt;in T&gt; ps：1，使用关键字in，则类型参数T只能作为方法的参数2，泛型类型参数可以从一个基类隐式转化为派生类，让一个带有协变参数的泛型接口（或委托）可以接收粒度更粗的泛型接口或委托作为参数，这个过程实际上是参数类型更加精细化的过程。 总结：协变让一个粗粒度接口（或委托）可以接收一个更加具体的接口（或委托）作为参数（或返回值）；逆变让一个接口（或委托）的参数类型（或返回值）类型更加具体化，也就是参数类型更强，更明确。 引发事件时，会依次调用程序列表中每个处理程序，只要它们满足指定的条件即可。委托的应用：delegate int OperationDelegate(int left,int right); void Function(OperationDelegate del) { int left,right; //... del(left,right); } void int OperationEx(int left,int right) { return left+right; } //Main1,用方法创建委托 void Function(new OperationDelegate(OperationEx)); 2,直接传递方法(默认创建委托) void Function(OperationEx); 3,匿名方法 void Function(delegate(int left,int right){ return left+right; }); 4,Lambda表达式 void Function((left,right) =&gt; left+right); //参数类型不用指定，会通过上下文推断出类型 Function((left,right) =&gt; (left-right)*right); //Lambda表达式本质还是委托//用Func来简化一个委托的定义。代替delegate xx…. Lambda表达式的解释：可以用两种方式解释Lambda表达式，第一，Lambda表达式是一个委托，可以把它表示为如下泛型类型：Action - lambda表达式不带参，返回void，Action&lt;&gt; - lambda表达式最多8个参数，返回void，Func&lt;&gt; - lambda表达式最多8个参数，返回不是void//e.g.Func lamb，前面的是参数，最后的bool是返回值 第二，可以把Lambda表达式解释为表达式树。并不能直接执行。LINQ架构的泛型类 Expression&lt;&gt;，可用于封装Lambda表达式，把它转换为相应的SQL脚本，以便在数据库中直接执行 工作目录：//设置当前工作目录，并不是转移文件！ Directory.SetCurrentDirectory(Directory.GetCurrentDirectory()+&quot;\\demo&quot;); //当前工作目录字符串 Directory.GetCurrentDirectory(); FileStream：FileInfo file = new FileInfo(&quot;test.txt&quot;); //创建一个只读的流 FileStream stream = file.OpenRead(); //创建一个只写的流 FileStream stream1 = File.OpenWrite(&quot;test.txt&quot;); //将文件指针移动到文件的第8个字节，起始位置为第1个字节 stream.Seek(8, SeekOrigin.Begin); //将指针从当前位置向前移动2个字节，则指向8+2=10个字节 stream.Seek(2, SeekOrigin.Begin); //查找文件中倒数第5个字节 stream.Seek(-5, SeekOrigin.End); //FileStream 操作字节或字节数组的流 //Stream(StreamReader或StreamWriter)操作的是字符 FileStream读取数据：//读取本身cs文件 byte[] byData = new byte[200]; char[] charData = new char[200]; try { FileStream stream = new FileStream(&quot;../../Program.cs&quot;, FileMode.Open); stream.Seek(110, SeekOrigin.Begin); stream.Read(byData, 2, 190); } catch (Exception e) { Console.WriteLine(&quot;AN IO Exception throw!&quot;); Console.WriteLine(e.ToString()); Console.ReadKey(); throw; } Decoder d = Encoding.UTF8.GetDecoder(); d.GetChars(byData, 0, byData.Length, charData, 0); Console.WriteLine(charData); FileStream写入：byte[] byData; char[] charData; try { FileStream file = new FileStream(&quot;test1.txt&quot;, FileMode.Create); charData = &quot;This is a charData array!&quot;.ToCharArray(); byData = new byte[charData.Length]; Encoder encoder = Encoding.UTF8.GetEncoder(); encoder.GetBytes(charData, 0, charData.Length, byData, 0, true); file.Seek(0, SeekOrigin.Begin); file.Write(byData, 0, byData.Length); } catch (Exception) { //... throw; } StreamReader/Writer的权限：StreamReader/Writer 总是拥有对文件的读写权限，为了使用高级参数如，FileMode,FileAccess，可以在FileStream构造函数指定这些参数，然后通过FileStream创建StreamReader/Writer 读取数据的选择：1，小文件，StreamReader.ReadToEnd();2，大型文件，StreamReader.ReadLine(); 循环判断是否为空 或者 foreach (var item in File.ReadLines(&quot;test.txt&quot;,Encoding.Default)) { Console.WriteLine(item); } File.ReadLines 一次读取一行，迭代读取。返回IEnumerable&lt;string&gt; File.ReadAllLines 打开一个文件，读取文件的所有行，然后关闭文件。返回string[] 压缩和解压缩类 输入读取类：System.IO.Compression; static void SaveCompressedFile(string fileName, string data) { FileStream file = new FileStream(fileName, FileMode.Create, FileAccess.Write); GZipStream zip = new GZipStream(file, CompressionMode.Compress); StreamWriter sw = new StreamWriter(zip,Encoding.Default); sw.Write(data); sw.Close(); } static string LoadCompressedFile(string fileName) { FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read); GZipStream zip = new GZipStream(file, CompressionMode.Decompress); StreamReader sr = new StreamReader(zip, Encoding.Default); string data = sr.ReadToEnd(); sr.Close(); return data; } C#6.0 新特性1，字符串插值（String Interpolation） 之前： var Name = &quot;Jack&quot;; var results = &quot;Hello&quot; + Name; 或者 var results = string.Format(&quot;Hello {0}&quot;, Name); Now： var results = $&quot;Hello {Name}&quot;; 之前： Person p = new Person {FirstName = &quot;Jack&quot;, LastName = &quot;Wang&quot;, Age = 100}; var results = string.Format(&quot;First Name: {0} LastName: {1} Age: { 2} &quot;, p.FirstName, p.LastName, p.Age); Now： var results = $&quot;First Name:{p.FirstName} LastName:{p.LastName} Age：{p.Age}&quot;; PS:还可以插入代码 - 相当于小脚本或Razor 的@{ }，不过只能作用于string Console.WriteLine($&quot;Jack is saying { new Tools().SayHello() }&quot;); 2，空操作符 ( ?. ) 之前： if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) { Console.WriteLine(user.Project.Tasks.First().Name); } Now： Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 还可用于数组索引器 User[] users = null; Console.WriteLine(users?[1].Name); // 正常 Console.WriteLine(users[1]?.Name); // 报错 PS：以下代码并不会报错，也不会有输出。减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常。那么使用这个特性反而隐藏了Bug User user = null; user?.SayHello(); C#6.0 新特性 2：3， NameOf Console.WriteLine(nameof(User.Name)); // output: Name Console.WriteLine(nameof(System.Linq)); // output: Linq Console.WriteLine(nameof(List&lt;User&gt;)); // output: List PS：NameOf只会返回Member的字符串，如果前面有对象或者命名空间，NameOf只会返回 . 的最后一部分, 另外NameOf有很多情况是不支持的，比如方法，关键字，对象的实例以及字符串和表达式 4，表达式方法体一句话的方法体可以直接写成箭头函数，而不再需要大括号 private static string SayHello() =&gt; &quot;Hello World&quot;; private static string JackSayHello() =&gt; $&quot;Jack {SayHello()}&quot;; Console.WriteLine(SayHello()); Console.WriteLine(JackSayHello()); 序列化对象：using System.IO; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Binary; [Serializable] class Product { public long Id; public string Name; public double Price; [NonSerialized] string Notes; public Product(long id, string name, double price, string notes) { Id = id; Name = name; Price = price; Notes = notes; } public override string ToString() { return $&quot;{Id}：{Name} (${Price:F2}) {Notes}&quot;; } } //Main中 List&lt;Product&gt; list = new List&lt;Product&gt;() { new Product(1,&quot;Pung&quot;,1000.0,&quot;Good stuff.&quot;), new Product(2,&quot;Soup&quot;,25.0,&quot;Tasty.&quot;), new Product(4,&quot;Hat Sauce&quot;,12.0,&quot;One for the kids.&quot;) }; Console.WriteLine(&quot;Products to save:&quot;); list.ForEach(p =&gt; Console.WriteLine(p.ToString())); IFormatter serializer = new BinaryFormatter(); FileStream file = new FileStream(&quot;Products.bin&quot;, FileMode.Create, FileAccess.Write); serializer.Serialize(file, list); file.Close(); FileStream fileLoad = new FileStream(&quot;Products.bin&quot;, FileMode.Open, FileAccess.Read); List&lt;Product&gt; list2 = serializer.Deserialize(fileLoad) as List&lt;Product&gt;; fileLoad.Close(); 监控文件：private FileSystemWatcher watcher; public Form1() { watcher = new FileSystemWatcher(); watcher.Deleted += new FileSystemEventHandler(OnDelete); watcher.Renamed += new RenamedEventHandler(OnRenamed); InitializeComponent(); } public void OnRenamed(object source, RenamedEventArgs e) { StreamWriter sw = new StreamWriter(@&quot;F:\Logs\log.txt&quot;, true); sw.WriteLine($&quot;File renamed from {e.OldName} to {e.FullPath}&quot;); sw.Close(); } public void OnDelete(object source, FileSystemEventArgs e) //... private void btnWatch_Click(object sender, EventArgs e) { watcher.Path = Path.GetDirectoryName(txtLocation.Text); watcher.Filter = Path.GetFileName(txtLocation.Text); watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size; watcher.EnableRaisingEvents = true; } XPath查询xml语言：XmlDocument xml = new XmlDocument(); xml.Load(&quot;../../Demo.xml&quot;); XmlElement e = xml.DocumentElement; var node = e.SelectSingleNode(&quot;Book[Title=&apos;韩寒&apos;]&quot;); Console.WriteLine(node.SelectSingleNode(&quot;Content&quot;).InnerText); xml.Save(&quot;../../Demo.xml&quot;); LINQ查询大数集合：private static int[] GetNumbers(int count) { Random ran = new Random(0); int[] result = new int[count]; for (int i = 0; i &lt; count; i++) { result[i] = ran.Next(); } return result; } static void Main(string[] args) { var nums = GetNumbers(12345678); var query = from n in nums where n &gt; 1000 select n; Console.WriteLine(query.Count()); Console.WriteLine(query.Max()); Console.WriteLine(query.Min()); // 默认版本.Sum()返回的是int，数值太大导致溢出 Console.WriteLine(query.Sum(p=&gt;(long)p)); Console.WriteLine(query.Average()); Console.ReadKey(); } LINQ 2：单值查询 .Distinct()（只选取没有重复的元素）任意符合 .Any()（任意元素符合条件返回true）全部符合 .All()（全部元素符合条件返回true） .First()和.FirstOrDefault()区别：.First()当条件不满足时，抛出异常.FirstOrDefault()当条件不满足时，返回一个null LINQ 3：集运算符：.Intersect() 使用默认的相等比较器得出两个序列的交集.Except() 同上，得出差集.Union() 同上，得出并集 Join查询： var orderIds = from n in list select n; var customers=from n in list join m in orderIds on n.Id equals m.Id //equals 关键词，必须 select n.Amount+m.Amount; LINQ TO XML：//从字符串转换 XDocument d1 = XDocument.Parse(@&quot; &lt;customers ID=&quot;&quot;A&quot;&quot; City=&quot;&quot;NY&quot;&quot; Region=&quot;&quot;North American&quot;&quot;&gt; &lt; order Item = &quot;&quot;Widget&quot;&quot; Price = &quot;&quot;100&quot;&quot; /&gt; &lt; order Item = &quot;&quot;Tire&quot;&quot; Price = &quot;&quot;200&quot;&quot; /&gt; &lt;/ customers &gt; &quot;); XDocument doc = new XDocument( //内部有其他元素，则有闭合标签 new XElement(&quot;customers&quot;, new XAttribute(&quot;ID&quot;, &quot;A&quot;), new XAttribute(&quot;City&quot;, &quot;NY&quot;), new XAttribute(&quot;Region&quot;, &quot;North American&quot;), //内部没有其他元素，则自闭 new XElement(&quot;order&quot;, new XAttribute(&quot;Item&quot;, &quot;Widget&quot;), new XAttribute(&quot;Price&quot;, 100) ), new XElement(&quot;order&quot;, new XAttribute(&quot;Item&quot;, &quot;Tire&quot;), new XAttribute(&quot;Price&quot;, 200) ) ) ); string path = &quot;../../demo.xml&quot;; doc.Save(path); XDocument d = XDocument.Load(path); Console.WriteLine(d); var query = from n in doc.Descendants(&quot;order&quot;) select n.Name; //.Elements()返回第一级子元素 //.Descendants()返回所有子元素 // 重载形式可以指定元素名 //.Attributes()返回当前元素所有特性]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F02%2F26%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git$ git config –global user.name “John Doe” //设置用户名邮箱–global 只针对当前用户$ git config –global user.email johndoe@example.com //去掉–global，针对特定项目使用不同的账号$ git config -l //列出所有设置$ git config –global alias.ci commit //设置别名$ git config –global alias.last ‘log -1 HEAD’ //看最后一次提交$ git config –global alias.visual ‘!gitk’ //外部命令，+!$ git config –global credential.helper cache //缓存验证密码$ git config –global alias.lg “log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative” //改造log显示，推荐 $ git init //在现有目录中初始化仓库$ git add //如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。add *$ git commit -a //跳过暂存，直接提交$ git log [-p] [-2] //提交记录。显示提交的差异。只显示2条。$ git log –oneline –decorate –graph –all //输出提交历史、各个分支的指向以及项目的分支分叉情况$ git status -s //更为紧凑的格式输出 $ git clone https://github.com/libgit2/libgit2 [mylibgit] //克隆现有的仓库，当前目录下创建一个名为 libgit2&#39;&#39; 的目录，并在这个目录下初始化一个.git 文件夹。[自定义文件夹命名]。命令会自动将其添加为远程仓库并默认以origin为简写。设置本地 master分支跟踪克隆的远程仓库的 master 分支。$ git clone -o booyah //自定义远程分支名字。创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master 。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。 $ git diff //查看上次暂存之后的变动$ git diff –staged //查看已经暂存的变动 $ git rm 1.txt //删除文件，跟踪清单和本地$ git rm –cached README //仓库中删除（亦即从暂存区域移除） ，但保留在当前工作目录中$ git mv 1.txt dir/2.txt //移动文件，也可重命名 $ git checkout a.md //还原成上次提交时的样子，只能撤销没add进暂存区的文件$ git reset HEAD 1.txt //取消暂存区中的文件$ git commit –amend //重新提交，覆盖上次提交 $ git remote //查看已经配置的远程仓库$ git remote -v //显示需要读写远程仓库使用的 Git 保存的简写与URL$ git remote add //添加一个新的远程 Git 仓库$ git remote show origin // URL 与跟踪分支的信息$ git remote rename pb paul //修改一个远程仓库的简写名$ git remote rm paul //移除一个远程仓库$ git push origin v1.5 //推送标签到远程$ git push origin –tags //推送远程没有的所有标签$ git push origin –delete serverfix //删除远程分支 $ git fetch origin master[:newb] //拉取pb的仓库中有但你没有的信息[并新建成分支newb]$ git checkout -b master origin/master //新建本地分支映射远程分支$ git pull //自动的抓取然后合并远程分支到当前分支=fetch+checkout$ git push origin master //推送到远程仓库的某一分支。需要：拥有写入权限，且本地与远程数据同步时。 $ git tag //列出已有的标签$ git tag -l ‘v1.8.5*’ //只对 1.8.5 系列$ git tag -a v1.4 -m ‘my version 1.4’ //创建一个附注标签$ git show v1.4 //标签信息$ git tag v1.4-lw //创建轻量标签，没有保存任何其他信息$ git tag //查看$ git tag -a v1.2 9fceb02 //后期打标签$ git checkout -b version2 v2.0.0 //在特定的标签上创建一个新分支 $ git stash //暂存当前所有改动$ git stash list //查看暂存记录$ git stash apply //还原已暂存代码$ git stash drop [stash_id] //删除暂存记录，[删除某条]$ git stash pop //快捷：还原+删除$ git stash clear //清空暂存区记录 $ git branch [–merged/–no-merged] //分支列表,[查看已/未与当前分支合并的分支],如与master合并的分支可以删除，无损失$ git branch -v //查看每个分支最后一次提交$ git branch -a //查看所有分支（远程和本地）$ git branch -r //查看所有远程分支$ git branch testing //分支创建$ git checkout testing //分支切换$ git checkout -b iss53 //新建并切换到新分支$ git checkout -b serverfix origin/serverfix //在某分支之上建立分支$ git checkout master //合并分支①$ git merge iss53 //合并分支②$ git branch -d hotfix //删除分支 $ git rebase master //以master为基底进行变基，重演experiment的提交过程，并清理提交历史。只对尚未推送或分享给别人的本地修改执行变基操作清理历史$ git checkout master //往回切换到master分支$ git merge experiment //master快进到目标点 忽略列表(.gitignore)* //匹配零个或多个任意，.a//支持glob模式(简化正则表达式)[abc] //匹配a或b或c? //只匹配一个任意字符!lib.a //忽略lib.a以外的文件[0-9] //匹配所有 0 到 9 的数/.txt //只忽略当前文件夹下的文件，不包括子目录 a/.txtbuild/ //忽略所有build/目录下的文件doc/**/.pdf //忽略所有.pdf文件在doc/ 目录下** //匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或a/b/c/z 等]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法示例]]></title>
    <url>%2F2017%2F02%2F26%2FMarkdown%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[基础标题123456#一级标题##二级标题###三级标题####四级#####五级######六级 列表123456789无序列表- 1- 2- 3有序列表1. 1 2. 23. 3 1 2 1 2 文本1*斜体* **粗体** 斜体 粗体 1&gt; 这里是引用 这里是引用 链接1[Baidu](http://www.baidu.com &quot;百度&quot;) Baidu 1234I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from Google than fromYahoo or MSN. 1![Logo](http://cdn-qn0.jianshu.io/assets/web/logo-58fd04f6f0de908401aa561cda6a0688.png &quot;简书&quot;) 1See my [Markdown语法示例](/Markdown语法示例) page. See my Markdown语法示例 page. 代码12`public void Add()` //局部代码块 public void Delete() //一个tab或四个空格 public void Add() public void Delete() Html123&lt;div style=&quot;color:red;&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; &copy; 2004 Foo Corporation 反义符号 ‘\’11986\. What a great season. 1986. What a great season. 未转义：11986. What a great season. What a great season. 进阶内容目录1[TOC] *这里不支持 删除线1~~ 表示删除线。 删除的文本 增强代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 12345678910111213141516/*** @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 表格1234|列首1|列首2|列首3|列首4||-:|:-: 右对齐，居中，左对齐(默认)|单元格|单元格|单元格|单元格||单元格|单元格|单元格|单元格| 列首1 列首2 列首3 列首4 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个Todo列表，支持嵌套以及混用Markdown语法 - [ ] **待办** - [ ] *取快递* - [x] 工作安排 - [x] 本季度绩效统计 [Google 表格](https://docs.google.com/spreadsheets/) 对应显示如下待办事宜 Todo 列表： 待办 取快递 工作安排 本季度绩效统计 Google 表格]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>

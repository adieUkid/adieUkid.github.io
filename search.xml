<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis入门指南_注释笔记]]></title>
    <url>%2F2018%2F12%2F25%2FRedis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介SQL型和NoSQL型的区别SQL：适合存储结构化数据，如用户的帐号、地址。 这些数据通常需要做结构化查询 这些数据的规模、增长的速度通常是可以预期的 事务性、一致性 NoSQL：适合存储非结构化数据，如文章、评论、微博。 这些数据通常用于模糊处理，如全文搜索、机器学习 这些数据是海量的，而且增长的速度是难以预期的， 根据数据的特点，NoSQL 数据库通常具有无限（至少接近）伸缩性 按key获取数据效率很高，但是对 join 或其他结构化查询的支持就比较差 准备安装123456wget http://download.redis.io/redis-stable.tar.gztar xzf redis-stable.tar.gzcd redis-stablemakemake install # 可执行文件复制到/usr/local/bin目录内[make test] 启动和停止Redis 的组件介绍123456redis-server # Redis服务器redis-cli # Redis命令行客户端redis-benchmark # Redis性能测试工具redis-check-aof # AOP文件修复工具redis-check-dump # RDB文件检查工具redis-sentinel # Sentinel服务器 启动直接启动1redis-server [--port 6380] # 默认6379 通过初始化脚本启动复制源目录 utils 文件夹下的初始化脚本：1sudo cp redis_init_script /etc/init.d/redis_6379 修改配置文件的 REDISPORT 为同样的端口号，然后创建需要的目录： 12sudo mkdir /etc/redissudo mkdir /var/redis/6379 复制配置文件模板到刚出案件的目录：1sudo cp /opt/redis-stable/redis.conf /etc/redis/6379.conf 修改配置文件： 设置 Redis 随系统自启：1sudo update-rc.d redis_6379 defaults 如果报错：insserv: warning: script ‘redis6379′ missing LSB tags and overrides，就在 /etc/init.d/redis_6379 文件中添加头： 123456789### BEGIN INIT INFO# Provides: redis6379# Required-Start: $local_fs $network# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: redis6379# Description: penavico redis 6379### END INIT INFO 启动 Redis 守护进程：1sudo service redis_6379 start 停止优雅的停止：redis-cli SHUTDOWN或者：kill PID Redis 命令行客户端发送命令1redis-cli [-h 127.0.0.1] [-p 6379] [-a password] 测试联通性：1redis-cli ping 命令返回值返回值的5种类型： 状态回复 返回命令状态信息，ping/set。 错误回复 以(error)开头，后面跟上错误信息。比如执行一个不存在的命令 整数回复 以(integer)开头，如递增键值的 INCR 命令，返回递增后的键值。 字符串回复 以双引号包裹，请求一个字符串类型键的键值或一个其他类型键中的某个元素时返回。如果不存在时得到一个空结果(nil) 多行字符串回复 请求一个非字符串类型键的元素列表时返回，每行以一个序号开头。如 keys * 配置指定配置文件启动 server：1redis-server /path/to/redis.conf [--loglevel warning] 启动参数传递的同名配置会覆盖配置文件中相应的参数。 不重启 redis 修改部分配置：1config set loglevel warning 获取 redis 当前的配置情况：1config get loglevel redis.conf 部分配置说明： 12345678910111213141516171819bind 127.0.0.1 //默认绑定主机地址port 6379 //默认端口timeout 0 //当客户端闲置多久后关闭连接，0代表没有启动该选项loglevel notice //日志的记录级别 // debug (很详细的信息 ，适合开发和测试) // verbose (包含不太有用的信息) // notice (适合生产环境) // warning (警告信息)logfile "" //日志的记录方式，默认为标准输出databases 16 //默认数据库数量为16个，编号从0到1save &lt;seconds&gt; &lt;changed&gt; //多少sec至少有多少个changed才将其同步到磁盘中的数据文件里save 900 1 //900秒（15分钟）至少有1次save 300 10 //300秒（5分钟）至少有10次save 60 10000 //60秒（1分钟）至少有10000次rdbcompression yes //存储本地数据库是否启用LZF压缩，默认yesdbfilename dump.rdb //指定本地数据库文件名，默认为dump.rdbdir ./ //指定本地数据库的存放目录，默认是当前目录 允许外部访问：注释掉 bind，修改 protected-mode 为 no。 设置访问密码：1requirepass yourpassword 多数据库一个 redis 实例提供了多个用来存储数据的字典，就像一个关系数据库实例中可以创建多个数据库。redis 不支持自定义数据库的名字，每个数据库都是以一个从0开始的递增数字命名，redis 默认支持16个数据库。可以通过修改配置 databases 来修改这一数字。通过 select 命令更换数据库。（默认建立连接后选择0号数据库）redis 也不支持为每个数据库设置不同的访问密码。多个数据库之间并不是完全隔离的，flushall 命令可以清空一个redis实例中所有数据库中的数据。所以这些数据库更像是一种命名空间，可以使用0号存储生产数据，使用1号存储测试数据。但不适宜存储不同应用程序的数据。一个空 redis 实例占用的内存只有1MB。 入门热身 获得符合规则的键名列表 1234keys ?keys *keys a[b-d]keys \? keys 会遍历 redis 中的所有键，键数量较多时会影响性能。 判断一个键是否存在 1exist bar 删除键 1del key del 本身不支持通配符，可以通过执行 redis-cli DEL &#39;redis-cli KEYS &quot;user:*&quot;&#39; 实现通配符效果。 获得键值的数据类型 1234567type keyset foo 1type foo //stringlpush bar 1type bar //list 字符串类型命令一个字符串类型键允许存储的数据的最大容量是512MB。列表类型是以列表的形式组织字符串，而集合类型是以集合的形式组织字符串。 赋制取值 12set key valueget key 递增数字 1incr key 包括 incr 在内的所有 redis 命令都是原子操作，无论多少个客户端同时连接，都不会出现“竞态”。 实践 文章访问量统计 每篇文章存一个 post:文章ID:page.view 来记录访问量，使用 incr 递增。 Redis 命名比较好的实践是用“对象类型：对象ID：对象属性”来命名一个健，如使用健 user:1:friends 来存储ID为1的用户的好友列表。对于多个单词则推荐使用“.”分隔。 生成自增ID 对每一类对象使用 objects:count（如users:count）的键来存储当前类型对象的数量 存储文章数据 命令拾遗 增加指定的整数 12incrby key incrementincrby bar 3 减少指定的整数 12decr keydecr key decrement 增加指定浮点数 1incrbyfloat key increment 向尾部追加值 1append key value 获取字符串长度 1234strlen keyset key 你好strlen key //返回6，中文的UTF-8编码长度一般都是3 同时获得/设置多个键值 12mget key [key ...]mset key value [key value ...] 位操作 1234getbit key offsetsetbit key offset valuebitcount key [start] [end]bitop operation destkey key [key ...] 利用位操作命令可以非常紧凑地存储布尔值。比如如果网站的每个用户都有一个递增的整数ID，如果使用一个字符串类型键配合位操作来记录每个用户的性别（用户ID作为索引，二进制位值1和0表示男性和女性），那么记录100万个用户的性别只需占用100KB多的空间，而且由于 GETBIT 和 SETBIT 的时间复杂度都是O(1)，所以读取二进制位值性能很高。 散列类型介绍散列类型适合存储对象，字段值只能是字符串。除了散列类型，其他数据类型同样不支持数据类型嵌套。不同于关系型数据库，所有记录（数据表）不一定拥有相同的属性，完全可以自由地为任何键增减字段而不影响其他键。 命令 赋值与取值 12345hset key field valuehget key fieldhmset key field value [field value ...]hmget key field [field ...]hgetall key hset 不区分插入和更新操作，字段存在则更新，返回0，不存在则插入，返回1。 判断字段是否存在 1hexists key field 当字段不存在时赋值 1hsetnx key field value 与 hset 的区别是，当字段已存在时不执行任何操作 增加数字 12hincrby key field incrementhincrby person score 60 删除字段 1hdel key field [field ...] 返回被删除字段个数 实践存储文章缩略名，伪代码：123456id = incr posts:counthsetnx slug.to.id slug idhmset post:id title title content content ....id = hget slug.to.id slughgetall post:id 命令拾遗 只获取字段名或字段值 12hkeys keyhvals key 获得字段数量 1hlen key 列表类型介绍redis 的列表类型内部使用双向链表实现的。一个列表类型键最多能容纳2的32次方-1个元素，与散列类型键最多能容纳的字段数量相同。 命令 向列表两端增加元素 12lpush key value [value ...] //向列表左边增加元素，返回列表的长度rpush key value [value ...] 从列表两端弹出元素 12lpop keyrpop key 把列表当做栈，则使用 lpush 和 lpop 或 rpush 和 rpop。 把列表当做队列，则搭配使用 lpush 和 rpop 或 rpush 和 lpop。 获取列表中元素的个数 1llen key 时间复杂度为O(1)。 获得列表片段 1lrange key start stop lrange 获取时不像 lpop 一样删除该片段，返回的值包含最右边的元素。支持负索引，表示从右边开始计算。 删除列表中指定的值 1lrem key count value 返回实际删除的个数。 count &gt; 0时，lrem 从列表左边开始删除前 count 个值为 value 的元素。 count &lt; 0时，lrem 从右边删除前 |count| 个值为 value 的元素。 count = 0时，lrem 命令会删除所有值为 value 的元素。 实践 存储文章ID列表 发布文章时使用 lpush 把新ID加入列表中，删除文章时也要把列表中的ID删除。就可以使用 lrange 命令来实现文章的分页显示了。但更适合存储文章ID的方式是使用有序集合类型。 存储评论列表 如果评论不允许修改，且一般获取评论都是获取全部。所以可以使用列表来存储，使用列表类型键 post:文章ID:comments 来存储某个文章的所有评论。读取评论同样使用 lrange 即可。 命令拾遗 获得/设置指定索引的元素值 12lindex key indexlset key index value 只保留列表指定片段 1ltrim key start end ltrim常和lpush命令一起使用限制列表中元素的数量，比如只保留最近的100条日志。 12lpush logs newlogltrim logs 0 99 向列表中插入元素 123linsert key key BEFORE|AFTER pivot valuelinsert numbers before 7 3 将元素从一个列表转到另一个列表 1rpoplpush source destination 先对source执行rpop，然后将返回值lpush进destination，然后返回这个值。 source和destination相同时，此命令会不断地将队尾的元素移到队首。整个过程是原子的。 利用这个特性可以实现一个循环队列，可以无缝地加入新元素，或新的处理者。 集合类型介绍一个集合类型（set）键可以最多存储2的32次方-1个字符串。在 redis 中集合是用值为空的散列表实现的，所以这些操作的时间复杂度都是O(1)。 命令 增加/删除元素 12sadd key member [member ...]srem key member [member ...] 不存在则创建，存在则忽略。 返回本次成功加入/删除的元素数量（不包括已存在的元素）。 获得集合中的所有元素 1smembers key 判断元素是否在集合中 1sismember key member 集合间运算 123sdiff key [key ...]sinter key [key ...]sunion key [key ...] 实践 存储文章标签 12sadd post:12:tags 技术文章 redissmembers post:12:tags 通过标签搜索文章 为每个标签使用一个名为 tag:标签:posts 的集合类型存储该标签下的文章ID列表。获取属于多个标签的文章时，只需对这些键的集合进行 sinter 运算即可。 命令拾遗 获得集合中元素个数 1scard key 进行集合运算并将结果存储 123sdiffstore destination key [key ...]sinterstore destination key [key ...]sunionstore destination key [key ...] 此类命令常用于需要进行多步集合运算的场景中 随机获得集合中的元素 1srandmember key [count] count 为正数时，随机从集合中获得 count 个不重复的元素。如果 count 的值大于集合中的元素个数，则返回集合中的全部元素。 count 为负数时，随机从集合中获得 |count| 个元素，这些元素有可能重复。如果 |count| 的值大于集合中的元素个数，则返回 |count| 个元素，这些元素有可能重复。 srandmember 获得的结果并不够随机，原因： 从集合中弹出一个元素 1spop key 从集合中随机选择一个元素弹出（并删除）。 有序集合类型介绍sorted set，为每个元素都关联了一个分数，所以可以获得分数最高（最低）的前N个元素，可以获得指定分数范围内的元素等。 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。 有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(logN))。 列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。 有序集合要比列表类型更耗费内存。 命令 增加元素 1zadd key score member [score member ...] 元素不存在则新增，存在则更新分数。score可以是整数，浮点数，+/-inf等。 获得元素的分数 1zscore key member 获得排名在某个范围的元素列表 12zrange key start stop [withscores]zrevrange key start stop [withscores] 按分数的范围正向/反向获取元素[是否携带分数]，分数相同时按照字典顺序排序（中文按照UTF-8编码后的字母顺序）。start/stop 可以为正数、负数（从后往前数）、无限大。 获得指定分数范围的元素 12zrangebyscore key min max [withscores] [limit offset count]zrevrangebyscore key max min [withscores] [limit offset count] 根据分数范围返回元素，如果不希望返回端点值，可以在分数前面加上“（” 1zrangebyscore scoreboard 80 (100 增加某个元素的分数 1zincrby key increment member increment可以是正数/负数，如果member不存在，redis会先建立它并且设置分数为0，后再执行操作。 实践 实现按点击量排序 12345zincrby posts:page.view 1 文章IDzrevrange posts:page.view start endforeach idshgetall post:id 改进按时间排序 在支持更改发布时间，又想通过发布时间对文章进行排序的博客系统中，可以使用有序列表实现。元素的分数是文章发布的Unix时间戳。 命令拾遗 获得集合中元素的数量 1zcard key 获得指定分数范围内的元素数量 123zcount key min maxzcount scoreboard (89 +inf 删除一个或多个元素 1zrem key member [member ...] 按照排名范围删除元素 12345zremrangebyrank key start stopzadd test 1 a 2 b 3 c 4 d 5 f 6 ezremrangebyrank test 2 3zrange test 0 -1 按照分数范围删除元素 1zremrangebyscore key min max 获得元素的排名 12zrank key memberzrevrank key member 计算有序集合的交集 1zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] numkeys，key的个数。 weights，计算时被乘上的权重。 aggregate，最终值的计算方式。 zunionstore 同上。 进阶事务概述redis 的事务是一组命令的集合，一个事务中的命令要么都执行，要么都不执行。也可避免被其他客户端插队执行命令。 12345multi命令1命令2...exec 错误处理 语法错误 事务中的命令，只要有一个命令有语法错误，执行 Exec 命令后 Redis 就会直接返回错误，连语法正确的命令也不会执行。 运行错误 redis 不支持回滚（rollback），如果事务中有命令出现了运行错误，事务里其他的命令依然会继续执行。 watch命令介绍watch 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到 Exec 命令（事务中的命令是在Exec之后才执行的，所以在 Multi 命令后可以修改watch监控的键值）。Exec 执行后会取消对所有键的监控。或者执行 unwatch 命令来取消监控。由于 watch 命令的作用只是当被监控的健值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一健值，所以我们需要在 Exec 执行失败后重新执行整个函数。 过期时间命令介绍1expire key seconds 单位是秒。 1TTL key 返回一个键剩余有效期（单位是秒），当键不存在时会返回-2，当键没有设置过期时间（即永久存在，这是默认情况）时返回-1。 pexpire/pttl key，时间单位是毫秒。其他和上述命令一样。persist key，将键恢复称永久的。重新执行赋值，比如set，也会清除键的过期时间。 键时间到期并自动删除，并不会被 watch 命令认为该键被改变。 实现访问频率限制使用名为 rate.limiting:用户IP 的字符串类型键，创建后设置过期时间，然后每次用户访问则 incr 一次。大于某个值则返回超过限制。因为创建和设置过期时间是两个命令，所以最好放在一个事务内完成。 实现缓存实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存并让 Redis 按照一定的规则淘汰不需要的缓存键这种方式在只将 Redis 用作缓存系统时非常实用。 具体的设置方法为：修改配置文件的 maxmemory 参数，限制 Redis 最大可用内存大小（单位是字节），当超出了这个限制时 Redis 会依据 maxmemory-policy 参数指定的策略来删除不需要的键直到 Redis 占用的内存小于指定内存。 具体规则： LRU（LeastRecentlyused）算法即“最近最少使用”，即当需要空间时这些键是可以被删除的。实际上 redis 并不会准确地将整个教据库中最久未被使用的键删除。而是每次从数据库中随机取3个键并删除这3个键中最久未被使用的键。删除过期时间最接近的键也一样。“3”这个数字可以通过配置文件的 maxmemory-samples 参数设里。 排序有序集合的集合操作redis 没有类似于 zinter 的命令，可以自己实现：12345multizinterstore tempKey ...zrange tempKey ...del tempKey ...exec sort命令可以操作列表、集合、有序集合类型键进行排序。redis 对集合类型存储对象的Id的情况进行了特殊优化，元素的排列是有序的。 指定 ALPHA 参数，按照字典顺序排列。指定 DESC 参数，倒序排序。支持 LIMIT 参数，来进行分页。 by参数有时候单纯对ID排序意义不大，更多时候按照对象的某个属性排序，可以使用by参数。 12sort tag:ruby:postIds by post:*-&gt;time descsort sortlist by items:* desc 遍历Id，然后使用元素值替换参键件中第一个“”，并获取该值对元素排序，当键的元素值相同时，对键本身进行排序。参考键可以是字符串类型键或者是散列类型键的某个字段（的必须放在-&gt;前面）。 当参考键不包含“*”时，不执行排序操作。可以使用这个特性，借助 sort 命令和常量键名，获得与元素相关的数据。当某个元素的参考键不存在时，会取默认值为0。 get参数get 的作用是使 sort 命令的返回结果不再是元素自身的值，而是 get 参数中指定的键值。1sort tag:ruby:postIds by post:*-&gt;time desc get post:*-&gt;title [get ...] get #，会返回元素本身 store 参数保存结果，保存后的键类型为列表类型，如果键已经存在则会覆盖。store 参数常用来结合 expire 命令缓存排序结果。 性能优化sort 命令的时间复杂度是O(n+mlog(m))，n表示元素个数，m表示要返回的元素个数。 尽可能减少待排序键中元素的数量。 使用 limit 参数只获取需要的数据。 如果要排序的数据数量较大，尽可能使用 store 参数将结果缓存起来。 消息通知使用Redis实现任务队列12brpop key, timeoutbrpop key, timeout brpop 命令和 rpop 命令相似，唯一的区别是当列表中没有元素时 BRPOP 命令会一直阻塞住连接，直到有新元素加入。返回两个值，分别是键名和元素值。 优先级队列多重任务使用同一个队列的时候，可以设置不同的优先级。 1brpop queue:confirmation.email queue.notification.email 0 按照从左到右的顺序，在左边队列有元素可获得情况下，优先获取左边的队列的元素。 “发布/订阅”模式123publish channel messagepublish channel.1 hi 发布消息，返回接收到这条消息的订阅者数量。发出去的消息不会被持久化。 123subscribe channel [channel ...]subscribe channel.1 订阅消息，可以同时订阅多个频道。 收到的发布消息有三种类型，每种类型的回复都包含3个值。 按照规则订阅psubscribe，支持glob风格通配符格式。 1psubscribe channel.?* 管道客户端和 Redis 使用TCP协议链接，发送命令返回结果都需要经过网络传输，这两部分的总耗时称为往返时延。大致来说到本地回环地址（loopbackaddress）的往返时延在数量级上相当于 Redis 处理一条简单命令的时间。如果执行较多的命令，每个命令的往返时延累加起来对性能还是有一定影响的。Redis 的底层通信协议对管道（pipelining）提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回，从而实现降低往返时延影响的目的。 节省空间精简键名和键值，多使用缩写。 内部编码优化键中元素很少时，Redis 会采用一种更为紧凑但性能稍差（获取元素的时间复杂度为O(n)）的内部编码方式。内部编码方式的选择对于开发者来说是透明的，当键中元素变多时 Redis 会自动将该键的内部编码方式转换成散列表。使用 object encoding key 来查看编码方式，执行结果如图： 实践.Net Core与redis客户端参考：https://www.cnblogs.com/yilezhu/p/9947905.html python与redis安装 redis-py，pip install redis。 1234import redisr = redis.StrictRedis(host='127.0.0.1', password='123123')print(r.hgetall('post:1')) 简便用法 HMSET/HGETALL 123r.hmset('people', &#123;'name': 'bob'&#125;)people = r.hgetall('people')print(people) 事务和管道 事务： 123456pipe = r.pipeline()pipe.set('foo', 'bar')pipe.get('foo')result = pipe.execute()print(result) 管道： 1pipe = r.pipeline(transaction=False) 支持链式调用： 1print(r.pipeline().set('foo','bar').get('foo').execute()) 实践：在线的好友有时网站本来就要记录全站用户的最后访问时间，这时就可以直接利 数据获得最后一次访问发生在10分钟内的用户列表（即在线用户）。 最直接的方法就是将上面存储在线用户列表的 online_users 变量存入 Redis 的一个集合类型的键中然后和用户的好友列表取交集。然而这种方法需要在服务端 和客户端传输数据，如果在线用户多的话会有较大的网络开销，而且这种方法也不能通过 Redis 的事务功能实现原子操作。为了解决这些问题，我们希望实现一个方法将 ZRANGEBYSCORE 命令的结果直接存入一个新键中而不返回到客户端。思路如下： 脚本概览Redis 的脚本功能，允许开发者使用 Lua 语言编写脚本传到 Redis 中执行。在 Lua 脚本中可以调用大部分的 Redis 命令，类似于“存储过程”。 好处： 减少网络开销，只需发送一个请求即可。 原子操作。事务可以完成的所有功能都可以用脚本来实现。 复用。客户端发送的脚本会永久存储在 Redis 中，供以后复用。 Lua语言Lua，在葡萄牙语中是“月亮”的意思。 Lua语法 数据类型 Lua是一个动态类型语言，常用数据类型： 变量 Lua 的变量分为全局变量和局部变量。全局变量无需声明就可以直接使用，默认值是 nil。如： 123a = 1 -- 为全局变量a赋值print(b) -- 无需声明即可使用，默认值是nila = nil -- 删除全局变量a的方法是将其赋值为nil。全局变量没有声明和未声明之分，只有非nil和nil的区别 在 Redis 脚本中不能使用全局变量，只允许使用局部变量以防止脚本之间相互影响。 声明局部变量的方法为 local 变量名，就像这样： 123local c --声明一个局部变量c，默认值是nillocal d = 1 --声明一个局部变量d并赋值为1local e,f --可以同时声明多个局部变量 声明一个存储函数的局部变量的方法为： 123local say_hi = function() print 'hi'end 变量名必须是非数字开头，只能包含字母、数字和下划线，区分大小写。不能与保留字相同。 注释 单行注释 ：-- 多行注释： 123-- [[ 多行]] 赋值 Lua 支持多重赋值。 123local a,b = 1,2local c,d = 1,2,3 -- 3被舍弃了local e,f = 1 -- f的值是nil 执行多重赋值时，Lua 会先计算所有表达式的值。比如： 123local a = &#123;1,2,3&#125;local i = 1i, a[i] = i+1,5 计算所有表达式的值：i, a[1] = 2,5。所以最后结果是i为2，a为 {5,2,3}。 操作符 数学操作符，如果是字符串会自动转换成数字 比较操作符 逻辑操作符，not and or 连接操作符：..，用来连接两个字符串。比如： 1print('The price is ' .. 25) 取长度操作符 1print(#'hello') --5 if语句 1234567if 条件 then 语句elseif 条件 then 语句else 语句end Lua 中只有 nil 和 false 才是假，其他值（包括空字符串和0），都被认为是真。所以直接调用 12if redis.call('exists','key') then . ... 则调用结果永远为真，需要这样写： 12if redis.call('exists','key')==1 then ... Lua 可以省略’;’，也并不强制要求缩进。 循环语句 1234567891011while 条件 do 语句endrepeat 语句until 条件for 变量 = 初值，终值 [，步长] do 语句end 步长省略默认为1。 表类型 12345678a = &#123;&#125;a['field'] = 'value'print(a.field)people = &#123; name = 'Bolb', age = 29&#125; 索引为整数时，表和传统的数组一样： 123a = &#123;&#125;a[1] = 'Bob'a[2] = 'Jeff' Lua规定数组的索引从1开始。 遍历表： 1234for i,v in ipairs(a) do print(i) print(v)end ipairs 是内置函数，实现类似迭代器的功能。 1234for i =1, #a do print(i) print(a[i])end #a的作用是获取表a的长度。 1234for i,v in pairs(people) do print(i) print(v)end pairs 与 ipairs 的区别在于前者会遍历所有值不为 nil 的索引，而后者只会从索引1开始递增遍历到最后一个值不为nil的整数索引。 函数 123local square = function (num) return num * numend 简化： 123local function square (num) return num * numend 这段代码会被转换为： 1234local square square = function (num) return num * numend 递归，实参/形参，解包： 标准库12345Base --提供了一些基础函数String --提供了用于字符串操作的函数Table --提供了用于表操作的函数Math --提供了数学计算函数Debug --提供了用于调试的函数 文档：http://www.lua.org/manual/5.3/ String库 可以通过字符串类型的变量以 OOP 的形式访问，如 string.len(var) 可以写成 var:len()。 获取长度： 1string.len(str) 转换大小写： 12string.lower(str)string.upper(str) 截取： 1string.sub(str,start [, end]) end 为负数则从后面开始计算。 Table库 Table 库中的大部分函数处理的都是数组形式的表。 将数组转换为字符串： 123table.concat(table [, sep [, i [, j ]]])table.concat(&#123;1, 2, 3&#125;, ',' ,2) 向数组中插入元素： 1table.insert(table, [pos,] value) 默认插入到尾部。 1234a = &#123;1, 2, 4&#125;table.insert(a, 3, 3)table.insert(a, 5) --print(table.concat(a, ',')) --1,2,3,4,5 从数组中弹出一个元素： 1table.remove(table [,pos]) 默认从尾部弹出。 Math库 如果参数是字符串会自动尝试转换成数字： 其他库Redis 还通过 cjson 库和 cmsgpack 库提供了对 JSON 和 MessagePack 的支持。Redis 自动加载了这两个库，在脚本中可以分别通过 cjson 和 cmsgpack 两个全局变量来访问对应的库。 12345678910local people = &#123; name = 'Bob', aqe = 29&#125;local json_people_str = cjson.encode(people)local json_people_obj = cjson.decode(people)local msgpack_people_str = cmsgpack.pack(people)local msqpack_people_obj = cmsgpack.unpack(people) Redis与Lua在脚本中调用Redis命令12redis.call('set', 'foo', 'bar')local v = redis.call('get', 'foo') redis.call 函数会将 Redis 的5种返回类型转换成对应的Lua数据类型： 整数回复 -》 数字类型字符串回复 -》 字符串类型多行字符串回复 -》 表类型（数组形式）状态回复 -》 表类型（只有一个ok字段）错误回复 -》 表类型（只有一个err字段） 空结果比较特殊，对应Lua的false。Redis 还提供了 redio.pcall 函数，功能与 redis.call 相同，唯一的区别是当命令执行出错时 redis.pcall 会记录错误并继续执行，而 redis.call 会直接返回错误，不会继续执行。 从脚本中返回值同样 Redis 会自动将脚本返回值的 Lua 数据类型转换成 Redis 的返回值类型。转换关系与上节的规则相反。Lua 的 false 比较特殊，会被转换成空结果。 脚本相关命令 EVAL命令 1234eval 脚本内容 key参数的数量 [key ...] [arg ...]eval "return redis.call('set',KEYS[1], ARGV[1])" 1 foo barget foo # bar EVAL 命令依据第二个参数将后面的所有参数分别存入脚本中 KEYS 和 ARGV 两个表类型的全局变量．当脚本不需要任何参数时也不能省略这个参数（设为0). EVALSHA命令 Redis 在执行 EVAL 命令时会计算脚本的 SHA1 摘要并记录在脚本缓存中，执行 EVALSHA 命令时 Redis 会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果找到了则执行脚本，否则会返回错误，以此来节省带宽。 很多编程语言的 Redis 客户端执行 EVAL 命令时，都会代替开发者执行 EVALSHA 命令，失败了才会执行 EVAL 命令。 应用实例 获得并删除有序集合中分数最小的元素，有序集合没有弹出操作，可以通过脚本实现。 123456789101112131415import redisr = redis.StrictRedis(host='', password='')lua = """ local element = redis.call('ZRANGE',KEYS[1],0,0)[1] if element: redis.call('ZREM',KEYS[1],element) end return element"""ztop = r.register_script(lua)print(ztop(keys=['zset'])) 深入脚本KEYS与ARGV向脚本传递的参数分为 KEYS 和 ARGV 两类，为了兼容集群，在脚本中使用的键名最好使用 KEYS 参数传递的键名。 沙盒与随机数Redis 中使用脚本的限制： 禁止使用Lua标准库中与文件或系统调用相关的函数 禁用脚本的全局变量保证每个脚本都是相对隔离的 为了保证服务器的安全和不依赖外界条件，独立性。 Redis 还对脚本中的随机数和会产生随机结果的命令进行了特殊的处理： 其他脚本相关命令一般由客户端封装起来，开发者很少使用到。 将脚本加入缓存：script load 加入缓存而不执行，script load &quot;return 1&quot;。返回脚本的SHA1摘要。 判断脚本是否已经被缓存：script exists 查找1个或多个脚本的SHA1摘要是否被缓存。script exists e0e1... abd4...。 清空脚本缓存：script flush Redis将脚本的SHA1摘要加入到缓存后会永久保留，使用script flush命令清空脚本缓存。 强制终止当前脚本的执行：script kill 原子性和执行时间Redis 的脚本执行是原子的，执行期间不会执行其他命令。Redis 提供了 lua-time-limit 参数限制脚本的最长运行时间，默认为5秒钟。脚本运行时间超过这一默认为5秒钟。当脚本运行时间超过这一限制后，Redis 将开始接受其他命令但不会执行（以确保脚本的原子性），而是会返回“Busy”错误。 此时，如果脚本没有修改数据的话，可以通过 script kill 终止当前脚本的运行。如果有修改数据的话，可以使用 shutdown nosave 命令强行终止 redis。shutdown nosave 和 shutdown 的区别在于前者将不会进行持久化操作，发生在上一次快照后的数据库修改都将丢失。 持久化这时我们希望 Redis 能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。Redis 支持两种方式的持久化，RDB和AOF。前者会根据指定的规则“定时”将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，但更多情况下是将二者结合使用。 RDB方式当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为“快照”。Redis 会在以下几种情况下对数据进行快照： 根据配置规则进行自动快照 用户执行 save 或 bgsave 命令 执行 flushall 命令 执行复制（replication）时 根据配置规则进行快照配置规则由两个参数构成：时间窗口M和改动的键的个数N。每当时间M内被改动的键的个数大于N时，即符合自动快照条件。 123save 900 1save 300 10save 60 10000 第一行的意思是15分钟（900秒）内有一个或一个以上的键被更改则进行快照。多个条件之间是或的关系。 用户执行save或bgsave命令 save 同步阻塞其他所有请求执行快照操作，导致 redis 较长时间不响应，避免在生产环境使用。 bgsave 在后台异步地进行快照操作，继续相应其他请求。执行后立即返回 ok，然后通过 lastsave 命令获取最近一次成功执行快照的时间（unix时间戳）。 fluahsallredis 会清除数据库中所有数据。不论是否满足自动快照条件，只有自动快照条件不为空，redis 就会执行一次快照操作。当没有定义自动快照条件时，flushall 不会进行快照。 执行复制时主从模式中，redis 会在复制初始化时进行自动快照。 快照原理redis 默认将快照文件存储在 redis 当前进程工作目录中的 dump.rdb 文件中，可以通过配置 dir 和 dbfilename 指定快照文件的路径和名称。 快照的过程如下： Redis 使用 fork 函数复制一份当前进程（父进程）的副本（子进程）。 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件。 当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件，至此一次快照操作完成。 写时复制（copy-on-write）： 备份与加载rdb： AOF方式以纯文本的形式记录了 Redis 执行的写命令，可见 AOF 文件的内容正是 Redis 客户端向 Redis 发送的原始通信协议的内容。每当达到一定条件时 Redis 就会自动重写（压缩重复命令）AOF 文件，这个条件可以在配置文件中设置：12auto-aof-rewrite-percentaqe 100auto-aof-rewrite-min-size 64mb auto-aof-rewrite-percentaqe 参数的意义是当目前的 AOF 文件大小超过上一次重写时的 AOF 文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。auto-aof-rewrite-min-size参数限制了允许重写的最小 AOF 文件大小。 还可以主动使用 BGREWRITEAOF 命令手动执行 AOF 重写。在启动 Redis 时，会逐个执行AOF文件中的命令来将以硬盘中的数据载入到内存中，速度相较RDB会慢一些。 同步硬盘数据操作系统的缓存同步：事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要 Redis 在写入 AOF 文件后主动要求系统将缓存内容同步到硬盘中。 123# appendfsync alwaysappendfsync everysec# appendfsync no 默认是everysec，即每秒执行一次同步操作。即每次执行写入都会执行同步，这是最安全也是最慢的方式。no，表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。一般情况下使用everysec就足够了。 Redis 允许同时开启 AOF 和 RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后 Redis 会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。 集群复制replication 配置在复制的概念中，数据库分为两类，一类是主数据库（master)，另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。 启动从实例时指定主实例节点：1redis-server --port 6380 --repllicaof 127.0.0.1 6379 或运行时切换主实例：1slaveof 127.0.0.1 6379 查看节点的信息：1info replication 从数据库默认只读，可以修改 slave-read-only 为 no 使之可写，但是不建议。停止当前节点的同步，并可转换为主节点：1replicaof no one 原理Redis 实现复制的过程： 图结构从数据库自己也可以作为主数据库存在。 读写分离与一致性在常见的场景中，读的频率大于写。可以建立一主多从的结构来满足需求，通过复制功能建立多个从数据库节点，主数据库只进行写操作，而从数据库负责读操作。 从数据库持久化为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。 当从数据库崩溃重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。当主数据库崩溃时，需要严格按照以下两步进行： 在从数据库中使用 replicaof no one 命令将从数据库提升成主数据库继续服务。 启动之前崩溃的主数据库，然后使用 replicaof 命令将其设置成新的主数据库的从数据库，即可将数据同步回来。 注意：当开启复制且主数据库关闭持久化功能时，一定不要使用 Supervisor 以及类似的进程管理工具令主数据库崩清后自动重启．或直接手动重新启动。因为当主数据库重新启动后，因为没有开启持久化功能，所以数据库中所有数据都被清空，这时从数据库依然会从主数据库中接收数据，使得所有从数据库也被清空！ 更自动化的方案：哨兵。 无硬盘复制基于RDB方式的复制具有以下缺点： 当主数据库禁用RDB快照时（即删除了所有的配置文件中的 save 语句），如果执行了复制初始化操作，Redis 依然会生成RDB快照，所以下次启动后主数据库会以该快照恢复数据。因为复制发生的时间不能确定，这使得恢复的数据可能是任何时间点的。 因为复制初始化时需要在硬盘中创建RDB快照文件，所以如果硬盘性能很慢（如网络硬盘）时这一过程会对性能产生影响。 开启无硬盘复制选项：1repl-disless-sync yes 在与从数据库进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给从数据库，避免了硬盘的性能瓶颈。 增量复制当主从数据库链接断开后，从数据库会发送 SYNC 命令来重新进行一次完成复制操作，即使断开期间数据库的变化很小（甚至没有）。Redis 2.8版之后实现了主从断线重连的情况下的增量复制。 增量复制基于以下3点实现： 从数据库会存储主数据库的运行ID(run id）。每个 Redis 运行实例均会拥有一个唯一的运行ID，每当实例重启后，就会自动生成一个新的运行ID。 在复制同步阶段，主数据库每将一个命令传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中，并记录下当前积压队列中存放的命令的偏移量范围。 从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量。 2.8版之后，从数据库不再发送 SYNC 命令，取而代之的是发送 PSYNC，格式为：PSYNC 主数据库的运行ID 断开前最新的命令偏移量 主数据库收到 PSYNC 命令后，会执行以下判断决定此次重连是否可以执行增量复制： 首先主数据库会判断从数据库传送来的运行ID是否和自己的运行ID相同。以此确保从数据库之前确实是和自己同步的，以免从数据库拿到错误的数据。 然后判断从数据库最后同步成功的命令偏移量是否在积压队列中，执行增量复制，并将积压队列中相应的命令发送给从数据库。 如果不满足增量复制的条件，主数据库会进行一次全部同步。 积压队列，本质上是一个固定长度的循环队列。通过 repl-backlog-size 选项调整积压队列的大小，默认为1MB。积压队列越大，其允许的主从数据库断线的时间就越长。所以估算积压队列的大小只需要估算主从数据库断线的时间中主数据库可能执行的命令的大小即可。 repl-backlog-ttl，即当所有从数据库与主数据库断开连接后，经过多久时间可以释放积压队列的内存空间。默认1小时。 哨兵Redis2.8中提供了哨兵工具实现自动化系统监控和故障恢复功能。 什么是哨兵哨兵是一个独立的进程，作用是监控 Redis 系统的运行状况，包括两个功能： 监控主从数据库是否正常运行 主数据库出现故障时自动将从数据库转换为从数据库 马上上手建立一个配置文件，如 sentinel.conf，内容为：12sentinel monitor mymaster 127.0.0.1 6379 1sentinel auth-pass mymaster password mymaster 表示要监控的主数据库的名字，最后的1表示最低通过票数。接下来启动 Sentinel 进程。1redis-sentinel /etc/redis/sentinel.conf 配置哨兵监控一个系统时，只需要配置监控主数据库即可，哨兵会自动发现所有该主数据库的从数据库。 哨兵输出内容详解：12345678+slave #表示新发现了从数据库+sdown #表示哨兵主观认为主数据库停止服务了+odown #表示哨兵客观认为主数据库停止服务了+try-failover #表示哨兵开始进行故障恢复+failover-end #表示哨兵完成故障恢复，期间包括Leader选举，备选从数据库的选择+switch-master #表示主数据库切换-sdown #表示实例恢复服务+convert-to-slave #表示将实例设置为从数据库 停止服务的实例有可能会在之后恢复服务，当实例停止服务后，哨兵会更新该实例的信息（如主数据库停止之后，则保留设置它为从数据库），使得当其重新加入后可以按照当前信息继续对外提供服务。 实现原理因为考虑到故障恢复后当前监控的系统的主数据库的地址和端口会产生变化，所以哨兵提供了命令可以通过主数据库的名字获取当前系统的主数据库的地址和端口号。 一个哨兵节点可以同时监控多个 Redis 主从系统，只需要提供多个 sentinel monitor 配置即可，例如：12sentinel monitor mymaster 127.0.0.1 63792sentinel monitor othermaster 192.168.1.36 3804 同时多个哨兵节点也可以同时监控同一个 Redis 主从系统，配置文件中还可以定义其他监控相关的参数，每个配置选项都包含主数据库的名字使得监控不同主数据库时可以使用不同的配置参数。例如：12sentinel down-after-milliseconds mymaster 60000sentinel down-after-milliseconds othermaster 10000 哨兵启动后，会与要监控的主数据库建立两条连接，这两个连接的建立方式与普通的Redis客户端无异。其中一条连接用来订阅该主数据的 sentinel:hello 频道以获取其他同样监控该数据库的哨兵节点的信息，因为客户端的连接进入订阅模式时就不能再执行其他命令了，所以这时哨兵会使用另外一条连接来发送命令： 每10秒哨兵会向主数据库和从数据库发送 INFO 命令。 每2秒哨兵会向主数据库和从数据库的 sentinel:hello 频道发送自己的信息。 每1秒哨兵会向主数据库、从数据库和其他哨兵节点发送PING命令。 这3个操作贯穿哨兵进程的整个生命周期中，非常重要。 首先，发送 INFO 命令使得哨兵可以获得当前数据库的相关信息（包括运行ID、复制信息即从节点信息等）从而实现新节点的自动发现。而后对每个从数据库同样建立两个连接，在此之后，哨兵会每10秒定时向已知的所有主从数据库发送 INFO 命令来获取信息更新并进行相应操作，比如对新增的从数据库建立连接并加入监控列表，对主从数据库的角色变化（由故障恢复操作引起）进行信息更新等。 接下来哨兵向主从数据库的 sentinel:hello 频道发送信息来与同样监控该数据库的哨兵分享自己的信息。发送的消息内容为： ＜地址＞,＜端口＞,&lt;运行ID&gt;,＜配置版本&gt;,＜主数据库的名字＞,＜主数据库的地址＞,＜主数据库的端口＞,＜主数据库的配置版本＞ 可以看到消息包括的哨兵的基本信息，以及其监控的主数据库的信息。前文介绍过，哨兵会订阅每个其监控的数据库的 sentinel:hello 频道，所以当其他哨兵收到消息后，会判断发消息的哨兵是不是新发现的哨兵。如果是则将其加入已发现的哨兵列表中并创建一个到其的连接（与数据库不同，哨兵与哨兵之间只会创建一条连接用来发送PING命令，而不需要创建另外一条连接来订阅频道，因为哨兵只需要订阅数据库的频道即可实现自动发现其他哨兵）。同时哨兵会判断信息中主数据库的配置版本，如果该版本比当前记录的主数据库的版本高，则更新主数据库的数据。 实现了自动发现从数据库和其他哨兵节点后，哨兵要做的就是定时监控这些数据库和节点有没有停止服务。这是通过每隔一定时间向这些节点发送PING命令实现的。时间间隔与 down-after-milliseconds 选项有关，down-after-milliseconds 小于1秒时，哨兵会每隔指定的时间发送一次PING命令，大于1秒时，哨兵会每隔1秒发送一次PING命令。 当超过 down-after-milliseconds 选项指定时间后，如果被PING的数据库或节点仍然未进行回复，则哨兵认为其主观下线(subjectively down)。如果该节点是主数据库，则哨兵会进一步判断是否需要对其进行故障恢复：哨兵发送 sentinel is-master-down-by-addr 命令询问其他哨兵节点以了解他们是否也认为该主数据库主观下线，如果达到指定数量时，哨兵会认为其客观下线（objectively down)，并选举领头的哨兵节点对主从系统发起故障恢复。这个指定数量即为quorum参数。例如：1sentinel monitor mymaster 127.0.0.1 6379 2 该配置表示只有当至少两个 Sentinel 节点（包括当前节点）认为该主数据库主观下线时，当前哨兵节点才会认为该主数据库客观下线。进行接下来的选举领头哨兵步骤。故障恢复需要由领头的哨兵来完成，这样可以保证同一时间只有一个哨兵节点来执行故障恢复。选举使用Raft算法，具体过程（https://raft.github.io）如下： 发现主数据库客观下线的哨兵节点（下面称作A）向每个哨兵节点发送命令，要求对方选自己成为领头哨兵。 如果目标哨兵节点没有选过其他人，则会同意将A设置成领头哨兵。 如果A发现有超过半数且超过 quorum 参数值的哨兵节点同意选自己成为领头哨兵，则A成功成为领头哨兵。 当有多个哨兵节点同时参选领头哨兵，则会出现没有任何节点当选的可能。此时每个参选节点将等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。 选出领头哨兵后，领头哨兵将会开始对主数据库进行故障恢复。过程具体如下： 首先领头哨兵将从停止服务的主数据库的从数据库中挑选一个来充当新的主数据库。挑选的依据如下： 所有在线的从数据库中，选择优先级最高的从数据库。优先级可以通过 slave-priority 选项来设置。 如果有多个最高优先级的从数据库，则复制的命令偏移量越大（即复制越完整）越优先。 如果以上条件都一样，则选择运行ID较小的从数据库。 选出一个从数据库后，领头哨兵将向从数据库发送 slaveof no one 命令使其升格为主数据库。而后领头哨兵向其他从数据库发送 slaveof 命令来使其成为新主数据库的从数据库。最后一步则是更新内部的记录，将已经停止服务的旧的主数据库更新为新的主数据库的从数据库，使得当其恢复服务时自动以从数据库的身份继续服务。 集群即使使用哨兵，此时的Redis集群的每个数据库依然存有集群中的所有数据，从而导致集群的总数据存储量受限于可用存储内存最小的数据库节点，形成木桶效应。 Redis 3.0版的一大特性就是支持集群，集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令。集群也存在一些限制，对于涉及多键的命令（如MGET)，如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外还有一个限制是只能使用默认的0号数据库，如果执行 select 切换数据库则会提示错误。 哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容，则集群是一个非常好的选择。 配置集群只需要将每个数据库节点的 cluster-enabled 配置选项打开即可。每个集群中至少需要3个主数据库才能正常运行。 集群会将当前节点记录的集群状态持久化地存储在指定文件中，这个文件默认为当前工作目录下的 nodes.conf 文件。每个节点对应的文件必须不同，否则会造成启动失败，所以启动节点时要注意最后为每个节点使用不同的工作目录，或者通过 cluster-config-file 选项修改持久化文件的名称。 判断集群是否正常启用：1info cluster 每个节点启动后都是完全独立的，需要将它们加入同一个集群里。redis-trib.rb 可以非常方便地完成这一任务。运行前需要在服务器上安装Ruby程序，redis-trib.rb 依赖于 gem 包 redis，可以执行 gem install redis 来安装。 使用 redis-trib.rb 来初始化集群，只需要执行：1/path/to/redis-trib.rb create --replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1 6384 127.0.0.1 6385 –replicas 1 表示每个主数据库拥有的从数据库个数为1，所以整个集群共有3（6/2）个主数据库以及3个从数据库。 运行后的输出内容包括集群具体的分配方案： 首先 redis-trib.rb 会以客户端的形式尝试连接所有的节点，并发送PING命令以确定节点能够正常服务。如果有任何节点无法连接，则创建失败。同时发送INFO命令获取每个节点的运行ID以及是否开启了集群功能（即clusterenabled为1）。 准备就绪后集群会向每个节点发送 CLUSTER MEET 命令，格式为 CLUSTER MEET ip port，这个命令用来告诉当前节点指定ip和port上在运行的节点也是集群的一部分，从而使得6个节点最终可以归入一个集群。 然后 redis-trib.rb 会分配主从数据库节点，分配的原则是尽量保证每个主数据库运行在不同的IP地址上，同时每个从数据库和主数据库均不运行在同一IP地址上，以保证系统的容灾能力。分配结果如下： 1234567Using 3 masters:127.0.0.1:6380127.0.0.1:6381127.0.0.1:6382Adding replica 127.0.0.1:6383 to 127.0.0.1:6380Adding replica 127.0.0.1:6384 to 127.0.0.1:6381Adding replica 127.0.0.1:6385 to 127.0.0.1:6382 分配完成后，会为每个主数据库分配插槽，分配插槽的过程其实就是分配哪些键归哪些节点负责，之后对每个要成为子数据库的节点发送 CLUSTER REPLICATE 主数据库的运行ID 来将当前节点转换成从数据库并复制指定运行ID的节点（主数据库）。 此时整个集群的过程即创建完成，使用 Redis 命令行客户端连接任意一个节点执行 CLUSTER NODES 可以获得集群中的所有节点信息。 节点的增加加入新的节点，也使用 CLUSTER MEET 命令实现。 只需要向新节点（以下记作A）发送如下命令即可：1CLUSTER MEET ip port ip和port是集群中任意一个节点的地址和端口号，A接收到命令后，会与该地址和端口号的节点B进行握手，使B将A认作当前集群中的一员。握手成功后，B会使用Gossip（分布式系统中常用的一种通信协议）协议将节点A的信息通知给集群中的每一个节点。所以即使集群中有多个节点，也只需要选择MEET其中任意一个节点，即可使新节点最终加入整个集群中。 插槽的分配新的节点加入集群后有两种选择：要么使用 CLUSTER REPLICATE 命令复制每个主数据库来以从数据库的形式运行，要么向集群申请分配插槽（slot）来以主数据库的形式运行。 在一个集群中，所有的键会被分配给16384个插槽，而每个主数据库会负责处理其中的一部分插槽。在创建集群时的输出中：1** 127.0.0.1:6380 slots:0-5460 (5461 slots) master 代表6380负责0~5460这部分的插槽。Redis 分配插槽时并不一定必须连续分配，可以任意分配几个插槽给任意节点。 插槽与键的关系，Redis 将每个键的键名的有效部分使用CRC16算法计算出散列值，然后取对16384的余数。这样每个键都可以分配到16384个插槽中，对应指定的一个节点中。键名的有效部分是指： 如果键名包含 { 符号，且在 { 符号后面存在｝符号，并且 { 和 } 之间有至少一个字符，则有效部分是指 { 和 } 之间的内容。 如果不满足上一条规则，那么整个键名为有效部分。 前面说如果命令涉及多个键（如MGET)，只有当所有键都位于同一个节点时Redis才能正常支持。利用键的分配规则，可以将所有相关的键的有效部分设置成同样的值使得相关键都能分配到同一个节点以支持多键操作。比如，{user102}:first.name 和 {user102}:last.name 会被分配到同一个节点，所以可以使用 MGET {user102}:first.name {user102}:last.name 来同时获取两个键的值。 如何将插槽分配给指定节点呢？ 插槽的分配分为如下几种情况： 插槽之前没有被分配过，现在想分配给指定节点。 插槽之前被分配过，现在想移动到指定节点。 第一种情况在指定节点使用 CLUSTER ADDSLOTS 命令来实现，redis-trib.rb 也是通过该命令在创建集群时为新节点分配插槽的。 1CLUSTER ADDSLOTS slot1 [slot2] …[slotN] 如果指定插槽已经分配过了，则会提示：(error) ERR Slot 100 is already busy。可以通过命令 CLUSTER SLOTS 来查看插槽的分配情况，返回4行数据，1，2行为插槽的开始结束号，3，4行为主从数据库信息。 第二种情况： 1/path/to/redis-trib.rb reshard 127.0.0.1:6380 执行重新分片命令，6380是集群中任意一个节点的地址和端口。 How many slots do you want to move(from 1 to 16384)?想要迁移多少个插槽，输入数字后回车。 What is the receiving node ID？可以通过 CLUSTER NODES 命令获取6381的运行ID，输入并回车。接着最后一步是询问从哪个节点移出插槽，我们输入6380对应的运行ID按回车，然后再输入done再按回车确认即可。 不借助redis-trib.rb手工进行重新分片：1CLUSTER SETSLOT 插槽号 NODE 新节点的运行ID SETSLOT 迁移插槽时，并不会把插槽中的键一起迁移。为此需要手动获取插槽中存在哪些键，然后将所有键迁移到新节点后，再迁移插槽，否则会造成对客户端来说键“丢失了”。123CLUSTER GETKEYSINSLOT 插槽号 要返回的键的数量MIGRATE 目标节点地址 目标节点端口 键名 数据库号码 超时时间 [COPY] [REPLACE] COPY 表示不将键从当前数据库中删除而是复制，REPLACE 表示如果存在同名键，则覆盖。集群模式中数据库号码只能为0。 为了避免迁移过程中相关键的临时“丢失”现象，Redis 提供了如下两个命令来实现集群不下线的情况下迁移数据： 123CLUSTER SETSLOT 插槽号 MIGRATING 新节点的运行 IDCLUSTER SETSLOT 插槽号 IMPORTING 原节点的运行ID 进行迁移时，假设要把0号插槽从A迁移到B，此时 redis-trib.rb 会依次执行如下操作： 在B执行CLUSTER SETSLOT 0 IMPORTING A。 在A执行CLUSTER SETSLOT 0 MIGRATING B。 执行CLUSTER GETKEYSINSLOT 0获取0号插槽的键列表。 对第3步获取的每个键执行MIGRATE命令，将其从A迁移到B。 执行CLUSTER SETSLOT 0 NODE B来完成迁移。 执行完前两步后，当客户端向A请求插槽0中的键时，如果键存在（即尚未被迁移），则正常处理，如果不存在，则返回一个ASK跳转请求，告诉客户端这个键在B里，客户端接收到后，首先向B发送 ASKING 命令，然后再重新发送之前的命令。相反，当客户端向B请求插槽0中的键时，如果前面执行了ASKING命令，则返回键值内容，否则返回MOVED跳转请求。这样一来可以在数据库迁移时自动从正确的节点获取到相应的键值，避免了键在迁移过程中临时“丢失”的问题。 获取与插槽对应的节点当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，则会像单机实例一样正常处理该命令：如果键不在该节点中，就会返回一个 MOVE 重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求向目标节点重新发送一次以获得结果。1redis-cli -c -p 6380 -c支持自动重定向。 集群的命令重定向增加了请求次数，所以客户端应该缓存插槽的路由信息，每次命令将均只发向正确的几点，来尽量减少重定向的次数。 故障恢复集群中每个节点每隔1秒钟就会随机选择5个节点，然后选择其中最久没有响应的节点发送PING命令。如果目标节点没有响应回复，则发起命令的节点会认为目标节点疑似下线（PFAIL），与哨兵的主观下线类似，过程具体为： 一旦节点A认为节点B是疑似下线状态，就会在集群中传播该消息，所有其他节点收到消息后都会记录下这一信息。 当集群中的某一节点C收集到半数以上的节点认为B是疑似下线的状态时，就会将B标记为下线（FAIL)，并且向集群中的其他节点传播该消息，从而使得B在整个集群中下线。 在集群中，当一个主数据库下线时，就会出现一部分插槽无法写入的问题。这时如果该主数据库拥有至少一个从数据库，集群就进行故障恢复操作来将其中一个从数据库转变成主数据库（Raft算法）来保证集群的完整。如果一个至少负责一个插槽的主数据库下线且没有相应的从数据库可以进行故障恢复，则整个集群默认会进入下线状态无法继续工作。可以修改配置cluster-require-full-coverage为no（默认为yes)，使集群仍能正常工作。 管理1bind 127.0.0.1 只允许本机应用连接Redis。1requirepass **** 设置密码。 配置 Redis 复制时如果主数据设置了密码，从数据库的配置文件中通过 masterauth 参数设置主数据库的密码。 重命名命令，保护关键命令：1rename-command flushall oyfekdjsm412jdssajt9dkslertl 以保证只有自己的应用可以使用该命令。1rename-command FLUSHALL "" 设置为空直接禁用某个命令。 通信协议Redis 支持两种通信协议，一种是二进制安全的统一请求协议，另一种是比较直观的便于在 telnet 程序中输入的简单协议。两种协议只是命令的格式有区别，命令返回值的格式是一样的。 简单协议简单协议适合在 telnet 程序中和Redis通信。 1telnet 127.0.0.1 6379 redis-cli 中的返回格式都是经过封装的，真正的返回格式如下： 错误回复 错误回复（error reply）以-开头，并在后面跟上错误信息，最后以\r\n结尾： -ERR unknown command &#39;ERRORCOMMAND&#39;\r\n 状态回复 状态回复（status reply）以+开头，并在后面跟上状态信息，最后以\r\n结尾： +OK\r\n 整数回复 整数回复（integer reply）以:开头，并在后面跟上数字，最后以\r\n结尾： :3\r\n 字符串回复 字符串回复（bulk reply）以$开头，并在后面跟上字符串的长度，并以\r\n分隔，接着是字符串的内容和\r\n: $3\r\nbar\r\n 如果返回值是空结果nil，则会返回$-1以和空字符串相区别。 多行字符串回复 多行字符串回复（multi-bulk-reply）以*开头，并在后面跟上字符串回复的组数，并以\r\n分隔。接着后面跟的就是字符串回复的具体内容了：*3\r\n$1\r\n3\r\n$1\r\n2\r\n$1\r\n1\r\n 统一请求协议命令格式和多行字符串回复的格式很类似。 SET foo bar 的统一请求协议写法是：*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n。Redis的AOF文件和主从复制时主数据库向从数据库发送的内容都使用了统一请求协议。如果要开发一个和Redis直接通信的客户端，推荐使用此协议。 管理工具redis-cli实用命令： 耗时命令日志 当命令的执行时间超过 slowlog-log-slower-than 配置的时间（单位是微秒，1000000微秒=1秒。默认是10000。设置为0纪录所有命令，设置为负数时关闭日志）时，Redis会将该命令的执行时间等信息加入耗时命令日志。耗时命令日志存储在内存中 slowlog-max-len 参数限制纪录的条数。 SLOWLOG GET 获取当前的耗时命令日志，每条日志都由以下4个部分组成： 该日志唯一ID 该命令执行的Unix时间 该命令的耗时时间，单位是微秒 命令及其参数 命令监控 MONITOR 命令监控 Redis 执行的所有命令，非常影响 Redis 的性能，一个客户端使用 MONITOR 命令会降低 Redis 将近一半的负载能力。 redis-faina，Instagram 团队开发的基于 MONITOR 命令的 Redis 查询分析程序。输入值为一段时间的 MONITOR 命令执行结果。 1redis-cli MONITOR | head -n &lt;要分析的命令数&gt; | ./redis-faina.py 附录Redis命令属性Redis 的不同命令拥有不同的属性，如是否是只读命令，是否是管理员命令等，一个命令可以拥有多个属性。在一些特殊情况下不同属性的命令会有不同的表现。 REDIS_CMD_WRITE 拥有 REDIS_CMD_WRITE 属性的命令的表现是会修改 Redis 数据库的数据。一个只读的从数据库会拒绝执行拥有REDIS_CMD_WRITE属性的命令。另外在Lua脚本中执行了拥有 REDIS_CMD_RANDOM 的命令后，不可以再执行拥有 REDIS_CMD_WRITE 属性的命令，否则会提示错误。 REDIS_CMD_DENYOOM 拥有 REDIS_CMD_DENYOOM 属性的命令有可能增加 Redis 占用的存储空间，显然拥有该属性的命令都拥有 REDIS_CMD_WRITE 属性，但反之则不然。如 DEL 命令。 当数据库占用的空间达到了配置文件中 maxmemory 参数指定的值且根据 maxmemory-policy 参数的空间释放规则无法释放空间时，Redis 会拒绝执行拥有REDIS_CMD_DENYOOM 属性的命令。 拥有 REDIS_CMD_DENYOOM 属性的命令每次调用时不一定都会使数据库的占用空间增大，只是有可能而已。例如，SET 命令当新值长度小于旧值时反而会减少数据库的占用空间．但无论如何，当数据库占用空间超过限制时，Redis 都会拒绝执行，而不会分析其实际上是不是会真的增加空间占用。 REDIS_CMD_NOSCRIPT 拥有 REDIS_CMD_NOSCRIPT 属性的命令无法在 Redis 脚本中执行。 提示 EVAL 和 EVALSHA 命令也拥有该属性，所以在脚本中无法调用这两个命令，即不能在脚本中调用脚本。 REDIS_CMD_RANDOM 当一个脚本执行了拥有 REDIS_CMD_RANDOM 属性的命令后，就不能执行拥有 REDIS_CMD_WRITE 属性的命令了。 REDIS_CMD_SORT_FOR_SCRIPT 拥有 REDIS_CMD_SORT_FOR_SCRIPT 属性的命令会产生随机结果，在脚本中调用这些命令时 Redis 会对结果进行排序。 REDIS_CMD_LOADING 当 Redis 正在启动时（将数据从硬盘载入到内存中），Redis 只会执行拥有 REDIS_CMD_LOADING 属性的命令。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解_注释笔记]]></title>
    <url>%2F2018%2F11%2F29%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[算法简介二分查找对数：对数运算是幂运算的逆运算。 公式 logn 相当于 log2n。 代码实现： 12345678910111213141516171819202122def binary_search(list, item): low = 0 high = len(list)-1 while low &lt;= high: mid = (low + high) // 2 guess = list[mid] if guess == item: return mid if guess &gt; item: high = mid-1 else: low = mid+1 return Nonelist = [1, 2, 5, 6, 7]item = 7print(binary_search(list, item)) 大O表示法假设列表包含n个元素。简单查找法需要检查每个元素，因此需要执行n次操作。使用大O表示法，这个运行时间为O(n)。单位是秒吗？不是，大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较“操作次数”，它指出了算法运行时间的增速。随着n的增长，操作次数的变化趋势。 大O表示法指出了最糟情况下的运行时间 经常会遇到的5种大O运行时间： O(logn)，也叫对数时间，这样的算法包括二分查找 O(n)，也叫线性时间，这样的算法包括简单查找 O(n * logn)，这样的算法包括快速排序——一种速度较快的排序算法 O(n2)，这样的算法包括选择排序——一种速度较慢的排序算法 O(n!)，这样的算法包括旅行商问题的解决方案——一种非常慢的算法 不同算法运行时间： 选择排序数组和链表数组添加新元素的速度很慢。就像你与朋友去看电影，找到地方就坐后又来了一位朋友，而当前坐的地方没有空位，你们就得转移，太麻烦了。虽然可以预留座位，但是你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。人数超过预留座位后，你还得转移。 链表链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起，根本就不需要移动元素。链表相当于说“我们分开来坐”，因此，只要有足够的内存空间，就能为链表分配内存。 数组需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃（比如读取最后一个元素时），链表的效率真的很低。就像排行榜网站上面，想查看下一项内容，就要点击“下一页”才能看到。 数组和链表： 在中间插入使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。而使用数组时，则必须将后面的元素都向后移。如果没有足够的空间，可能还得将整个数组复制到其他地方。因此，当需要在中间插入元素时，链表是更好的选择。 删除要删除元素时，链表也是更好的选择，因为只需修改前一个元素指向的地址即可（前提是能直接访问到这个元素）。而使用数组时，删除元素后，必须将后面的元素都向前移。 选择排序假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。 选择排序：遍历列表，找到列表中播放次数最大的歌曲，然后将该歌曲添加到一个新列表中。重复这个过程。*大O表示法省略诸如1/2这样的常数，因此O(n × 1/2 × n)简单地写作O(n × n)或O(n2)。 代码实现： 123456789101112131415161718def findSmallest(arr): smallest_index = 0 smallest = arr[0] for i in range(1, len(arr)): if smallest &gt; arr[i]: smallest = arr[i] smallest_index = i return smallest_indexdef selectionSort(arr): newArr = [] for _ in range(len(arr)): # 执行n遍 smallest = findSmallest(arr) newArr.append(arr.pop(smallest)) return newArrprint(selectionSort([2, 76, 1, 6, 12, 75, 2, 21])) 递归如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。 基线条件和递归条件递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 栈栈就好比一个待办事项清单–一叠便条，这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。 快速排序分而治之分而治之（divide and conquer，D&amp;C） ——一种著名的递归式问题解决方法。 D&amp;C的工作原理： 找出简单的基线条件 确定如何缩小问题的规模，使其符合基线条件 D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。 分治： 12345678910111213141516171819arr = [2, 1, 5, 2, 1, 3, 6]# 尾调用优化def calculSum(sum, arr): if len(arr) == 1: return sum + arr[0] else: return calculSum(sum+arr[0], arr[1:])print(calculSum(0, arr))# 一般形式def calculSum(arr): if len(arr) == 1: return arr[0] else: return arr[0] + calculSum(arr[1:])print(calculSum(arr)) 快速排序 选择基准值 分区（partitioning）：根据基准值把所有元素分为比基准值小的元素和比基准值大的元素 对这两个子数组进行快速排序 合并 以此类推 归纳证明：归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。 对于快速排序，基线条件是，我证明这种算法对空数组或包含一个元素的数组管用。归纳条件是，我证明如果快速排序对包含一个元素的数组管用，对包含两个元素的数组也将管用；如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用，以此类推。因此，我可以说，快速排序对任何长度的数组都管用。 代码实现： 1234567891011def qsort(arr): if len(arr) &lt;= 1: return arr pivot = arr[0] less = [i for i in arr[1:] if i &lt;= pivot] greater = [i for i in arr[1:] if i &gt; pivot] return qsort(less) + [pivot] + qsort(greater)print(qsort([7, 32, 1, 3, 87, 23, 64, 11, 40])) 再谈大O表示法常见算法复杂度： 比较归并排序和快速排序快速排序平均情况下运行时间为O(n logn)，最糟的情况下为O(n2)，而归并排序的运行时间总是O(n logn)。 123456from time import sleepdef print_items2(list): for item in list: sleep(1) print(item) 上面函数的运行时间也为O(n)，但是因为休眠所以慢得多。在O(n)中，n实际上指的是次数，而运行总时间为c * n，c为算法所需的固定时间量，被称为常量。所以上面算法的总时间为1秒 * n。如果两种算法的大O运行时间不同，这种常量将无关紧要。但有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。快速查找的常量比归并查找小，因此如果它们的运行时间都为O(n * logn)，快速查找的速度将更快。平均情况下，快排比归并的速度更快。而相对于最糟的情况，平均情况的可能性要大得多。 平均情况和最糟情况最糟情况：假设你总是将第一个元素用作基准值，且要处理的数组是有序的。 平均情况： 总结： D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n * logn) 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(logn)的速度比O(n)快得多 散列表Hash Table 散列函数散列函数 散列函数准确地指出了元素的存储位置，你根本不用查找！之所以能够这样，具体原因如下: 散列函数总是将同样的输入映射到相同的索引 散列函数将不同的输入映射到不同的索引 散列函数知道数组有多大，只返回有效的索引 散列表是一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置，使用数组来存储数据，因此其获取元素的速度与数组一样快。 冲突冲突（collision），处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。 散列函数很重要。最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。 如果散列表存储的链表很长，散列表的速度将急剧下降。 性能要避免冲突，需要有： 较低的填装因子 良好的散列函数 填装因子，即占用的位置数/位置总数。一旦填装因子大于0.7，就需要调整散列表的长度。调整长度的开销很大，因此你不会希望频繁地这样做。良好的散列函数，让数组中的值呈均匀分布，糟糕的散列函数让值扎堆，导致大量的冲突。 广度优先搜索图，图由节点和边组成，一个节点可能与众多节点直接相连，这些节点被称为邻居。广度优先搜索（BFS），让你能够找出两样东西之间的“最短”距离，是一种用于图的查找算法。回答两类问题： 从节点A出发，有前往节点B的路径吗？ 从节点A出发，前往节点B的哪条路径最短？ 队列，FIFO的数据结构，类似于排队上车。栈，LIFO的数据结构。类似于桌子上的一叠纸牌。树，是一种特殊的单向图。 实现图表示邻近关系可以用散列表。 1234graph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"]graph["bob"] = ["anuj", "peggy"]... 这被称为有向图（directed graph），其中的关系是单向的。因此，Anuj是Bob的邻居，但Bob不是Anuj的邻居。无向图（undirected graph）没有箭头，直接相连的节点互为邻居。 实现算法12345678910111213141516171819202122232425262728293031from collections import dequegraph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"]graph["bob"] = ["anuj", "peggy"]graph["alice"] = ["peggy"]graph["claire"] = ["thom", "jonny"]graph["anuj"] = []graph["peggy"] = []graph["thom"] = []graph["jonny"] = ['you']def search(name): search_queue = deque() search_queue += graph[name] searched = [] while search_queue: person = search_queue.popleft() if person not in searched: if person_is_seller(person): print(person + " is a mango seller!") break else: search_queue += [p for p in graph[person] if p not in searched] searched.append(person)def person_is_seller(name): return name[-1] == 'm' # 假设条件search('you')print('end') 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。对于检查过的人，务必不要再去检查，否则可能导致无限循环。 运行时间 如果你在你的整个人际关系网中搜索，就意味着你将沿每条边前行，因此运行时间至少为O(边数)。你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。 狄克斯特拉算法狄克斯特拉算法Dijkstra’s algorithm 4个步骤： 找出当前节点（可能是起点或其他节点）的邻居节点中，最便宜的（未处理）节点。对于还不知道的节点，暂假设为无穷大 计算经最便宜的节点前往其各个邻居所需的开销。更新从起点到各个节点的最短开销 重复这个过程，直到对图中每个节点都这样做了 计算最终路径 术语带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。狄克斯特拉算法，让你能够找出加权图中前往X的最短路径。狄克斯特拉算法只适用于有向无环图，在无向图中，每条边都是一个环。 案例：换钢琴交换图： 交换第二步： 最终路径： 负边权负边权路径： 如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。这是因为狄克斯特拉算法这样假设：对于处理过的节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。在包含负权边的图中，要找出最短路径，可以用贝尔曼福德算法（Bellman-Fordalgorithm）。 实现要编写解决这个问题的代码，需要三个散列表： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import operator# 路线图表graph = &#123;&#125;graph['start'] = &#123;&#125;graph['start']['a'] = 6graph['start']['b'] = 2graph['a'] = &#123;&#125;graph['a']['fin'] = 1graph['b'] = &#123;&#125;graph['b']['a'] = 3graph['b']['fin'] = 5graph['fin'] = &#123;&#125; # 终点没有邻居# 开销表，从起点到此节点的最少开销（可能被更新）infinity = float('inf')costs = &#123;&#125;costs['a'] = 6costs['b'] = 2costs['fin'] = infinity # 暂时不知道开销的节点可以用无限大表示# 父节点表parents = &#123;&#125;parents['a'] = 'start'parents['b'] = 'start'parents['fin'] = Noneprocessed = []def find_lowest_cost_node(costs): unpro_costs = &#123;k: v for k, v in costs.items() if k not in processed&#125; return min(unpro_costs, key=lambda x: unpro_costs[x]) if unpro_costs else Nonenode = find_lowest_cost_node(costs) # 找出开销最低的节点while node is not None: cost = costs[node] neighbors = graph[node] # 获得该节点的所有邻居 for n in neighbors.keys(): # 遍历邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: # 如果开销更小 costs[n] = new_cost # 更新开销 parents[n] = node # 更新父节点 processed.append(node) node = find_lowest_cost_node(costs) 贪婪算法贪婪算法，每步都采用局部最优解，最终得到的就是近似全局最优解。完美是优秀的敌人，有时候只需找到一个能够大致解决问题的算法，此时贪婪算法正好派上用场。因为它们实现起来很容易，得到的结果又与正确结果相当接近。 集合覆盖问题 代码实现： 12345678910111213141516171819202122232425states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"])stations = &#123;&#125;stations["kone"] = set(["id", "nv", "ut"])stations["ktwo"] = set(["wa", "id", "mt"])stations["kthree"] = set(["or", "nv", "ca"])stations["kfour"] = set(["nv", "ut"])stations["kfive"] = set(["ca", "az"])final_stations = set()while states_needed and stations: best_station = None states_covered = set() for station, states_for_station in stations.items(): coverd = states_needed &amp; states_for_station # % 交集，| 并集，- 差集 if len(coverd) &gt; len(states_covered): best_station = station states_covered = coverd final_stations.add(best_station) states_needed -= states_covered stations.pop(best_station)print(final_stations)print(states_needed) NP 完全问题旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 NP完全问题无处不在！没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的： 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢 涉及“所有组合”的问题通常是NP完全问题 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题 动态规划背包问题 网格： 多行： 更新： 最终: 背包问题FAQ问：沿着一列往下走时，最大价值有可能降低吗？答：不可能。每次迭代时，你都存储当前的最大价值。最大价值不可能比以前低！ 问：行的排列顺序发生变化时结果会变化吗？答：最终结果不会变化。 问：增加一件更小（重量有小数点）的商品将如何呢答：你需要考虑的粒度更细，因此必须调整网格。 最长公共子串动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 最长公共子串： 这个问题的最终答案并不在最后一个单元格中。 最长公共子序列FOSH和FORT，最长公共子串是2。FOSH和FISH，最长公共子串也是2。但是后者的相同字母（也就是最长公共子序列）更多，更相像。 最长子序列： 动态规划的实际应用： 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。还被用来寻找多发性硬化症治疗方案 git diff Microsoft Word的断字功能 动态规划的特点： 需要在给定约束条件下优化某种指标时，动态规划很有用 问题可分解为离散子问题时，可使用动态规划来解决 每种动态规划解决方案都涉及网格 单元格中的值通常就是你要优化的值 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题 没有放之四海皆准的计算动态规划解决方案的公式 K最近邻算法k-nearest neighbours，KNN。 你将使用KNN来做两项基本工作——分类和回归：分类就是编组；回归就是预测结果（如一个数字）。 特征抽取，即将物品（如水果或用户）转换为一系列可比较的数字。能否挑选合适的特征事关KNN算法的成败。 其他数据结构树对于树中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。在二叉查找树中查找节点时，平均运行时间为O(logn)，但在最糟的情况（不平衡的树）下所需时间为O(n)，但是插入和删除所需时间都为O(logn)。有序数组进行二分查找，查找所需时间O(logn)，插入和删除都为O(n)。 二叉树的确定：不能随机访问。 反向索引反向索引（inverted index），讲单词映射到包含它的页面（文档）。常用来创建搜索引擎。 傅里叶变换傅里叶变换，“给它一杯冰沙，它能告诉你其中包含哪些成分”。常用来处理MP3音乐格式，地震预测和DNA分析。 MapReduceMapReduce，一种流行的分布式算法，可让算法在多台计算机上运行。可通过Hadoop来使用它。 应用场景：对包含数十亿乃至数万亿行的数据库表进行复杂的SQL查询。处理100万个小任务，每个任务需要10秒。 MapReduce基于两个简单的理念：映射（map）函数，归并（reduce）函数 映射函数12arr1 = [1, 2, 3, 4, 5]arr2 = map(lambda x: x*2, arr1) 归并函数1234from functools import reducearr1 = [1, 2, 3, 4, 5]total = reduce(lambda x, y: x+y, arr1) 布隆过滤器用散列表进行数据搜索是很快的，时间复杂度为O(1)，但是如果数据量特别大时（比如Google管理的数万亿个网页的索引），这个散列表将占用大量的存储空间。布隆过滤器是一种概率型数据结构，非常适合用于不要求答案绝对准确的情况，比如对安全网址提示工具来说，这样说完全可行：“我们认为这个网站可能是恶意的，请倍加小心。”。 SHA算法安全散列算法（secure hash algorithm）。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。SHA被广泛用于计算密码的散列值。这种散列算法是单向的。 局部敏感的散列算法SHA还有一个重要特征，那就是局部不敏感的。如果你修改其中的一个字符，再计算其散列值，结果将截然不同！Simhash算法则相反，如果你对字符串做细微的修改， Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！ 应用场景：Google使用Simhash来判断网页是否已收集。老师使用Simhash来判断论文是否是从网上抄的。 RSA公钥加密，私钥解密。私钥加密，公钥解密。 线性规划线性规划用于在给定约束条件下最大限度地改善指定的指标。例如，假设你所在的公司生产两种产品：衬衫和手提袋。衬衫每件利润2美元，需要消耗1米布料和5粒扣子；手提袋每个利润3美元，需要消耗2米布料和2粒扣子。你有11米布料和20粒扣子，为最大限度地提高利润，该生产多少件衬衫、多少个手提袋呢？在这个例子中，目标是利润最大化，而约束条件是拥有的原材料数量。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集_注释笔记]]></title>
    <url>%2F2018%2F10%2F24%2FPython%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初见网络爬虫BeautifulSoap 简介1234567from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.smallapping.com')bsObj = BeautifulSoup(html.read(), features='lxml')print(bsObj.h1)print(bsObj.html.body.p) 调用 bsObj.tagName 只能获取页面中的第一个指定的标签。 可靠的网络连接12345678910111213141516171819202122from urllib.request import urlopenfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSoupdef getTitle(url): try: html = urlopen(url) except HTTPError: return None try: bsObj = BeautifulSoup(html.read(), 'lxml') title = bsObj.body.h1 except AttributeError: return None return titletitle = getTitle('http://www.smallapping.com')if title is None: print('Title could not be found')else: print(title) 复杂HTML解析不是一直都要用锤子在面对埋藏很深或格式不友好的数据时， 千万不要不经思考就写代码，一定要三思而后行： 寻找“打印此页”的链接，或者看看网站有没有 HTML 样式更友好的移动版（把自己的请求头设置成处于移动设备的状态，然后接收网站移动版）。 寻找隐藏在 JavaScript 文件里的信息。要实现这一点，你可能需要查看网页加载的JavaScript 文件。 我曾经要把一个网站上的街道地址（以经度和纬度呈现的）整理成格式整洁的数组时，查看过内嵌谷歌地图的 JavaScript 文件，里面有每个地址的标记点。 虽然网页标题经常会用到，但是这个信息也许可以从网页的 URL 链接里获取。 如果你要找的信息只存在于一个网站上， 别处没有，那你确实是运气不佳。如果不只限于这个网站， 那么你可以找找其他数据源。有没有其他网站也显示了同样的数据？网站上显示的数据是不是从其他网站上抓取后攒出来的？ 再端一碗1234567891011from urllib.request import urlopenfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/warandpeace.html')bs = BeautifulSoup(html, 'lxml')nameList = bs.findAll('span', &#123;'class': 'green'&#125;)for name in nameList: print(name.get_text()) findAll和find最常用的两个函数： attributes, recursive, text, limit, keywords)```122. ```find(tag, attributes, recursive, text, keywords) 1bs.findAll(['p', 'span'], &#123;'class': 'green'&#125;, text='the prince', id='text' ) text： 筛选内容与text完全匹配的标签 recursive：设置为 True， findAll 就会查找标签参数的所有子标签，以及子标签的子标签。为 False， findAll 就只查找文档的一级标签 limit： 只用于findAll，前x项，按照网页上的顺序 keywords： 选择特定属性的标签，如id=’text’。冗余功能，完全可以用其他技术替代。findAll(id=”text”)，等同于findAll(“”,{“id”:”text”})。偶尔还会出现问题，比如class=”class”就会错误，因为class是关键字 其他BeautifulSoup对象 BeautifulSoup对象 标签Tag对象，find和findAll获得 NavigableString对象，表示标签里的文字 Comment对象，注释标签 导航树12345from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/page3.html")bs = BeautifulSoup(html, 'lxml') 子标签和后代标签 bsObj.body.h1 选择了 body 标签后代里的第一个 h1 标签，不会去找 body 外面的标签。 字标签：&#123;'id': 'giftList'&#125;).children```12后代标签：```bs.find(&apos;table&apos;, &#123;&apos;id&apos;: &apos;giftList&apos;&#125;).descendants 兄弟标签 next_siblings 和 previous_siblings，返回标签后面/前面的兄弟标签 返回表格中除标题行以外的所有行：&#123;'id': 'giftList'&#125;).tr.next_siblings```12单标签版本：```next_sibling``` 和 ```previous_sibling 父标签 parent 和 parents 123img = bs.find('img', &#123;'src': '../img/gifts/img1.jpg'&#125;)print(img.parent.previous_sibling.get_text())print(img.parent.previous) 正则表达式1a+b&#123;5&#125;(cc)*d? a至少出现一次。b重复5次。c重复任意欧数次。d可有可无。 正则表达式常用符号： 正则表达式和BeautifulSoup123for img in bs.findAll('img', &#123;'src': re.compile('\.\./img/gifts/img.*\.jpg')&#125;): print(img.attrs) # 获取所有属性 print(img['src']) # 读取某一个属性 Lambda表达式1bs.findAll(lambda tag: len(tag.attrs) == 2) 开始采集遍历单个域名1234567891011121314151617181920212223from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom sys import stdoutimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(url): html = urlopen('http://en.wikipedia.org'+url) bs = BeautifulSoup(html, 'lxml') return bs.find('div', id='bodyContent').findAll( 'a', href=re.compile('^/wiki/((?!:).)*$')) # 页面链接的特点stdout.flush()links = getLinks('/wiki/Kevin_Bacon')while len(links) &gt; 0: newArticle = links[random.randint(0, len(links)-1)].attrs['href'] print(newArticle) stdout.flush() links = getLinks(newArticle) 采集整个网站深网和暗网： 链接收集和链接去重： 123456789101112131415161718192021222324from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom sys import stdoutimport repages = set()def getLinks(url): global pages html = urlopen('http://en.wikipedia.org'+url) bs = BeautifulSoup(html, 'lxml') for link in bs.findAll('a', href=re.compile('^(/wiki/)')): href = link['href'] if href is not None: if href not in pages: print(href) stdout.flush() pages.add(href) getLinks(href) # 注意递归次数：Python 默认的递归限制（程序递归地自我调用次数）是 1000 次getLinks('') # 从主页开始 收集整个网站的据： 12345678910111213141516171819202122232425262728293031from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom sys import stdoutimport repages = set()def getLinks(url): global pages html = urlopen('http://en.wikipedia.org'+url) bs = BeautifulSoup(html, 'lxml') try: print(bs.h1.get_text()) print(bs.find(id="mw-content-text").findAll("p")[0]) print(bs.find(id="ca-edit").find("span").find("a").attrs['href']) except AttributeError: print('缺少属性，不过不必担心！') stdout.flush() for link in bs.findAll('a', href=re.compile('^(/wiki/)')): href = link['href'] if href is not None: if href not in pages: print('------------------------\n'+href) stdout.flush() pages.add(href) getLinks(href)getLinks('') Scrapy scrapy startproject wikiSpider 在spiders文件夹下新建articleSpider.py 在items.py文件中定义新的item 每个Item对象表示网站上的一个页面，可以定义不同的条目（url、content、header、image等），这里只演示收集每页的title字段 12class Article(scrapy.Item): title = scrapy.Field() articleSpider.py 12345678910111213141516171819202122from scrapy.selector import Selectorfrom scrapy import Spiderfrom wikiSpider.items import Articleclass ArticleSpider(Spider): name = 'article' allowed_domains = ['en.wikipedia.org'] start_urls = ['http://en.wikipedia.org/wiki/Main_Page', 'http://en.wikipedia.org/wiki/Python_%28programming_language%29'] custom_settings = &#123; # 爬虫级设置 'LOG_LEVEL': 'INFO', # 只记录Info及以上级别 &#125; def parse(self, response): item = Article() title = response.xpath('//h1/text()')[0].extract() print('Title is:', title) item['title'] = title return item 启动爬虫 在主目录运行命令，scrapy crawl article 切换提取信息格式，指定日志文件 123scrapy crawl article -s LOG_FILE=wiki.txt -o articles.csv -t csvscrapy crawl article -o articles.json -t jsonscrapy crawl article -o articles.xml -t xml 也可以把结果写入文件或数据库中，只要在parse部分增加相应代码即可 使用API123token = "your api key"webRequest = urllib.request.Request('http://myapi.com',headers=&#123;'token':token&#125;)html = urlopen(webRequest) 解析json数据： 123456789101112import jsonfrom urllib.request import urlopendef getCountry(ipAddress): response = urlopen('http://ip-api.com/json/' + ipAddress).read().decode('utf8') dic = json.loads(response) return dic['countryCode']print(getCountry('')) 抓取维基百科的编辑历史的贡献者IP地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom urllib.error import HTTPErrorimport jsonimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(articleUrl): html = urlopen("http://en.wikipedia.org"+articleUrl) bs = BeautifulSoup(html, 'lxml') return bs.find("div", &#123;"id": "bodyContent"&#125;).findAll("a", href=re.compile("^(/wiki/)((?!:).)*$"))def getHistoryIPs(pageUrl): # 编辑历史页面URL链接格式是： # http://en.wikipedia.org/w/index.php?title=Title_in_URL&amp;action=history pageUrl = pageUrl.replace("/wiki/", "") historyUrl = "http://en.wikipedia.org/w/index.php?title=" + pageUrl+"&amp;action=history" print("history url is: "+historyUrl) html = urlopen(historyUrl) bs = BeautifulSoup(html, 'lxml') # 找出class属性是"mw-anonuserlink"的链接 # 它们用IP地址代替用户名 ipAddresses = bs.findAll("a", &#123;"class": "mw-anonuserlink"&#125;) addressList = set() for ipAddress in ipAddresses: addressList.add(ipAddress.get_text()) return addressListdef getCountry(ip): try: response = urlopen('http://ip-api.com/json/'+ip).read().decode('utf8') except HTTPError: return None responseJson = json.loads(response) return responseJson['countryCode']links = getLinks("/wiki/Python_(programming_language)")while len(links) &gt; 0: for link in links: print('------------------') ips = getHistoryIPs(link['href']) for ip in ips: country = getCountry(ip) print(ip+' is from '+country) newLink = links[random.randint(0, len(links)-1)].attrs['href'] links = getLinks(newLink) 存储数据媒体文件存储媒体文件的两种方式：只获取文件URL链接或直接下载源文件。 只获取媒体文件的URL的优缺点： 下载一张图片： 12345678from urllib.request import urlopenfrom urllib.request import urlretrievefrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com')bs = BeautifulSoup(html, 'lxml')imgUrl = bs.find('a', id='logo').find('img')['src']urlretrieve(imgUrl, 'logo.jpg') 下载所有具有src属性的资源： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osfrom urllib.request import urlopenfrom urllib.request import urlretrievefrom bs4 import BeautifulSoupdire = 'downloaded'baseUrl = 'http://pythonscraping.com'def getAbsoluteURL(baseUrl, source): if source.startswith('http://www.'): url = 'http://' + source[11:] elif source.startswith('http://'): url = source elif source.startswith('www.'): url = source[:4] url = 'http://' + url else: url = baseUrl + '/'+source if baseUrl not in url: return None return url.split('?')[0]def getDownloadPath(baseUrl, absoluteUrl, dire): path = absoluteUrl.replace('www.', '') path = path.replace(baseUrl, '') path = dire + path dire = os.path.dirname(path) if not os.path.exists(dire): os.makedirs(dire) return pathhtml = urlopen('http://www.pythonscraping.com')bs = BeautifulSoup(html, 'lxml')downloads = bs.findAll(src=True)for download in downloads: fileUrl = getAbsoluteURL(baseUrl, download['src']) if fileUrl is not None: print(fileUrl) downPath = getDownloadPath(baseUrl, fileUrl, dire) urlretrieve(fileUrl, downPath) 把数据存储到CSV创建csv文件： 1234567import csvwith open('test.csv', 'w+') as csvFile: writer = csv.writer(csvFile) writer.writerow(('number', 'number plus 2', 'number times 2')) for i in range(10): writer.writerow((i, i+2, i*2)) 常用场景，获取HTML表格并写入CSV文件： 12345678910111213141516import csvfrom urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://en.wikipedia.org/wiki/Comparison_of_text_editors')bs = BeautifulSoup(html, 'lxml')table = bs.find('table', &#123;'class': 'wikitable'&#125;)rows = table.findAll('tr')with open('editors.csv', 'w+', newline='', encoding='utf8') as csvFile: writer = csv.writer(csvFile) for row in rows: csvRow = [] for cell in row.findAll(['td', 'th']): csvRow.append(cell.get_text()) writer.writerow(csvRow) MySQL12345678import pymysqlconn = pymysql.connect(host='127.0.0.1', unix_socket='/tmp/mysql.sock', user='root', passwd=None, db='mysql')cur = conn.cursor()cur.execute("USE scraping")cur.execute("SELECT * FROM pages WHERE id=1")print(cur.fetchone())cur.close()conn.close() 让数据库支持Unicode： 1234ALTER DATABASE scraping CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE pages CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE pages CHANGE title title VARCHAR(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE pages CHANGE content content VARCHAR(10000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 抓取并保存到MySQL： 1234567891011121314151617181920212223242526272829303132333435363738394041from urllib.request import urlopenfrom bs4 import BeautifulSoupimport reimport datetimeimport randomimport pymysqlconn = pymysql.connect(host='127.0.0.1', unix_socket='/tmp/mysql.sock', user='root', passwd=None, db='mysql', charset='utf8')cur = conn.cursor()cur.execute("USE scraping")random.seed(datetime.datetime.now())def store(title, content): cur.execute( "INSERT INTO pages(title, content) VALUES(\"%s\",\"%s\")", (title, content)) cur.connection.commit()def getLinks(articleUrl): html = urlopen("http://en.wikipedia.org"+articleUrl) bsObj = BeautifulSoup(html) title = bsObj.find("h1").get_text() content = bsObj.find("div", &#123;"id": "mw-content-text"&#125;).find("p").get_text() store(title, content) return bsObj.find("div", &#123;"id": "bodyContent"&#125;).findAll("a", href=re.compile("^(/wiki/)((?!:).)*$"))links = getLinks("/wiki/Kevin_Bacon")try: while len(links) &gt; 0: newArticle = links[random.randint(0, len(links)-1)].attrs["href"] print(newArticle) links = getLinks(newArticle)finally: cur.close() conn.close() email发邮件： 123456789101112import smtplibfrom email.mime.text import MIMETextmsg = MIMEText('the body of email')msg['Subject'] = 'an email'msg['From'] = 'alan@python.com'msg['To'] = 'some@python.com's = smtplib.SMTP('localhost')s.send_message(msg)s.quit() Python 有两个包可以发送邮件： smtplib 和 email email 模块里包含了许多实用的邮件格式设置函数，可以用来创建邮件“包裹”。下面的示例中使用的 MIMEText 对象，为底层的 MIME（Multipurpose Internet MailExtensions，多用途互联网邮件扩展类型）协议传输创建了一封空邮件， 最后通过高层的SMTP 协议发送出去。 MIMEText 对象 msg 包括收发邮箱地址、邮件正文和主题， Python 通过它就可以创建一封格式正确的邮件。 smtplib 模块用来设置服务器连接的相关信息。就像 MySQL 服务器的连接一样，这个连接必须在用完之后及时关闭，以避免同时创建太多连接而浪费资源。 封装一下： 12345678910111213141516171819202122232425import smtplibfrom email.mime.text import MIMETextfrom bs4 import BeautifulSoupfrom urllib.request import urlopenimport timedef sendMail(subject, body): msg = MIMEText(body) msg['Subject'] = subject msg['From'] = 'christmas_alerts@python.com' msg['To'] = 'alan@python.com' s = smtplib.SMTP('localhost') s.send_message(msg) s.quit()bs = BeautifulSoup(urlopen("https://isitchristmas.com/"))while bs.find('a', &#123;'id': 'answer'&#125;).attrs['title'] == '不是': print('It is not Christmas yet.') time.sleep(3600) bs = BeautifulSoup(urlopen("https://isitchristmas.com/"))sendMail('It\'s Christmax!', 'According to http://itischristmas.com, it is Christmas!') 邮件程序可以做很多事情，可以发送网站访问失败、 应用测试失败的异常情况，也可以在 Amazon 网站上出现了一款卖到断货的畅销品时通知你。 读取文档纯文本123from urllib.request import urlopenpage = urlopen('https://www.ietf.org/rfc/rfc1149.txt')print(page.read()) 对法语文本进行编码显示： 123456789101112from urllib.request import urlopenfrom bs4 import BeautifulSouptextPage = urlopen( "http://www.pythonscraping.com/pages/warandpeace/chapter1-ru.txt")print(str(textPage.read(), 'utf8'))html = urlopen("http://en.wikipedia.org/wiki/Python_(programming_language)")bsObj = BeautifulSoup(html, 'lxml')content = bsObj.find("div", &#123;"id": "mw-content-text"&#125;).get_text()content = bytes(content, "UTF-8")content = content.decode("UTF-8") CSV读取网络csv文件： 1234567891011from urllib.request import urlopenfrom io import StringIOimport csvdata = urlopen( 'http://pythonscraping.com/files/MontyPythonAlbums.csv').read().decode('ascii', 'ignore')dataFile = StringIO(data)csvReader = csv.reader(dataFile)for row in csvReader: print(row) # row是一个列表，代表每一行（包括列头那一行） 123456789101112from urllib.request import urlopenfrom io import StringIOimport csvdata = urlopen( 'http://pythonscraping.com/files/MontyPythonAlbums.csv').read().decode('ascii', 'ignore')dataFile = StringIO(data)dictReader = csv.DictReader(dataFile)print(dictReader.fieldnames) # ['Name', 'Year']for row in dictReader: print(row) # row是字典对象，OrderedDict([('Name', "Monty Python's Flying Circus"), ('Year', '1970')]) PDF读取PDF文件，使用PDFMiner3K库，过程略。 docx读取微软Word的.docx文件： 12345678910111213from zipfile import ZipFilefrom urllib.request import urlopenfrom io import BytesIOfrom bs4 import BeautifulSoupwordFile = urlopen("http://pythonscraping.com/pages/AWordDocument.docx").read()wordFile = BytesIO(wordFile)document = ZipFile(wordFile)xml_content = document.read('word/document.xml')wordObj = BeautifulSoup(xml_content.decode('utf-8'))textStrings = wordObj.findAll("w:t") # 读取文档for textElem in textStrings: print(textElem.text) 数据清洗编写代码清洗数据语言模型n-gram：表示文字或语言中的 n 个连续的单词组成的序列。在进行自然语言分析时，使用 n-gram 或者寻找常用词组， 可以很容易地把一句话分解成若干个文字片段。 123456789101112131415161718192021222324252627282930313233343536from urllib.request import urlopenfrom bs4 import BeautifulSoupimport reimport stringdef clearInput(input): input = re.sub('\n+', ' ', input) # 把换行符（或者多个换行符）替换成空格 input = re.sub('\[\d*\]', '', input) # 去掉维基百科的引用标记 input = re.sub(' +', ' ', input) # 把连续的多个空格替换成一个空格 input = bytes(input, 'utf8') input = input.decode('ascii', 'ignore') # 把内容转换成 UTF-8 格式以消除转义字符 cleanInput = [] input = input.split() for item in input: # 去除两端的标点符号。string.punctuation，标点符号，包括：!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ item = item.strip(string.punctuation) if len(item) &gt; 1 or (item.lower() == 'a' or item.lower() == 'i'): cleanInput.append(item) return cleanInputdef ngrams(input, n): input = clearInput(input) output = [] for i in range(len(input)-n+1): output.append(input[i:i+n]) return outputhtml = urlopen('http://en.wikipedia.org/wiki/Python_(programming_language)')bs = BeautifulSoup(html, 'lxml')content = bs.find("div", &#123;"id": "mw-content-text"&#125;).get_text()ngrams = ngrams(content, 2)print(ngrams)print("2-grams count is: "+str(len(ngrams))) 数据标准化： 1234567891011121314def ngrams_dict(input, n): input = clearInput(input) output = &#123;&#125; for i in range(len(input)-n+1): newNGram = ' '.join(input[i:i+n]) if newNGram in output: output[newNGram] += 1 else: output[newNGram] = 1 return outputngrams = ngrams_dict(content, 2)ngrams = OrderedDict(sorted(ngrams.items(), key=lambda t: t[1], reverse=False))print(ngrams) 数据存储后再清洗使用OpenRefine，过程略。 自然语言处理概括数据12345content = urlopen( 'http://pythonscraping.com/files/inaugurationSpeech.txt').read().decode('utf8')ngrams = ngrams_dict(content, 2)sortedNGrams = sorted(ngrams.items(), key=operator.itemgetter(1), reverse=True)print(sortedNGrams) 排除常用单词： 123456789101112131415161718192021222324252627282930def isCommon(ngram): commonWords = ["the", "be", "and", "of", "a", "in", "to", "have", "it", "i", "that", "for", "you", "he", "with", "on", "do", "say", "this", "they", "is", "an", "at", "but", "we", "his", "from", "that", "not", "by", "she", "or", "as", "what", "go", "their", "can", "who", "get", "if", "would", "her", "all", "my", "make", "about", "know", "will", "as", "up", "one", "time", "has", "been", "there", "year", "so", "think", "when", "which", "them", "some", "me", "people", "take", "out", "into", "just", "see", "him", "your", "come", "could", "now", "than", "like", "other", "how", "then", "its", "our", "two", "more", "these", "want", "way", "look", "first", "also", "new", "because", "day", "more", "use", "no", "man", "find", "here", "thing", "give", "many", "well"] for word in ngram: if word in commonWords: return True return Falsedef ngrams_dict(input, n): input = clearInput(input) output = &#123;&#125; for i in range(len(input)-n+1): if not isCommon(input[i:i+n]): newNGram = ' '.join(input[i:i+n]) if newNGram in output: output[newNGram] += 1 else: output[newNGram] = 1 return output 马尔可夫模型马尔可夫模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from urllib.request import urlopenfrom random import randintdef wordListSum(wordList): sum = 0 for word, value in wordList.items(): sum += value return sumdef retrieveRandomWord(wordList): randIndex = randint(1, wordListSum(wordList)) for word, value in wordList.items(): randIndex -= value if randIndex &lt;= 0: return worddef buildWordDict(text): # 剔除换行符和引号 text = text.replace('\n', ' ') text = text.replace('\"', '') # 将标点符号保留在马尔可夫链中 punctuation = [',', '.', ';', ':'] for symbol in punctuation: text = text.replace(symbol, ' '+symbol+' ') words = text.split(' ') words = [word for word in words if word != ''] wordDict = &#123;&#125; for i in range(1, len(words)): if words[i-1] not in wordDict: wordDict[words[i-1]] = &#123;&#125; if words[i] not in wordDict[words[i-1]]: wordDict[words[i-1]][words[i]] = 0 wordDict[words[i-1]][words[i]] += 1 return wordDicttext = urlopen( 'http://pythonscraping.com/files/inaugurationSpeech.txt').read().decode('utf8')wordDict = buildWordDict(text)length = 1000chain = ''currentWord = 'I'for i in range(0, length): chain += currentWord + ' ' currentWord = retrieveRandomWord(wordDict[currentWord])print(chain) 穿越网页表单与登录窗口进行采集Python RequestsPython 的标准库 urllib 为你提供了大多数 HTTP 功能，但是它的 API 非常差。这是因为它是经过许多年一步步建立起来的——不同时期要面对的是不同的网络环境。于是为了完成最简单的任务，它需要耗费大量的工作（甚至要重写整个方法）。 Requests 库就是这样一个擅长处理那些复杂的 HTTP 请求、 cookie、 header（响应头和请求头）等内容的 Python 第三方库。 提交一个基本表单1234567import requestsparams = &#123;'firstname': 'Ryan', 'lastname': 'Mitchell'&#125;r = requests.post( 'http://pythonscraping.com/pages/files/processing.php', data=params)print(r.text) 提交文件和图像1234567import requestsfiles = &#123;'uploadFile': open('1.png', 'rb')&#125;r = requests.post( 'http://pythonscraping.com/pages/files/processing2.php', files=files)print(r.text) 处理登录和cookie123456789101112131415import requestssession = requests.Session()params = &#123;'username': 'Ryan', 'password': 'password'&#125;s = session.post( 'http://pythonscraping.com/pages/cookies/welcome.php', params)print('Cookie is set to:')print(s.cookies.get_dict())print('----------------------')s = session.get('http://pythonscraping.com/pages/cookies/profile.php')print(s.text)session对象会持续跟踪会话信息，像cookie、header，甚至包括运行HTTP协议的信息，比如HTTPAdapter（为HTTP何HTTPS的链接会话提供统一接口） HTTP基本接入认证： 12345678import requestsfrom requests.auth import AuthBasefrom requests.auth import HTTPBasicAuthauth = HTTPBasicAuth('ryan', 'password')r = requests.post( url='http://pythonscraping.com/pages/auth/login.php', auth=auth)print(r.text) 采集Javascript在Python中用Selenium执行JavaScript： 12345678910111213141516171819202122232425262728293031from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport requestsimport time#1 只能采集到加载前的页面r = requests.get('http://pythonscraping.com/pages/javascript/ajaxDemo.html')print(r.text)#2 使用Selenium模拟浏览器打开页面browser = webdriver.Chrome() # 将chromedriver.exe的路径加入到path中browser.get('https://www.baidu.com') # 新开一个浏览器#3 使用Selenium模拟浏览器等待chrome_options = Options()chrome_options.add_argument('--headless') # 无界面模式chrome_options.add_argument('--disable-gpu')driver = webdriver.Chrome(chrome_options=chrome_options)driver.get('http://pythonscraping.com/pages/javascript/ajaxDemo.html')time.sleep(3)print(driver.find_element_by_id('content').text)driver.close()#4 Selenium的通用选择器driver.find_elements_by_css_selector("#content")#5 可以搭配BeautifulSoup来解析网页内容pageSource = driver.page_sourcebsObj = BeautifulSoup(pageSource)print(bsObj.find(id="content").get_text()) 隐式等待： 1234567891011121314from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get('http://pythonscraping.com/pages/javascript/ajaxDemo.html')try: element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, 'loadedButton')))finally: print(driver.find_element_by_id('content').text) driver.close() WebDriverWait 和 expected_conditions，这两个模块组合起来构成了 Selenium 的隐式等待（implicit wait）。元素被触发的期望条件（expected condition）有很多种，包括： 弹出一个提示框 一个元素被选中（比如文本框） 页面的标题改变了，或者某个文字显示在页面上或者某个元素里 一个元素在 DOM 中变成可见的，或者一个元素从 DOM 中消失了 元素用定位器（locator）指定，By对象选择的策略： ID：在上面的例子里用过；通过 HTML 的 id 属性查找元素 CLASS_NAME：通过 HTML 的 class 属性来查找元素 CSS_SELECTOR：通过 CSS 的 class、 id、 tag 属性名来查找元素，用 #idName、 .className、 tagName 表示 LINK_TEXT：通过链接文字查找 HTML 的 标签。例如，如果一个链接的文字是“Next”，就可以用 (By.LINK_TEXT, “Next”) 来选择 PARTIAL_LINK_TEXT：与 LINK_TEXT 类似，只是通过部分链接文字来查找 NAME：通过 HTML 标签的 name 属性查找。这在处理 HTML 表单时非常方便 TAG_NAME：通过 HTML 标签的名称查找 XPATH：用 XPath 表达式选择匹配的元素 XPath文档：https://msdn.microsoft.com/zh-cn/zn-CH/enus/library/ms256471 处理重定向识别一个页面已经完成重定向：从页面开始加载时就“监视 ” DOM 中的一个元素，然后重复调用这个元素直到 Selenium 抛出一个 StaleElementReferenceException 异常。也就是说，元素不在页面的DOM里了。 123456789101112131415161718192021222324252627from selenium import webdriverimport timefrom selenium.webdriver.remote.webelement import WebElementfrom selenium.common.exceptions import StaleElementReferenceExceptiondef waitForLoad(driver): elem = driver.find_element_by_tag_name('html') count = 0 while True: count += 1 if count &gt; 20: print('Timing out after 10 seconds and returning') return time.sleep(.5) if elem != driver.find_element_by_tag_name('html'): return # try: # elem == driver.find_element_by_tag_name('html') # except StaleElementReferenceException: # returndriver = webdriver.Chrome()driver.get('http://pythonscraping.com/pages/javascript/redirectDemo1.html')waitForLoad(driver)print(driver.page_source) 图像识别与文字处理OCR库Pillow，Tesseract。 安装：conda install -c simonflueckiger tesserocr pillow 设置训练数据文件路径：setx TESSDATA_PREFIX &#39;D:\Program Files\Tesseract OCR\&#39; 处理格式规范的文字 tesseract demo.png text：将某个图片的文字识别出来，保存到text.txt文件中 如果图片图片背景有渐变色，文字识别变得困难，可以使用Pillow库创建一个阈值过滤器来去掉渐变的背景色，只把文字流下来，从而利于Tesseract读取。 1234567891011121314151617181920from PIL import Imageimport subprocessimport osdef cleanFile(filePath, newFilePath): image = Image.open(filePath) # 对图片进行阈值过滤，然后保存 image = image.point(lambda x: 0 if x &lt; 120 else 255) image.save(newFilePath) # 调用系统的tesseract命令对图片进行OCR subprocess.call(['tesseract', newFilePath, 'output']) # 打开文件读取结果 with open('output.txt', 'r') as f: print(f.read())cleanFile('demo1.png', 'demo_clean.png') 从网站图片中抓取文字： 123456789101112131415161718192021222324252627282930313233343536import timefrom urllib.request import urlretrieveimport subprocessfrom selenium import webdriver# 打开亚马逊《战争与和平》图书详情页driver = webdriver.Chrome()driver.get('http://www.amazon.com/War-Peace-Leo-Nikolayevich-Tolstoy/dp/1427030200')time.sleep(2)# 单击图书预览按钮driver.find_element_by_id('sitbLogoImg').click()imageList = set()# 等待页面加载完成time.sleep(5)# 当向右箭头可以点击时，开始翻页while 'pointer' in driver.find_element_by_id('sitbReaderRightPageTurner').get_attribute('style'): driver.find_element_by_id('sitbReaderRightPageTurner').click() time.sleep(2) # 获取已加载的新页面（一次可以加载多个页面，但是重复的页面不能加载到集合中） pages = driver.find_elements_by_xpath("//div[@class='pageImage']/div/img") for page in pages: image = page.get_attribute('src') imageList.add(image)driver.quit()# 用Tesseract处理我们收集的图片URL链接for image in sorted(imageList): imgName = image[image[0:image.find('?')].rfind('/')+1:image.find('?')] name = imgName[0:imgName.rfind('.')] urlretrieve(image, imgName) p = subprocess.Popen(['tesseract', imgName, name], stdout=subprocess.PIPE, stderr=subprocess.PIPE) p.wait() f = open(name+'.txt', 'r') 读取验证码与训练Tesseract首先要把大量的验证码样本下载到一个文件夹里，建议使用验证码的真实结果给每个样本文件命名（即 4MmC3.jpg）。 第二步是准确地告诉 Tesseract 一张图片中的每个字符是什么，以及每个字符的具体位置。这里需要创建一些矩形定位文件（box file），示例： 4 15 26 33 55 0M 38 13 67 45 0m 79 15 101 26 0C 111 33 136 60 03 147 17 176 45 0 第一列符号是图片中的每个字符，后面的 4 个数字分别是包围这个字符的最小矩形的坐标（图片左下角是原点 (0,0)， 4 个数字分别对应每个字符的左下角 x 坐标、左下角 y 坐标、右上角 x 坐标和右上角 y 坐标），最后一个数字“0”表示图片样本的编号。 制作矩形定位文件的工具，Tesseract OCR Chopper（http://pp19dd.com/tesseract-ocr-chopper/）。 备份一下这个文件夹。 完成所有的数据分析工作和创建 Tesseract 所需的训练文件，一共有六个步骤。 一个 Python 版的解决方案（https://github.com/REMitchell/tesseract-trainer）。 获取验证码提交答案常用的处理方法就是，首先把验证码图片下载到硬盘里，清理干净，然后用 Tesseract 处理图片，最后返回符合网站要求的识别结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from urllib.request import urlopen, urlretrievefrom bs4 import BeautifulSoupimport subprocessimport requestsfrom PIL import Imagefrom PIL import ImageOpsdef cleanImage(imagePath): image = Image.open(imagePath) image = image.point(lambda x: 0 if x &lt; 143 else 255) borderImage = ImageOps.expand(image, border=20, fill='white') borderImage.save(imagePath)html = urlopen('http://www.pythonscraping.com/humans-only')bs = BeautifulSoup(html, 'lxml')# 收集需要处理的表单数据（包括验证码和输入字段）imageLocation = bs.find('img', &#123;'title': 'Image CAPTCHA'&#125;)['src']formBuildId = bs.find('input', &#123;'name': 'form_build_id'&#125;)['value']captchaSid = bs.find('input', &#123;'name': 'captcha_sid'&#125;)['value']captchaToken = bs.find('input', &#123;'name': 'captcha_token'&#125;)['value']captchaUrl = 'http://pythonscraping.com'+imageLocationurlretrieve(captchaUrl, 'captcha.jpg')cleanImage('captcha.jpg')p = subprocess.Popen(['tesseract', 'captcha.jpg', 'captcha'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)p.wait()f = open('captcha.txt', 'r')# 清理识别结果中的空格和换行符captchaResponse = f.read().replace(' ', '').replace('\n', '')print('Captcha solution attempt: '+captchaResponse)if len(captchaResponse) == 5: params = &#123;'captcha_token': captchaToken, 'captcha_sid': captchaSid, 'form_id': 'comment_node_page_form', 'form_build_id': formBuildId, 'captcha_response': captchaResponse, 'name': 'Nobody', 'subject': 'Nosubject', 'comment_body[und][0][value]': '中文内容'&#125; r = requests.post( 'http://www.pythonscraping.com/comment/reply/10', data=params) responseObj = BeautifulSoup(r.text, 'lxml') if responseObj.find('div', &#123;'class': 'messages'&#125;) is not None: print(responseObj.find('div', &#123;'class': 'messages'&#125;).get_text())else: print('There was a problem reading the CAPTCHA correctly!') 避开采集陷阱让网络机器人看起来像人类用户修改请求头12345678910session = requests.Session()headers = &#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"&#125;url = 'https://www.zhihu.com/api/v4/questions/35441232/answers?include=data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.author.follower_count%2Cbadge%5B%2A%5D.topics&amp;limit=50&amp;offset=0&amp;sort_by=default'req = session.get(url, headers=headers)with open('d.json', 'w', encoding='utf8') as f: d = json.loads(req.text) json.dump(d, f, ensure_ascii=False, indent=4) 处理cookie123456789101112from selenium import webdriverdriver = webdriver.Chrome()driver.get('http://pythonscraping.com')driver.implicitly_wait(1)print(driver.get_cookies())driver.delete_all_cookies()driver.add_cookie(&#123;'name': 'foo', 'value': 'bar', 'path': '/', 'secure': True&#125;)print(driver.get_window_size())driver.get_screenshot_as_file('foo.png') 避免蜜罐1234567891011121314from selenium import webdriverfrom selenium.webdriver.remote.webelement import WebElementdriver = webdriver.Chrome()driver.get('http://pythonscraping.com/pages/itsatrap.html')links = driver.find_elements_by_tag_name('a')for link in links: if not link.is_displayed(): print('The link '+link.get_attribute('href')+' is a trap')fields = driver.find_elements_by_tag_name('input')for field in fields: if not field.is_displayed(): print('Do not change value of '+field.get_attribute('name')) 问题检查表如果你已经登录网站却不能保持登录状态，或者网站上出现了其他的“登录状态”异常，请检查你的 cookie。 确认在加载每个页面时 cookie 都被正确调用，而且你的 cookie 在每次发起请求时都发送到了网站上。 如果你在客户端遇到了 HTTP 错误， 尤其是 403 禁止访问错误，这可能说明网站已经把你的 IP 当作机器人了，不再接受你的任何请求。你要么等待你的 IP 地址从网站黑名单里移除，要么就换个 IP 地址（可以去星巴克上网，或者看看第 14 章的内容）。如果你确定自己并没有被封杀，那么再检查下面的内容： 确认你的爬虫在网站上的速度不是特别快。 快速采集是一种恶习，会对网管的服务器造成沉重的负担，还会让你陷入违法境地， 也是 IP 被网站列入黑名单的首要原因。给你的爬虫增加延迟，让它们在夜深人静的时候运行。切记：匆匆忙忙写程序或收集数据都是拙劣项目管理的表现；应该提前做好计划，避免临阵慌乱访问者。如果你不确定请求头的值怎样才算合适，就用你自己浏览器的请求头吧 还有一件必须做的事情： 修改你的请求头！有些网站会封杀任何声称自己是爬虫的访问者。如果你不确定请求头的值怎样才算合适，就用你自己浏览器的请求头吧 确认你没有点击或访问任何人类用户通常不能点击或接入的信息 用爬虫测试网站Python 单元测试 为每个单元测试的开始和结束提供 setUp 和 tearDown 函数 提供不同类型的“断言”语句让测试成功或失败 把所有以 test 开头的函数当作单元测试运行，忽略不带 test 的函数 1234567891011121314151617181920import unittestclass TestAddition(unittest.TestCase): def setUp(self): print('Setting up the test') def tearDown(self): print('Tearing down the test') def test_twoPlusTwo(self): total = 2+2 self.assertEqual(total, 4) def test_twoPlusOne(self): total = 2+1 self.assertEqual(total, 4)if __name__ == '__main__': unittest.main() setUp 和 tearDown这两个函数在每个测试方法的开始和结束都会运行一次。 测试维基百科： 12345678910111213141516171819202122232425262728from urllib.request import urlopenfrom bs4 import BeautifulSoupimport unittestclass TestWikipedia(unittest.TestCase): bsObj = None def setUpClass(): print('1') global bsObj url = 'http://en.wikipedia.org/wiki/Monty_Python' bsObj = BeautifulSoup(urlopen(url), 'lxml') print('2') def test_titleText(self): global bsObj pageTitle = bsObj.find('h1').get_text() self.assertEqual('Monty Python', pageTitle) def test_contentExists(self): global bsObj content = bsObj.find('div', &#123;'id': 'mw-content-text'&#125;) self.assertIsNotNone(content)if __name__ == '__main__': unittest.main() setUpClass函数只在类的初始化阶段运行一次（与每个测试启动时都运行的 setUp 函数不同）。 Selenium 单元测试123456from selenium import webdriverdriver = webdriver.Chrome()driver.get('http://en.wikipedia.org/wiki/Monty_Python')assert 'Monty Python' in driver.titledriver.close() Selenium 单元测试的时候需要比写 Python 单元测试更加随意，断言语句甚至可以整合到生产代码中。 与网站进行交互： Selenium 也可以对任何给定元素执行很多操作： 12345myElement.click()myElement.click_and_hold()myElement.release()myElement.double_click()myElement.send_keys_to_element("content to enter") 动作链： 123456789101112131415161718192021222324from selenium import webdriverfrom selenium.webdriver.remote.webelement import WebElementfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver import ActionChainsdriver = webdriver.Chrome()driver.get('http://pythonscraping.com/pages/files/form.html')firstnameField = driver.find_element_by_name('firstname')lastnameField = driver.find_element_by_name('lastname')submitButton = driver.find_element_by_id('submit')### 方法1 ###firstnameField.send_keys('Ryan')lastnameField.send_keys('Mitchell')submitButton.click()### 方法2 ###actions = ActionChains(driver).click(firstnameField).send_keys( 'Ryan').click(lastnameField).send_keys('Mitchell').send_keys(Keys.RETURN) # Keys.RETURN 回车键actions.perform()print(driver.find_element_by_tag_name('body').text)driver.close() 鼠标拖放动作 12345678910111213from selenium import webdriverfrom selenium.webdriver.remote.webelement import WebElementfrom selenium.webdriver import ActionChainsdriver = webdriver.Chrome()driver.get('http://pythonscraping.com/pages/javascript/draggableDemo.html')print(driver.find_element_by_id('message').text)element = driver.find_element_by_id('draggable')target = driver.find_element_by_id('div2')actions = ActionChains(driver).drag_and_drop(element, target).perform()print(driver.find_element_by_id('message').text) 截屏 1234567from selenium import webdriverfrom selenium.webdriver.remote.webelement import WebElementfrom selenium.webdriver import ActionChainsdriver = webdriver.Chrome()driver.get('http://www.pythonscraping.com/')driver.get_screenshot_as_file('pythonscraping.png') Python单元测试与Selenium单元测试的选择Python 的单元测试语法严谨冗长，更适合为大多数大型项目写测试，而 Selenium 的测试方式灵活且功能强大，可以成为一些网站功能测试的首选。两者组合是最佳拍档。 远程采集Tor代理服务器洋葱路由（The Onion Router）网络，常用缩写为 Tor，是一种 IP 地址匿名手段。由网络志愿者服务器构建的洋葱路由器网络， 通过不同服务器构成多个层（就像洋葱）把客户端包在最里面。数据进入网络之前会被加密，因此任何服务器都不能偷取通信数据。另外，虽然每一个服务器的入站和出站通信都可以被查到， 但是要想查出通信的真正起点和终点，必须知道整个通信链路上所有服务器的入站和出站通信细节，而这基本是不可能实现的。 PySocks 是一个非常简单的 Python 代理服务器通信模块，它可以和 Tor 配合使用。 1234567import socksimport socketfrom urllib.request import urlopensocks.set_default_proxy(socks.SOCKS5, "localhost", 9150)socket.socket = socks.socksocketprint(urlopen('http://icanhazip.com').read()) 如果你想在 Tor 里面用 Selenium 和 PhantomJS，不需要 PySocks，只需要增加 service_args 参数设置代理端口。 1234567from selenium import webdriverservice_args = [ '--proxy=localhost:9150', '--proxy-type=socks5', ]driver = webdriver.PhantomJS(executable_path='&lt;path to PhantomJS&gt;', service_args=service_args)driver.get("http://icanhazip.com")print(driver.page_source)driver.close() 附录robots.txt 1234567891011121314151617181920#Welcome to my robots.txt file!User-agent: *Disallow: *User-agent: GooglebotAllow: *Disallow: /privateTwitter 的 robots.txt 文件对 Google 的规则#Google Search Engine RobotUser-agent: GooglebotAllow: /?_escaped_fragment_Allow: /?lang=Allow: /hashtag/*?src=Allow: /search?q=%23Disallow: /search/realtimeDisallow: /search/usersDisallow: /search/*/gridDisallow: /*?Disallow: /*/followersDisallow: /*/following]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流畅的Python_注释笔记]]></title>
    <url>%2F2018%2F09%2F13%2F%E6%B5%81%E7%95%85%E7%9A%84Python_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python 数据模型特殊方法内置函数会调用特殊方法，一般无需直接调用特殊方法，除了__init__方法。 __len__：调用len(obj)，解释器会自动调用 obj.__len__()。 对于Python内置的类型（list,str等），CPython还会抄近路提升计算速度，直接返回PyVarObject（内存中长度可变的内置对象的C语言结构体）里的ob_size属性 __repr__：被repr()函数调用，或者直接在控制台输入，把一个对象用字符串的形式表达出来以便辨认。面向开发者使用__str__：被str()函数调用，或者用print函数打印时调用，返回的字符串对中断用户更友好。面向用户的 区别：如果一个对象没有__str__函数，Python又需要调用时，会用__repr__代替 __add__：执行+运算__mul__：执行*运算 PS：中缀运算符的原则是，不改变操作对象，而是产生出一个新的值 __rmul__：解决交换律问题__bool__：被bool()函数调用，应该返回bool类型 12def __bool__(self): return bool(self.a or self.b) 序列构成的数组内置序列按元素类型分类： 容器序列：list、tuple、collections.deque，可以存放不同类型的数据扁平序列：str、bytes、bytearray、memoryview、array.array，只能容纳一种类型 按是否能被修改分类： 可变序列：list、bytearray、array.array、collections.deque、memoryview不可变序列：tuple、str、bytes 列表推导式、生成器表达式列表推导式生成新的列表 str = &#39;测试字符串&#39;arr = [ord(x) for x in str if ord(x) &gt; 30000] 与使用filter加map的比较 list(filter(lambda x: x &gt; 30000, map(ord, str))) 生成器表达式：生成列表以外的序列类型 逐个的产出元素，而不会在内存中留下一个列表，节省内存，提高效率。 str = &#39;测试字符串&#39;*1000000arr = (ord(x) for x in str if ord(x) &gt; 30000) 上述操作花费0.2s，如果换成列表推到式，将大约花费2s。 如果声称其表达式是函数调用中的唯一参数，那么不再需要括号围起来，如 tuple(x for x in arr)。 元组可以作为“不可变列表”，还可以用于没有字段名的纪录。 具名元组namedtuple，有名称和字段名的元组。 定义：x = (&#39;Beijing&#39;, 2018) 或省略括号 x = &#39;Beijing&#39;, 2018 访问元素：x[0] 元组拆包city, year, pop = (&#39;Tokyo&#39;, 2003, 32450) 等式左边是元组的省略括号的写法，等同于(city,year,pop) = ...。 元组拆包可以应用到任何可迭代对象上，唯一的要求是，接受元素的元组的空档数必须要和被迭代对象中的元素数量一致。 对于不关心的元素，可以用_占位符代替。对于多余的元素，可以用*来忽略。 str = &#39;测试字符串&#39; a,b,_,*args = str *前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置。 拆包时带的变量类型被定义为list，如果加在方法的形参上面，则变量被定义为tuple。 a, *b = &#39;Beijing&#39;, 2018, 1print(type(b)) #list 12def my(a,*b): print(type(b)) #tuple 不使用中间变量交换两个变量的值 b,a=a,b 嵌套元组拆包name, cc, pop, (lat, long) = (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667))print(&#39;{:^15}|{:^9.4f}|{:^9.4f}&#39;.format(name, lat, long)) # :9个单位的空间，保留4位小数，^居中 具名元组12345import collectionsCity = namedtuple('City', 'name country population coordinates') City = namedtuple('City', ['name','country','population','coordinates']) tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) 元素访问： tokyo[0]，tokyo.name 属性和方法： City._fields：返回包含这个类所有字段名称的元组City._make()：通过接受一个可迭代对象来生成一个实例，和调用City()是一样的City._asdict()：以 collections.OrderedDict 形式返回，方便遍历元素 12for k, v in tokyo._asdict().items(): print(k, v) 元组与列表的方法区别：元组没有列表的增删改/清空等方法，包含查询和统计的方法。 切片slice 切片和区间操作都不包含范围的最后一个元素，（左闭右开）。 优点：快速计算长度，后一个数减前一个数。快速分割元素不重叠，mylist[:10]和mylist[10:] s = &#39;bicycle&#39;print(s[::3]) # start:stop:step 相当于s[slice(None,None,3)]，即s.__getitem__(slice(None,None,3))。 多维切片：二维的numpy.ndarray就可以用a[m:n, k:l]的方式来得到二维切片 省略：ellipsis，Ellipsis对象是ellipsis类的单一实例 给切片复制：切片可以放在复制语句的左边或作为del操作的对象，可以对序列进行嫁接，切除或就地修改 1234l[2:5] = [20,30]del l[5:7]l[3::2] = [11,22]l[2:5] = 100 #报错，如果把切片放在赋值左侧·1，右侧则必须是个可迭代对象 对序列使用+和*浅表复制，序列中包含引用的话，仅仅是复制引用。 创建一个3*3的列表 arr = [[&#39;_&#39;]*3]*3 实际上创建了一个[‘‘,’‘,’_’]列表，然后复制了3次引用。改变其中一个列表的元素 arr[1][2] = &#39;0&#39;，将影响三个列表。 等同于： 123row = ['_'] * 3for i in range(3): arr.append(row) 正确的做法： arr = [[&#39;_&#39;] * 3 for i in range(3)] 序列的增量赋值a += b 增量赋值运算符+=和*=的表现取决于他们第一个操作对象。背后的特殊方法时 __iadd__ 和 __imul__ ，如果a实现了 __iadd__ ，则会调用这个方法。 对于可变序列（list,bytearray…）来说，a就会就地改动（in-place），好像调用了 a.extend(b) 一样。 如果a没有实现 __iadd__，这个表达式就变得跟 a = a+b 一样了。会计算 a+b，得出一个新对象，然后赋值给a。 123456789l=[1,2,3]print(id(l))l*=2print(id(l)) # 两次id相等，in-place，效率高t=(1,2,3)print(id(t))t*=2print(id(t)) # 两次id不等，新的对象，效率低 问题： 123456t = (1, 2, [30, 40])try: t[2] += [50, 60]except Exception as e: passprint(t) 结果：t变成（1,2,[30,40,50,60]），但仍会抛出TypeError异常 查看类似过程的字节码： 12import disdis.dis('s[a]+=b') 步骤说明： 将s[a]的值存入TOS（Top Of Stack） TOS += b，TOS是一个list，可以执行 s[a] = TOS，s是不可变的，所以执行失败 结论： 不要把可变对象放在元组里 增量赋值不是一个原子操作 list.sort()和sorted()list.sort()，就地排序，返回None。 sorted，新建一个列表并返回。可接受任何形式的可迭代对象，如，字符串，不可变序列或生成器，最后都会返回一个列表。 list.sort()和sorted()的参数： reverse：为True则降序排列 key：一个只有一个参数的函数，key=len，key=myfunc，默认值是恒等函数 包含key参数的内置函数还有，min()和max()等。 bisect管理已排序的序列bisect模块包含两个主要函数，bisect和insort，都利用二分查找来在有序序列中查找或插入元素。 bisect.bisect：bisect(haystack, needle)，在haystack(干草垛，必须升序)中找needle(针，待插入的元素)的位置 可选参数，lo和hi，控制搜索的范围。 bisect其实是bisect_right函数的别名，如果碰到相等的元素，bisect_right返回的插入位置是原序列中被插入元素相等的元素的之后的位置。 相应的还有bisect_left，对于这种情况则返回相等元素的原位置，即相等元素之前的位置。 123456789import bisectdef grade(score): breakpoints = [60, 70, 80, 90] grades = 'FDCBA' i = bisect.bisect(breakpoints, score) return grades[i]print([grade(x) for x in [59, 66, 99]]) bisect.insort：insort(seq,item)把变量item插入到序列seq中，并能保持seq的升序顺序 123456import bisectimport randoml = []for i in range(10): bisect.insort(l, random.randrange(100)) 列表不是首选时如果要存放1000万个浮点数的话，数组（array）的效率要高得多。因为数组背后存的不是float对象，而是数字的机器翻译，也就是字节表述。就跟C语言中的数组一样。 如果要频繁的进行FIFO的操作，deque速度会更快。如果检查元素是否存在的频率很高，用set更合适。因为set专为检查元素是否存在做过优化。 数组：数组支持所有跟可变序列有关的操作，pop，insert，extend。还有从文件读和存入文件的更快的方法，frombytes，tofile 12345678910111213141516from array import arrayfrom random import random# 用生成器表达式建立一个1000万个浮点数的数组。'd'是类型码，代表数组只能存放双精度浮点数fs = array('d', (random() for i in range(10**7)))print(fs[-1])fp = open('floats.bin', 'wb')fs.tofile(fp) #将1000万个浮点数以二进制格式写入一个二进制文件fp.close()fs2 = array('d')fp = open('floats.bin','rb')fs2.fromfile(fp, 10**7)fp.close()print(fs2[-1])print(fs == fs2) #两个数组的内容一模一样 从Python3.4开始，数组类型不在支持诸如list.sort()这种就地排序，排序要用sorted函数新建一个数组。 内存视图：能让用户在不复制内容的情况下操作同一个数组的不同切片。memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象。 1234567891011121314import arraynums = array.array('i', [2, 3, 4, 5])memv = memoryview(nums)print(memv[0]) #2memv[0] = 1print(nums[0]) #1memv_n = memv.cast('B')memv_n[0] = 9print(memv[0]) #9print(memv_n[0]) #9print(nums[0]) #9 双向队列和其他形式的队列： 1234567891011121314151617from collections import dequedq = deque(range(10), maxlen=10) # maxlen可选参数，指定队列的最大长度，超出的元素将被舍弃dq.rotate(3) # 旋转：接受一个参数n，当n&gt;0时，从队列最右边的n个元素移动到队列左边。当n&lt;0时，反之。dq.rotate(-4)dq.append(10) # 从队列尾部（右边）添加一个元素dq.append([10, 20]) # 从队列尾部添加一个列表元素dq.appendleft(10) # 与append相反dq.appendleft([10, 20])dq.extend([10, 20]) # 接受可迭代对象，将所有元素一个一个添加到队列右边dq.extendleft([10, 20]) # 与extend相反dq.pop() # 删除队列最右边的一个元素，并返回dq.popleft() append和popleft都是原子操作，deque可以在多线程程序中安全地当做FIFO的栈使用。 字典和集合泛映射类型collections.abc模块中有Mapping和MutableMapping两个基类。 ABC：Abstract Base Class 非抽象映射类型一般不直接继承这些abc，他们的作用是作为形式化文档，为dict何其他映射类型定义形式接口。还可以通过isinstance来判断某个数据是否是映射类型。 my_dict = {} # 或其他类型的Map isinstance(my_dict, abc.Mapping) # True 可散列类型： 如果一个对象是可散列的，那么在这个对象的声明周期中，它的散列值是不变的，而且这个对象要实现hash()方法。 另外可散列对象还有有qe()方法，这样才能和其他键值作比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。 原子不可变数据类型（str、butes和数值），frozenset，tuple（必须包含的所有元素都是可散列类型），都是可散列的。 可散列tuple： 1234t1 = (1, 2)hash(t1)t2 = (1, [])hash(t2) # TypeError: unhashable type: 'list' 字典的构造方法： 1234567a = &#123;'one': 1&#125;b = dict(&#123;'one': 1&#125;)c = dict(one=1)d = dict(zip(['one'], [1]))e = dict([('one', 1)])a == b == c == d == e # True 字典推导1234567891011CODES = [ (86, 'China'), (91, 'India'), (1, 'USA'), (55, 'Brazil'), (7, 'Russia'), (81, 'Japan')]codes = &#123;contry: code for code, contry in CODES if code &gt; 10&#125;print(codes) 映射的常用方法setdefault： my_dict.setdefault(key, []).append(new_value) 等价于 123if key not in my_dict: my_dict[key] = []my_dict[key].append(new_value) 等价于 123v = my_dict.get(key, [])v.append(new_value)my_dict[key] = v defaultdict： 123from collections import defaultdictd = defaultdict(list)d[key].append(new_value) 把list的构造方法作为default_factory来创建一个defaultdict，只会在getitem里被调用，其他比如get方法，在找不到键时只会返回None。 __missing__： 只被__getitem__调用，如defaultdict，在__missing__中实现了调用default_factory方法。 字典的变种collections.OrderedDict：添加键的时候会保持顺序 collections.ChainMap：可以容纳数个不同的映射对象，然后进行键查找时会把这些对象当成一个整体逐个查找。这个功能再给有嵌套作用域的语言做解释器的时候很有用，如： 1234567891011import builtinsprint(locals()) #本地变量print(globals()) #全局变量print(vars(builtins))collections.Counter：键-整数计数器，每次更新一个键的时候都会增加这个计数器。这个类型可以用来给可散列对象技术。ct = collections.Counter('absdfxasdasdf')ct.update('aaaadd')print(ct.most_common(2)) # 最常见的2个键和它们的计数 UserDict：子类化，以UserDict为基类创造自定义映射类型，它并不是dict的子类，继承的是MutableMapping，有一个data属性，是一个dict实例。最终存储数据的地方。 不可变映射类型：返回一个映射的只读视图，但是时动态的，如果原映射有改动，可以通过视图观察到。 123456789from types import MappingProxyTyped = &#123;1: 'A'&#125;d_proxy = MappingProxyType(d)print(d_proxy[1])d_proxy[1] = 'B' # 报错d[1] = 'B'print(d_proxy[1]) set保证元素的唯一性，集合中的元素必须是可散列的，set本身是不可散列的，但是frozenset可以 中缀运算：a|b，返回合集。a&amp;b返回交集，a-b返回差集 计算重叠元素的个数 found = len(needles &amp; haystack) #两侧都需要是集合类型 或 found = len(set(needles).intersection(haystack)) #如果一个对象还不是集合类型 直接使用set的交集计算比for遍历计算求和快的多 字面量：s = {1} 或 s = set([1]) 空集：s = set()，不能写{}（空字典） 直接写{1}的方式更快，因为Python会利用一个专门的BUILD_SET的字节码来创建集合。查看区别： 1234from dis import disdis('&#123;1&#125;')dis('set([1])') fronzenset只能通过构造方法创建。 集合推导： 123from unicodedata import nameprint(&#123;chr(c) for c in range(32, 256) if 'SIGN' in name(chr(c), '')&#125;) 集合的的继承关系： 基本操作： +/-/&amp;/| e in s，元素e是否属于s s &lt;= z，s是否为z的子集 s &lt; z，s是否为z的真子集 s &gt;=z/s&gt;z dict和set的背后原理散列表其实是一个稀疏数组（总有空白元素的数组），散列表的单元通常叫做表元（bucket），在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。 因为Python会设法保证大概还有三分之一的表元是空的，所以快要达到这个阈值时，原有的散列表会被复制到更大的空间里面进行扩容。 散列表算法为了获取dict[search_key]背后的值，Python首先会调用hash(search_key)来计算search_key的散列值，取这个值最低的几位数字（具体几位看当前散列表的大小）当做偏移量，在散列表里查找表元。若找到的表元是空的，则抛出KeyError异常。若不是空的，则表元里会有一堆found_key:found_value，这时候进行校验search_key == found_key是否为真，如果相等，则返回found_value。 如果search_key和found_key不匹配的话，这种情况称为散列冲突。发生这种情况原因是，把随机元素映射到几位的数字上，而索引又依赖于这几位数字的一部分而已。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当成索引寻找表元，重复以上给欧成。 添加和更新操作几乎跟上面一样。 dict的实现及其限制 键必须是可散列的 支持hash()函数，并且通过 __hash__() 方法得到的散列值是不变的。 支持通过 __eq__() 方法来检测相对性。 若a == b为真，则hash(a) == hash(b) 也为真。 所有由用户自定义的对象默认都是可散列的，散列值由id()来计算获取。 字典内存开销巨大 为了保持散列表是稀疏的，将降低在空间上的效率。 如果要存放数量巨大的纪录，元组或具名元组构成的列表是比较好的选择。 键查询很快 dict是典型的空间换时间，内存开销大，但是查询速度快。 键的次序取决于添加顺序 添加新键又发生散列冲突时，新键可能会被安排存放到另一个位置。这将导致键的顺序乱掉。 往字典里添加新键可能会改变已有键的顺序 无论何时添加新键，Python解释器都可能做出字典寇蓉的决定。扩容导致把字典中已有的元素添加到更大的新表中，过程中如果发生散列冲突，将导致新标中键的次序变化。因此不要同时对字典进行迭代和修改，最好分开两步进行。 文本和字节序列字符问题Unicode字符标识和字节表述： 字符的标识，即码位。是0~1114111的数字，以4~6个十六进制数字表示。 字节表述取决于所用的编码，是在码位和字节序列之间转换时使用的算法。如UTF-8，字符在ASCII范围内用的编码成1个字节，一个汉字占3个字节。 字节概要调用各自的构造方法，构建bytes或bytearray实例。 一个str对象和一个encoding关键字参数。 一个可迭代对象，提供0~255之间的数值。 一个实现了缓冲协议的对象（bytes，bytearray，memoryview，array.array），把源对象中的字节序列复制到新建的二进制序列中。 12345678910cafe = bytes('café', encoding='utf8')print(cafe) # b'caf\xc3\xa9'print(type(cafe)) # bytesprint(cafe[0]) # 99 0~255的整数print(cafe[:1]) # b'c' 一个字节的切片仍是bytes类型cafe_arr = bytearray(cafe)print(cafe_arr) # bytearray(b'caf\xc3\xa9')print(cafe_arr[-1:]) # bytearray(b'\xa9') 各个字节的值可能使用下列三种不同的方式显示， 可打印的ASCII范围内的字节（空格到~），使用ASCII字符本身。 制表符、换行符、回车符和\，使用转义序列\t、\n、\t和\。 其他字节，使用十六进制转义序列（\x00） 编码异常UnicodeEncodeError：编码时，编解码器没有定义某个字符时，就会抛出 123456city = 'São Paulo'city.encode('utf_8')city.encode('cp437') #抛出异常city.encode('cp437', errors='ignore') #忽略并删除无法编码的字符city.encode('cp437', errors='replace') #把无法编码的字符替换成'?'city.encode('cp437', errors='xmlcharrefreplace') #把无法编码的字符替换成XML实体 UnicodeDecodeError：解码时碰到无法转换的字节序列时会抛出 1234octets = b'Montr\xe9al'octets.decode('cp1252')octets.decode('utf_8') #抛出异常octets.decode('utf_8', errors='replace') #\xe9替换成“黑色菱形问号”（码位是U+FFFD），这是官方指定的 REPLACEMENT CHARACTER（替换字符），表示未知字符。 处理文本文件123456789import osopen('cafe.txt', 'w', encoding='utf_8').write('café') # 返回写入Unicode字符数，4# 报告文件中有5个字节：caf是ASKII范围内的字符，占一个字节，最后一个特殊字符占两个字节os.stat('cafe.txt').st_size print(open('cafe.txt', encoding='utf8').read())fp4 = open('cafe.txt', 'rb') # 以二进制模式打开文件。常规代码只应该使用二进制模式打开二进制文件fp4.read() # b'caf\xc3\xa9' 如果读取时不指定编码格式，那么Python会使用系统默认的编码，很有可能出现乱码。所以需要在多台设备或场合下运行的代码，打开读取文件时应始终明确传入encoding参数。 编码默认值： 12345678910111213141516171819202122import sysimport localeexpressions = """ locale.getpreferredencoding() type(my_file) my_file.encoding sys.stdout.isatty() sys.stdout.encoding sys.stdin.isatty() sys.stdin.encoding sys.stderr.isatty() sys.stderr.encoding sys.getdefaultencoding() sys.getfilesystemencoding()"""my_file = open('dummy', 'w')for expression in expressions.split(): value = eval(expression) print(expression.rjust(30), '-&gt;', repr(value)) 输出： 1234567891011locale.getpreferredencoding() -&gt; 'cp936' type(my_file) -&gt; &lt;class '_io.TextIOWrapper'&gt; my_file.encoding -&gt; 'cp936' sys.stdout.isatty() -&gt; True sys.stdout.encoding -&gt; 'utf-8' sys.stdin.isatty() -&gt; True sys.stdin.encoding -&gt; 'utf-8' sys.stderr.isatty() -&gt; True sys.stderr.encoding -&gt; 'utf-8' sys.getdefaultencoding() -&gt; 'utf-8'sys.getfilesystemencoding() -&gt; 'utf-8' 一等函数把函数视作对象“一等对象”的定义为满足下述条件的程序实体： 函数是一等对象。 在运行时创建。 可以赋值给变量，通过变量调用。 能作为参数传给函数。 能作为函数的返回结果。 123456789101112def factorial(n): '''return n!''' return 1 if n &lt; 2 else n * factorial(n-1)print(factorial(42))print(factorial.__doc__)print(type(factorial))fact = factorialprint(fact(5))print(map(fact, range(10)))print(list(map(fact, range(10)))) 高阶函数接受函数为参数或返回函数为结果的是函数是高阶函数，如map，sorted map，filter返回生成器，因此现在它们的直接替代品是生成器表达式。 functools.reduce，最常用于求和。 all(iterable)，如果iterable的每个元素都是真值，就返回True。 any(iterable)，如果iterable中有元素是真值，就返回True。 匿名函数因为句法限制，lambda函数的定义体不能赋值和使用while等语句，在Python中很少使用。 12words = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']print(sorted(words, key=lambda word: word[::-1])) 可调用对象可被调用运算符（即()）应用的，叫做可调用对象，可以使用callable()函数判断。 包括： 用户定义的函数（def或lambda创建） 内置函数（C语言实现的函数，如len） 内置方法（C语言实现的方法，如dict.get） 方法（在类的定义体中定义的函数） 类（调用顺序为 __new__，__init__ 初始化实例，然后返回给调用方） 类的实例（定义了 __call__ 方法的类） 生成器函数（使用yield关键字的函数或方法，返回的是生成器对象） 用户定义的可调用类型实现了 __call__ 的对象： 123456789101112class Bingo(): def __init__(self, items): self._items = list(items) def pick(self): return self._items.pop() def __call__(self): return self.pick()b = Bingo(range(3))print(b()) 函数内省dir函数可以探知对象的属性，计算出函数专有而一般对象没有的属性： 12345class C(): passc = C()def func(): passprint(set(dir(func))-set(dir(c))) 从定位参数到仅限关键字参数123456789101112131415161718192021def tag(name='p', *content, cls=None, **attrs): if cls: attrs['class'] = cls if attrs: attrs_str = ''.join(' &#123;&#125;="&#123;&#125;"'.format(attr, value) for attr, value in attrs.items()) else: attrs_str = '' if content: return '\n'.join('&lt;&#123;&#125;&#123;&#125;&gt;&#123;&#125;&lt;/&#123;&#125;&gt;'.format(name, attrs_str, c, name) for c in content) return '&lt;&#123;&#125;&#123;&#125; /&gt;'.format(name, attrs_str)print(tag('br'))print(tag('p', 'hello'))print(tag('p', 'hello', 'world', id='33', cls='side'))print(tag(content='内容', name='img'))d = &#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;print(tag(**d)) cls即仅限关键字的参数，因为未指定关键字的参数会被cls前面的*content捕获，并且cls有默认值可不指定，所以想要指定的话就必须指定关键字。 获取关于参数的信息1234567891011from inspect import signaturedef tag(name, *content, cls=None, **attrs): passprint(tag.__defaults__) # None,如果形参是name='xx',则是('xx',)。返回一个元组，保存的定位参数和关键字参数的默认值print(tag.__code__) # &lt;code object tag at ...&gt;，一个 code 对象引用， 自身也有很多属性print(tag.__code__.co_varnames) # ('name', 'cls', 'content', 'attrs') print(tag.__code__.co_argcount) # 1 更好更直观的方式： 12345678910111213141516171819202122232425sig = signature(tag)print(sig) # (name='p', *content, cls=None, **attrs)for name, param in sig.parameters.items(): print(param.kind, ':', name, '=', param.default) # POSITIONAL_OR_KEYWORD : name = &lt;class 'inspect._empty'&gt;。通过定位参数和关键字参数传入的形参 # VAR_POSITIONAL : content = &lt;class 'inspect._empty'&gt;。定位参数元组 # KEYWORD_ONLY : cls = None。仅限关键字参数 # VAR_KEYWORD : attrs = &lt;class 'inspect._empty'&gt;。关键字参数字典。my_tag = &#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;bound_args = sig.bind(**my_tag) # 尝试绑定，验证参数，规则同调用# &lt;BoundArguments (name=&#123;'name': 'img', 'title': 'Sunset Boulevard', 'src': 'sunset.jpg', 'cls': 'framed'&#125;)&gt;print(bound_args)for name, value in bound_args.arguments.items(): print(name, '=', value) # name = img # cls = framed # attrs = &#123;'title': 'Sunset Boulevard', 'src': 'sunset.jpg'&#125;del my_tag['name']bound_args = sig.bind(**my_tag) #抛出TypeError，缺少name参数。或提供name的默认值 函数注解123456789101112from inspect import signaturedef clip(text: str, max_len: 'int &gt; 0123'=80) -&gt; str: passsig = signature(clip)print(sig.return_annotation) # &lt;class 'str'&gt;for param in sig.parameters.values(): note = repr(param.annotation).ljust(30) print(note, ':', param.name, '=', param.default) # &lt;class 'str'&gt; : text = &lt;class 'inspect._empty'&gt; # 'int &gt; 0123' : max_len = 80 函数式编程的包operator模块：多个算术运算符提供了对应的函数， 从而避免编写lambda a, b: a*b这种平凡的匿名函数。 12345678910111213141516171819202122232425262728293031323334from functools import reducefrom operator import muldef fact(n): # return reduce(lambda curr, item: curr*item, range(1, n+1)) return reduce(mul, range(1, n+1))itemgetter，itemgetter(1) 即 lambda fields: fields[1]attrgetterfrom operator import itemgetter, attrgetterfrom collections import namedtuplemetro_data = [ ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),]for city in sorted(metro_data, key=itemgetter(1)): # 按某个字段排序 print(city)for city in metro_data: print(itemgetter(0, 1)(city))LatLong = namedtuple('LatLong', 'lat long')Metropolis = namedtuple('Metropolis', 'name cc pop coord')metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) for name, cc, pop, (lat, long) in metro_data]print(metro_areas[0])print(metro_areas[0].coord.lat)name_lat = attrgetter('name', 'coord.lat')for city in sorted(metro_areas, key=attrgetter('coord.lat')): print(name_lat(city)) methodcaller： 123456789101112131415161718192021from operator import methodcallers = 'The time has come'upcase = methodcaller('upper')hiphenate = methodcaller('replace', ' ', '-')print(upcase(s))print(hiphenate(s))使用functools.partial 冻结参数：即柯里化，基于一个函数创建一个新的可调用对象，固定指定某些参数from operator import mulfrom functools import partialtriple = partial(mul, 3)print(list(triple(i) for i in range(10)))picture = partial(tag, 'img', cls='pic-frame')picture(src='some.jpg') 使用一等函数实现设计模式策略模式经典的策略模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from abc import ABC, abstractmethodfrom collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem(): def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order(): def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(c.total() for c in self.cart) return self.__total def due(self): if self.promotion: discount = self.promotion.discount(self) else: discount = 0 return self.total()-discount def __repr__(self): fmt = '&lt;Order total:&#123;:.2f&#125; due:&#123;:.2f&#125;' return fmt.format(self.total(), self.due())class Promotion(ABC): @abstractmethod def discount(self, order): passclass FidelityPromo(Promotion): def discount(self, order): return order.total() * .05 if order.customer.fidelity &gt; 1000 else 0class BulkItemPromo(Promotion): def discount(self, order): return sum(item.total()*.1 for item in order.cart if item.quantity &gt;= 20)class LargeOrderPromo(Promotion): def discount(self, order): distinct_items = &#123;item.product for item in order.cart&#125; return order.total() * .07 if len(distinct_items) &gt;= 10 else 0ann = Customer('Ann Smith', 1100)cart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]print(Order(ann, cart, FidelityPromo())) 函数实现“策略”模式12345678910111213141516171819202122def fidelity_promo(order): return order.total() * .05 if order.customer.fidelity &gt; 1000 else 0def bulk_item_promo(order): return sum(item.total()*.1 for item in order.cart if item.quantity &gt;= 20)def large_order_promo(order): distinct_items = &#123;item.product for item in order.cart&#125; return order.total() * .07 if len(distinct_items) &gt;= 10 else 0promos = [fidelity_promo, bulk_item_promo, large_order_promo]def best_promo(order): return max(p(order) for p in promos)print(Order(ann, cart, best_promo)) 找出模块中的全部策略若想添加新的促销策略，要定义函数且加到promos列表中，下面尝试更灵活的方式。 globals：返回一个字典，表示当前的全局符号表 把策略方法封装到promotions模块中，使用inspect内省，取出 内省模块的全局命名空间， 构建 promos 列表： 123promos = [globals()[name] for name in globals() if name.endswith('_promo') and name != 'best_promo'] 内省单独的 promotions 模块， 构建 promos 列表： 1promos = [func for name, func in inspect.getmembers(promotions, inspect.isfunction)] 命令模式命令模式是回调机制的面向对象替代品，目的是解耦调用者和接收者。做法是在调用者和接收者之间放一个Command对象，让它实现execute接口，调用接受者自己的方法执行所需的操作，这样调用者无需了解接收者的接口，不同的接收者也可以适应不同的Command子类。 在 Python 中使用函数或可调用对象实现回调更自然，可以不用为调用者提供一个Command实例，而是给它一个函数，调用者不用调用command.execute()，直接调用command()即可。 12345678class MacroCommand(): def __init__(self, commands): self.commands = commands def __call__(self): for command in self.commands: command() 函数装饰器和闭包装饰器基础装饰器是可调用对象，参数是被装饰的函数。可以把它替换掉也可以原样返回。 12345678910def decorate(func): def inner(): print('running inner') return inner@decoratedef target(): print('running target')print(target) # &lt;function decorate.&lt;locals&gt;.inner at ...&gt; 装饰器只是语法糖： 123@decoratedef target(): pass 可以转换为： 123def target(): passtarget = decorate(target() 装饰器的执行时机装饰器在被装饰的函数定义之后立即执行，这通常是在导入时（即Python加载模块时）。 1234567891011121314def reister(func): print('running reister &#123;&#125;'.format(func)) return func@reisterdef f1(): print('running f1')def main(): print('running main') f1()if __name__ == '__main__': main() 打印如下： 123running reister &lt;function f1 at ...&gt;running mainrunning f1 装饰器在真实代码中的常用方式： 装饰器通常定义在一个模块中，然后应用到其他模块中的函数上。 大多数装饰器会在内部定义一个函数，然后将其返回。也可能原样返回，比如很多Python Web框架使用这样的装饰器把函数添加到某种中央注册处。比如上面的例子中，使用促销装饰器把所有促销注册起来，供best_promo使用。 变量作用域1234567b = 6def func(a): print(a) print(b) b = 9func(1) 会报错local variable ‘b’ referenced before assignment，Python判断b是局部变量，运行时从本地环境中获取，但是还未定义，所以报错。通过dis查看操作b的字节码为LOAD_GLOBAL。 改为： 123456789b = 6def func(a): global b #让解释器把b当成全局变量 print(a) print(b) b = 9func(1)print(b) # 9 不再报错，读取和修改的都是全局变量。通过dis查看操作b的字节码为LOAD_FAST。CPython VM是栈机器，LOAD和POP操作引用的是栈。 闭包闭包指延伸了作用域的函数， 它能访问定义体之外定义的非全局变量。 1234567891011121314def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()print(avg(10))print(avg(22)) 在 averager 中， series 是自由变量（free variable， 指未在本地作用域中绑定的变量）。 1234print(avg.__code__.co_varnames) # 局部变量print(avg.__code__.co_freevars) # 自由变量print(avg.__closure__) # 一个元组 (&lt;cell at 0x0000028489CDA4C8: list object at ...&gt;,)print(avg.__closure__[0].cell_contents # nonlocal 声明123456789101112131415def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total # python3的关键字，python2中通过赋值给可变对象（如字典）的属性来实现。不加这一句下面将会报错，因为相当于声明了局部变量的count 。count = count + 1。在读取count时报错 count += 1 total += new_value return total / count return averageravg = make_averager()print(avg(1))print(avg(4)) 实现一个简单的装饰器12345678910111213141516171819202122232425262728293031import timedef clock(func): def clocked(*args): t0 = time.perf_counter() result = func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = ','.join(repr(arg) for arg in args) print('[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'.format(elapsed, name, arg_str, result)) return result return clocked@clockdef snooze(seconds): time.sleep(seconds)@clockdef factorial(n): return n if n == 1 else n * factorial(n-1)if __name__ == '__main__': print(factorial.__name__) # clocked。factorial已经被替换为clocked函数，__name__属性被覆盖 print('*'*40, 'Calling snooze(.123)') snooze(.123) print('*'*40, 'Calling factorial(6)') factorial(6) 使用functools.wraps装饰器解决name覆盖的问题： functools.wraps 装饰器会把相关的属性从 func 复制到 clocked 中。 1234567891011121314151617181920def clock(func): @functools.wraps(func) def clocked(*args, **kwargs): # 支持关键字参数 t0 = time.perf_counter() result = func(*args, **kwargs) elapsed = time.perf_counter() - t0 name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['&#123;&#125;=&#123;&#125;'.format(k, v) for k, v in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[&#123;:.8f&#125;s] &#123;&#125;(&#123;&#125;) -&gt; &#123;&#125;'.format(elapsed, name, arg_str, result)) return result return clocked 标准库中的装饰器functools.lru_cache： lru，即“Least Recently Used”。 它把耗时的函数的结果保存起来， 避免相同的参数重复计算。缓存不会无限制增长， 一段时间不用的缓存会被扔掉。 1234567891011import functools@functools.lru_cache() # ()调用，可传入配置参数@clockdef fibonacci(n): if n &lt; 2: return n return fibonacci(n-2) + fibonacci(n-1)if __name__ == '__main__': print(fibonacci(20)) 极大的减少调用次数。 functools.lru_cache(maxsize=128, typed=False) 参数： maxsize，指定存储多少个调用的结果，应该设为2的幂。 typed，True会把不同参数类型得到的结果区分开，比如1和1.0。 因为lru_cache使用字典存储结果，所以被修饰的函数，所有参数都必须是可散列的。 functools.singledispatch： Python 不支持重载方法或函数， 所以我们不能使用不同的签名定义函数的变体， 也无法使用不同的方式处理不同的数据类型。 在Python 中， 一种常见的做法是把函数变成一个分派函数。singledispatch装饰器可以把整体方案拆分成多个模块。 12345678910111213141516171819from functools import singledispatchfrom collections import abcimport numbersimport html@singledispatchdef htmlize(obj): content = html.escape(repr(obj)) return '&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'.format(content)@htmlize.register(numbers.Integral)def _(n): # 函数名称无所谓 return '&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'.format(n)@htmlize.register(tuple)@htmlize.register(abc.MutableSequence) #可以叠放多个 register 装饰器def _(seq): inner = '&lt;/li&gt;\n&lt;li&gt;'.join(htmlize(item) for item in seq) return '&lt;ul&gt;\n&lt;li&gt;' + inner + '&lt;/li&gt;\n&lt;/ul&gt;' 叠放装饰器1234@d1@d2def f(): print('f') 相当于： 123def f(): print('f')f = d1(d2(f)) 参数化装饰器12345678910111213141516171819202122registry = set()def register(active=True): def decorate(func): print('running register(active=&#123;&#125;)-&gt;decorate(&#123;&#125;)'.format(active, func)) registry.add(func) if active else registry.discard(func) return func return decorate@register(active=False)def f1(): print('running f1()')@register()def f2(): print('running f2()')print(registry) # 只有f2 装饰器函数金字塔： 12345678910111213141516171819import timedef clock(): # 装饰器工厂 def decorate(func): # 装饰器 def clocked(*_args): # 包装被装饰的函数 t0 = time.time() _result = func(*_args) # 被包装的函数返回的真正结果 elapsed = time.time() - t0 # pass print('1') return _result # clocked会取代原函数，因此应该返回被装饰函数的返回值 return clocked # 装饰器返回包装函数 return decorate # 工厂返回一个装饰器@clock()def funcname(): pass 对象引用、可变性和垃圾回收标识、相等性和别名id()： 在 CPython 中， id() 返回对象的内存地址， 但是在其他 Python 解释器中可能是别的值。 关键是， ID 一定是唯一的数值标注， 而且在对象的生命周期中绝不会变。 ==和is： is运算符比==速度快，==是语法糖，等同于a.__eq__(b) 默认浅复制列表的内置构造函数或list[:]语句，做的都是浅复制（只复制最外层的容器，容器中的元素只复制引用）。 123456789101112l1 = [3, [66, 55, 44], (7, 8, 9)]l2 = list(l1)l1.append(100) # l1的容器添加一个元素l1[1].remove(55) print('l1:', l1)print('l2:', l2)l2[1] += [33, 22]l2[2] += (10, 11) # l2 创建了新的元组print('l1:', l1)print('l2:', l2) 深复制和浅复制： 1234from copy import deepcopycopy.copy(list) # 浅复制copy.deepcopy(list) # 深复制 函数的参数作为引用时Python 唯一支持的参数传递模式是共享传参，指函数的各个形式参数获得实参中各个引用的副本。 也就是说， 函数内部的形参是实参的别名。 123456789101112131415161718def f(a, b): a += b return ax = 1y = 2f(x, y)print(x, y) # x未改变a = [1, 2]b = [3, 4]f(a, b)print(a, b) # a改变t = (10, 20)u = (30, 40)f(t, u)print(t, u) # t未改变 不要使用可变类型作为参数的默认值，如： 12def __init__(self, passengers=[]): self.passengers = passengers 默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象， 而且修改了它的值， 那么后续的函数调用都会受到影响。 默认值会储存在class.__init__.__defaults__的属性里（一个tuple）。 防御可变对象参数： 当参数是可变对象时，如果没有约定的情况下，最好创造一个可变参数的副本，如： 12345def __init__(self, passengers=None): if passengers is None: self.passengers = [] else: self.passengers = list(passengers) 这样就不会影响外部的对象了。 del 和 垃圾回收del语句删除名称，而不是对象。仅当删除的变量保存的是对象的最后一个引用， 或者无法得到对象时，del 命令才可能导致对象被当作垃圾回收。 在 CPython 中， 垃圾回收使用的主要算法是引用计数。 实际上， 每个对象都会统计有多少引用指向自己。 当引用计数归零时， 对象立即就被销毁： CPython 会在对象上调用 __del__ 方法（如果定义了），然后释放分配给对象的内存。 1234567891011121314import weakrefdef bye(): print('Gone with the wind...')s1 = &#123;1, 2, 3&#125;s2 = s1ender = weakref.finalize(s1, bye)print(ender.alive) # Truedel s1print(ender.alive) # Trues2 = 'spam' # Gone..print(ender.alive) # False 弱引用弱引用不会增加对象的引用数量，不会妨碍所指对象被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用而始终缓存对象。 12345678910111213141516&gt;&gt;&gt; import weakref&gt;&gt;&gt; a_set = &#123;0, 1&#125;&gt;&gt;&gt; wref = weakref.ref(a_set) # 创建弱引用&gt;&gt;&gt; wref&lt;weakref at 0x0000021194B76598; to 'set' at 0x00000211969AF588&gt;&gt;&gt;&gt; wref() # 返回被引用的对象，但因为是控制台会话，所以&#123;0,1&#125;会绑定给_变量&#123;0, 1&#125;&gt;&gt;&gt; a_set = &#123;0, 1, 2&#125; # a_set 不再指代&#123;0,1&#125;集合，但是变量_仍然指代它&gt;&gt;&gt; wref()&#123;0, 1&#125;&gt;&gt;&gt; _&#123;0, 1&#125;&gt;&gt;&gt; wref() is None # 返回值False绑定给变量_，&#123;0,1&#125;没有强引用了False&gt;&gt;&gt; wref() is None # &#123;0,1&#125;对象不存在了True weakref.ref类其实是低层接口，最好不要手动处理weakref.ref实例，而是使用weakref集合。 符合Python风格的对象向量类1234567891011121314151617181920212223242526272829303132333435363738394041from array import arrayimport mathclass Vector2d(): typecode = 'd' def __init__(self, x, y): self.x = float(x) self.y = float(y) def __iter__(self): yield self.x yield self.y # return (i for i in (self.x, self.y)) def __repr__(self): class_name = type(self).__name__ return '&#123;&#125;(&#123;!r&#125;,&#123;!r&#125;)'.format(class_name, *self) def __str__(self): return str(tuple(str)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.hypot(self.x, self.y) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(*memv) classmethod与staticmethodclassmethod： 定义操作类的方法，第一个参数是类本身，最常见的用途是定义备选构造函数 staticmethod： 静态方法就是普通函数，只是碰巧在类的定义体中，而不是在模块层定义的。完全可以不用使用它。 123456789101112class Demo(): @classmethod def klassmeth(*args): return args @staticmethod def statmeth(*args): return argsprint(Demo.klassmeth(1)) # (&lt;class '__main__.Demo'&gt;, 1)print(Demo.statmeth(1)) # (1,) 格式化显示委托给相应的 __format__(format_spec) 方法 1234brl = 1/2.43print(brl) # 0.4115226337448559print(format(brl, '.4f')) # 0.4115print('1 BRL = &#123;rate:.2f&#125; USD'.format(rate=brl)) # 1 BRL = 0.41 USD rate是字段名，.4f是格式规范微语言。 整数使用的代码有 ‘bcdoxXn’， 浮点数使用的代码有’eEfFgGn%’， 字符串使用的代码有 ‘s’。 格式规范微语言文档（https://docs.python.org/3/library/string.html#formatspec） 12print(format(42, 'b')) # b二进制 o八进制 x十六进制print(format(2/3, '.1%')) # 66.7% 如果没有定义__format__方法，从object继承的方法会返回str(obj)。 print(format(v)) # (2.0, 3.0) 但是如果传入格式说明符，object.format方法会抛出TypeError。 print(format(v,&#39;.2f)) # TypeError 给Vector2d定义__format__方法： 12345def __format__(self, fmt_spec=''): compoments = (format(c, fmt_spec) for c in self) return '(&#123;&#125;,&#123;&#125;)'.format(*compoments)print(format(v, '.2f')) # (2.00,3.00) 自定义格式代码： 假设我们自定义的代码为p，用来显示极坐标中的向量 123456789101112131415161718def angle(self): return math.atan2(self.y, self.x)def __format__(self, fmt_spec=''): if fmt_spec.endswith('p'): fmt_spec = fmt_spec[:-1] coords = (abs(self), self.angle()) outer_fmt = '&lt;&#123;&#125;,&#123;&#125;&gt;' else: coords = self outer_fmt = '(&#123;&#125;,&#123;&#125;)' compoments = (format(c, fmt_spec) for c in coords) return outer_fmt.format(*compoments)print(format(v, 'p')) # &lt;3.605551275463989,0.982793723247329&gt;print(format(v, '.5fp')) # &lt;3.60555,0.98279&gt; 可散列的Vector2d123456789101112131415# other codedef __init__(self, x, y): self.__x = float(x) # 使用两个__把属性"标记"为私有的 self.__y = float(y)@property # 把读值方法标记为特性def x(self): # 方法名即公开属性名 return self.__x@propertydef y(self): return self.__ydef __hash__(self): return hash(self.x) ^ hash(self.y) # 最好使用位运算符异或(^)混合各分量的散列值 让这些向量不可变是有原因的， 因为这样才能实现hash 方法。 私有属性和“受保护”的属性12def __init__(self, x, y): self.__x = float(x) 使用两个_作为前缀命名实例属性，Python会把属性名存入实例的dict属性中，而且会进行“名称改写”，如prop会被改写成_ClassNameprop。 123v = Vector2d(3, 4)print(v.__dict__) # &#123;'_Vector2d__x': 3.0, '_Vector2d__y': 4.0&#125;，__dict__为实例的可读属性的键值字典print(v.__dir__()) # __dir__()方法返回实例和类的所有属性名和方法名的list 也有人不喜欢这种不对称的名称，他们约定使用一个_前缀编写“受保护”的属性，如self._x。Python不会对这种属性名做特殊处理，这仅仅是程序员之间遵守的约定，他们不会在类外部访问这种属性。 使用slots类属性节省空间创建一个类属性，使用 __slots__ 这个名字， 并把它的值设为一个字符串构成的可迭代对象。 12class Vector2d: __slots__ = ('__x', '__y') 作用是告诉解释器，这个类中的所有实例属性都在这儿了！ Python会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的dict属性。当同时有数百万个实例活动时，能节省大量内存。 副作用是定义了slots属性之后，实例不能再有slots 中所列名称之外的其他属性。 但故意这样禁止用户新增属性是不对的。 如果定义了slots属性，且想让对象支持弱引用，则必须把weakref添加到slots中。 解释器会忽略继承的slots属性，所以每个子类都要定义slots属性。 覆盖类属性1234567class Vector2d(): typecode = 'd'v = Vector2d(3, 4)print(v.typecode) # dv.typecode = 'f'print(v.typecode) # f 类属性为实例属性提供默认值，但是并不代表实例拥有此实例，如果为类属性赋值，类属性不会受影响，实例会创建同名的属性覆盖掉类属性。想要修改类属性，需要直接在类上修改，Vector2d.typecode = &#39;f&#39;。 序列的修改、散列和切片1234567891011121314151617181920212223242526272829303132333435363738394041from array import arrayimport reprlibimport mathclass Vector(): typecode = 'd' def __init__(self, components): self._components = array(self.typecode, components) def __iter__(self): return iter(self._components) def __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return 'Vector(&#123;&#125;)'.format(components) def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components)) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.sqrt(sum(x ** 2 for x in self)) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv) reprlib.repr() 函数获取 self._components 的有限长度表示形式（如 array(‘d’, [0.0, 1.0, 2.0, 3.0, 4.0, …])） 。 协议和鸭子类型12345def __len__(self): return len(self._components)def __getitem__(self, index): return self._components[index] 协议是非正式的接口， 只在文档中定义， 在代码中不定义。 例如， Python 的序列协议只需要 __len__ 和 __getitem__ 两个方法。 任何类（如 Spam）只要实现了这两个方法， 就能用在任何期待序列的地方。 12v = Vector([1, 2, 3, 4, 5])print(v[1:2]) # array('d', [2.0]) 可切片的序列切片原理12345678910class MySeq(): def __getitem__(self, index): return indexs = MySeq()print(s[1]) # 1print(s[1:2]) # slice(1, 2, None)print(s[1:2:3]) # slice(1, 2, 3)print(s[1:2:3, 4]) # (slice(1, 2, 3), 4)。多维切片，__getitem__收到的是元组print(s[1:2:3, 4:5]) # (slice(1, 2, 3), slice(4, 5, None)) slice.indices方法： 123print(slice(None, 10, 2)) # slice(None, 10, 2)print(slice(None, 10, 2).indices(5)) # (0, 5, 2)print(slice(-3, None, None).indices(5)) # (2, 5, 1) indices方法提供了内置序列实现的复杂“整顿”逻辑，用于优雅地处理索引缺失、负数、长度过长等情况。如果自定义的getitem最终不是依靠的底层序列，那么可以使用这个方法节省大量时间。 自定义切片的getitem1234567891011121314def __getitem__(self, index): cls = type(self) if isinstance(index, slice): return cls(self._components[index]) # 返回当前类型的切片，而不是委托给数组返回一个数组的切片 elif isinstance(index, numbers.Integral): return self._components[index] else: msg = '&#123;cls.__name__&#125; indices must be integers' raise TypeError(msg.format(cls=cls))s = Vector(range(100))print(type(s[1])) # Vectorprint(type(s[1:10])) # Vectorprint(s[1:10, 2]) # TypeError 动态存取属性使用x、y、z、t来取代v[0]，v[1]，v[2]，v[3]。 123456789def __getattr__(self, name): cls = type(self) if len(name) == 1: pos = cls.shortcut_names.find(name) if len(self._components) &gt; pos &gt;= 0: return self._components[pos] # .__name__会从cls中取值，!r以文本形式'' msg = '&#123;.__name__!r&#125; objects has no attribute &#123;!r&#125;' raise AttributeError(msg.format(cls, name)) 为了防止直接向v.x赋值而创建一个新的属性。 1234567891011121314def __setattr__(self, name, value): cls = type(self) if len(name)=1: if name in cls.shortcut_names: error = 'readonly attribute &#123;attr_name!r&#125;' elif name.islower(): error = "can't set attribute 'a' to 'z' in &#123;cls_name!r&#125;" else: error = '' if error: msg = error.format(cls_name=cls.__name__, attr_name=name) raise AttributeError(msg) super().__setattr__(name, value) # 在超类上调用 __setattr__ 方法， 提供标准行为 散列和快速等值测试规约函数reduce,sum,any,all把序列或有限可迭代对象编程一个聚合结果。reduce函数的参数，第一个函数是接受两个参数的函数，第二个参数是一个可迭代的对象，第三个参数是初始值。 reduce(fn,lst)： fn(lst[0],lst[1]) -&gt; r1fn(r1,lst[2]) -&gt; r2fn(r2,lst[3]) -&gt; r3... 实现阶乘的三种方式： 1. 123n = 0for i in range(1, 6): n ^= 1 2. functools.reduce(lambda a, b: a ^ b, range(6)) 3. functools.reduce(operator.xor, range(6)) 把Vector变成可散列的对象：123def __hash__(self): hashes = (hash(x) for x in self._components) return functools.reduce(operator.xor, hashes, 0) 修改 __eq__ 方法： 使用zip函数 1234567def __eq__(self, other): if len(self) != len(other): return False for a, b in zip(self, other): if a != b: return False return True 使用all函数 12def __eq__(self, other): return len(self) == len(other) and all(a == b for a, b in zip(self, other)) 出色的zip函数： zip函数能并行迭代两个或多个可迭代对象，它返回的元组可以拆包成变量，分别对应各个并行输入中的一个元素。 123456from itertools import zip_longestprint(zip(range(3), 'ABC')) # &lt;zip object at ...&gt;print(list(zip(range(3), 'ABC'))) # [(0, 'A'), (1, 'B'), (2, 'C')]# [(0, 'A', 1), (1, 'B', 2), (2, 'C', 3), (-1, -1, 4)]print(list(zip_longest(range(3), 'ABC', [1, 2, 3, 4], fillvalue=-1))) itertools.chain函数：合并两个序列 123456import itertoolsl1 = [1,2,3]t1 = (4,5,6)r1 = itertools.chain(l1,t1)print(r1) #&lt;itertools.chain object at ...&gt; 接口：从协议到抽象基类接口和协议协议：非正式的接口，不能像正式接口那样施加限制，是Python实现多态的方式。一个类可依只实现部分接口，这是允许的。 1234567class Foo: def __getitem__(self, pos): return range(0, 30, 10)[pos]f = Foo()f[1]for i in f: print(i) Foo类没有继承abc.Sequence，只实现了序列协议的一个方法：__getitem__，没有__iter__方法，但是仍然会后备使用__getitem__来进行迭代。没有实现__contains__方法，但是也能使用in运算。 使用猴子补丁在运行时实现协议123456import randomfrom french_deck import FrenchDeckf = FrenchDeck()# 就地打乱, TypeError: 'FrenchDeck' object does not support item assignmentrandom.shuffle(f) 我们可以动态修正这个问题： 12345def set_card(self, position, card): self._cards[position] = cardFrenchDeck.__setitem__ = set_cardrandom.shuffle(f) 猴子补丁： 在运行时修改类或模块， 而不改动源码。 猴子补丁很强大， 但是打补丁的代码与要打补丁的程序耦合十分紧密， 而且往往要处理隐藏和没有文档的部分 标准库中的抽象基类collections.abc模块中的抽象基类collections.abc： Iterable、 Container 和 Sized： 各个集合应该继承这三个抽象基类， 或者至少实现兼容的协议。 Iterable 通过 __iter__ 方法支持迭代， Container 通过__contains__ 方法支持 in 运算符， Sized 通过 __len__ 方法支持len() 函数。 Sequence、 Mapping 和 Set： 这三个是主要的不可变集合类型， 而且各自都有可变的子类。 MappingView： 映射方法 .items()、 .keys() 和 .values() 返回的对象分别是 ItemsView、 KeysView 和 ValuesView 的实例。 前两个类还继承了 Set 类 Callable 和 Hashable： 没有Callable 或 Hashable 的子类。 这两个抽象基类的主要作用是为内置函数 isinstance 提供支持， 以一种安全的方式判断对象能不能调用或散列。若想检查是否能调用， 可以使用内置的 callable() 函数； 但是没有类似的 hashable() 函数， 因此测试对象是否可散列， 最好使用 isinstance(my_obj, Hashable)。 抽象基类的数字塔numbers包定义的抽象基类是线性的层次结构，依次往下是，Number、Complex、Real、Rational、Integral。 检查是否为整数，isinstance(x,numbers.Integral)。 定义使用一个抽象基类定义： 123456789101112131415161718192021222324252627import abcclass Tombola(abc.ABC): #自己定义的抽象基类要继承 abc.ABC。 @abc.abstractmethod def load(self, iterable): """从可迭代对象中添加元素。 """ #抽象方法使用 @abstractmethod 装饰器标记， 而且定义体中通常只有文档字符串。 @abc.abstractmethod def pick(self): """随机删除元素， 然后将其返回。 如果实例为空， 这个方法应该抛出`LookupError`。 """ def loaded(self): #抽象基类可以包含具体方法 """如果至少有一个元素， 返回`True`， 否则返回`False`。 """ return bool(self.inspect()) def inspect(self): """返回一个有序元组， 由当前元素构成。 """ items = [] while True: try: items.append(self.pick()) except LookupError: break self.load(items) #抽象基类中的具体方法可以依赖抽象基类中的其他具体方法、 抽象方法或特性 return tuple(sorted(items)) 错误的实现： 123456from tombola import Tombolaclass Fake(Tombola): passf = Fake() # TypeError: Can't instantiate abstract class Fake with abstract methods load, pick 正确的实现： 123456789101112131415161718192021import randomfrom tombola import Tombolaclass BingoCage(Tombola): def __init__(self, items): self._randomizer = random.SystemRandom() self._items = [] self.load(items) def load(self, items): self._items.extend(items) self._randomizer.shuffle(self._items) def pick(self): try: return self._items.pop() except IndexError as e: raise LookupError('pick from empty BingoCage') def __call__(self): self.pick() 虚拟子类： 在抽象基类上调用register方法，issubclass和isinstance等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。Python也不会做检查。 12345678910111213141516171819from random import randrangefrom tombola import Tombola@Tombola.registerclass TomboList(list): def pick(self): if self: position = randrange(len(self)) return self.pop(position) else: raise LookupError('pop from empty TomboList') load = list.extend def loaded(self): return bool(self) def inspect(self): return tuple(sorted(self)) 虚拟子类检查： 1234567from tombola import Tombolafrom tombolist import TomboListprint(issubclass(TomboList, Tombola)) # Truet = TomboList(range(100))print(isinstance(t, Tombola)) # True __mro__属性：方法解析顺序，按顺序列出类及其超类。 123# (&lt;class 'tombolist.TomboList'&gt;, &lt;class 'list'&gt;, &lt;class 'object'&gt;)print(TomboList.__mro__)print(Tombola) # &lt;class 'tombola.Tombola'&gt; Tombolist.__mro__ 中没有 Tombola， 因此 Tombolist 没有从Tombola 中继承任何方法。 继承内省属性： 12345# __subclasses__()，这个方法返回类的直接子类列表， 不含虚拟子类。print(Tombola.__subclasses__()) # [&lt;class 'bingo.BingoCage'&gt;]# _abc_registry，只有抽象基类有这个数据属性， 其值是一个 WeakSet 对象， 即抽象类注册的虚拟子类的弱引用。print([x for x in Tombola._abc_registry]) # [&lt;class 'tombolist.TomboList'&gt;] 使用registerTombola.register可以当做类装饰器使用，也可以当做函数调用Tombola.register(TomboList)。这种做法更常见，可用于注册其他地方定义的类，例如，在collections.abc模块的源码中，Sequence.register(tuple)Sequence.register(str)Sequence.register(range)Sequence.register(memoryview) __subclasshook__： 12345678from collections import abcclass Struggle(): def __len__(self): return 23print(issubclass(Struggle, abc.Sized)) # Trueprint(isinstance(Struggle(), abc.Sized)) # True 没有注册和继承，抽象基类也能把一个类识别为虚拟子类，因为abc.Sized实现了一个特殊的类方法，名为__subclasshook__。源码： 12345678910111213class Sized(metaclass=ABCMeta): __slots__ = () @abstractmethod def __len__(self): return 0 @classmethod def __subclasshook__(cls, C): if cls is Sized: if any("__len__" in B.__dict__ for B in C.__mro__): # C及其超类__dict__属性里是否有__len__属性 return True return NotImplemented 继承的优缺点子类化内置类型很麻烦直接子类化内置类型（如 dict、 list 或 str） 容易出错，因为内置类型的方法通常会忽略用户覆盖的方法（这种问题只发生在C语言实现的内置类型内部的方法委托上，而且只影响直接继承内置类型的用户自定义类）。 不要子类化内置类型， 用户自己定义的类应该继承 collections 模块（http://docs.python.org/3/library/collections.html） 中的类， 例如UserDict、 UserList 和 UserString， 这些类做了特殊设计， 因此易于扩展。 多重继承和方法解析顺序12345678910111213141516171819202122class A: def ping(self): print('ping:', self)class B(A): def pong(self): print('pong:', self)class C(A): def pong(self): print('PONG:', self)class D(B, C): # 声明中超类的顺序影响方法解析顺序 def ping(self): super().ping()print('post-ping:', self) def pingpong(self): self.ping() super().ping() self.pong() super().pong() C.pong(self) Python能区分子类调用的是哪个父类的方法，是因为Python会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order， MRO）。类都有一个名为__mro__的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object类。 1D.__mro__ # (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;) 也可以在子类中绕过方法解析顺序，直接调用某个超类的方法，比如，A.ping(self)，而不是super().ping()。 正确重载运算符略 可迭代的对象、迭代器和生成器单词序列12345678910111213141516171819202122232425262728293031import reimport reprlibRE_WORD = re.compile('\w+')class Sentence(): def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __getitem__(self, index): return self.words[index] def __len__(self): return len(self.words) def __repr__(self): return 'Sentence(&#123;&#125;)'.format(reprlib.repr(self.text))from sentence import Sentences = Sentence('"The time has come," the Walrus said,')print(s) # Sentence('"The time ha... Walrus said,')for word in s: print(word) # 可以迭代print(list(s)) 可以迭代的原因： 从 Python 3.4 开始， 检查对象 x 能否迭代， 最准确的方法是：调用 iter(x) 函数(或直接进行迭代)， 如果不可迭代， 再处理 TypeError 异常。 这比使用 isinstance(x, abc.Iterable) 更准确， 因为 iter(x)函数会考虑到遗留的 __getitem__ 方法， 而 abc.Iterable 类则不考虑。 可迭代的对象与迭代器的对比使用 iter 内置函数可以获取迭代器的对象。 如果对象实现了能返回迭代器的 __iter__ 方法， 那么对象就是可迭代的。 可迭代的对象和迭代器之间的关系： Python 从可迭代的对象中获取迭代器。 123s = 'ABC'for c in s: print(c) 字符串’ABC’是可迭代的对象，背后运行的是迭代器。 不使用for语句的话，就需要使用while和iter组合迭代。 12345678910s = 'ABC'it = iter(s)while True: try: print(next(it)) #或 print(it.__next__()) except StopIteration as e: # 如果没有下一个元素，抛出StopIteration del it # 释放引用，废弃迭代器对象 break 标准的迭代器接口有两个方法： __next__，返回下一个可用元素或无元素时抛出StopIteration异常。 __iter__，返回self，以便在应该使用可迭代对象的地方使用迭代器，例如在for循环中。 collections.abc.Iterator抽象基类中定义了__next__抽象方法。且这个抽象基类继承自collections.abc.Iterable类，这个类中定义了__iter__抽象方法。 123i1 = id(s.__iter__()) # 返回字符串的迭代器i2 = id(s.__iter__().__iter__()) # 迭代器返回自身print(i1 == i2) # True Python中的迭代器是一种协议，而不是某种特定的类型。所以判断一个对象x(或类)是否为迭代器最好的方式是调用isinstance(x, abc.Iterator)(或issubclass)，得益于Iterator.__subclasshook__ 方法， 即使对象 x 所属的类不是Iterator 类的真实子类或虚拟子类， 也能这样检查。 123456789class X(): def __iter__(self): pass def __next__(self): passprint(issubclass(X, collections.abc.Iterator)) #True，因为实现了__iter__和__next__协议print(isinstance(X(), collections.abc.Iterable)) #True，因为事先了__iter__协议 迭代器的定义： 迭代器是这样的对象： 实现了无参数的 __next__ 方法， 返回序列中的下一个元素； 如果没有元素了， 那么抛出 StopIteration 异常。Python 中的迭代器还实现了 __iter__ 方法， 因此迭代器也可以迭代。 典型的迭代器123456789101112131415161718192021class Sentence(): # ... def __iter__(self): return SentenceIterator(self.words)class SentenceIterator(): def __init__(self, words): self.words = words self.index = 0 def __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word def __iter__(self): return self 为了“支持多种遍历”， 必须能从同一个可迭代的实例中获取多个独立的迭代器， 而且各个迭代器要能维护自身的内部状态， 因此这一模式正确的实现方式是， 每次调用 iter(my_iterable) 都新建一个独立的迭代器。 这就是为什么这个示例需要定义SentenceIterator 类。 可迭代的对象一定不能是自身的迭代器。 也就是说， 可迭代的对象必须实现 __iter__ 方法， 但不能实现 __next__ 方法。另一方面， 迭代器应该一直可以迭。 迭代器的 __iter__ 方法应该返回自身。 生成器函数实现相同功能， 但却符合 Python 习惯的方式是， 用生成器函数代替SentenceIterator 类。 1234567class Sentence(): # ... def __iter__(self): for word in self.words: yield word # 产出当前的word return # 可以不写，会触发生成器对象抛出 StopIteration 异常 生成器函数：只要 Python 函数的定义体中有 yield 关键字， 该函数就是生成器函数。 调用生成器函数时， 会返回一个生成器对象。 也就是说， 生成器函数是生成器工厂。 12345678910111213141516171819def gen_123(): yield 1 yield 2 yield 3 g = gen_123() # 通过生成器函数创建一个新的生成器print(g) # &lt;generator object gen_123 at ...&gt;for i in g: # 迭代生成器时，执行函数到定义体中的下一个yield语句暂停住，返回产出的值 print(i)def gen_AB(): print('start') yield 'A' print('continue') yield 'B' print('end')for i in gen_AB(): print('for:',i) 打印结果： 12345startfor: Acontinuefor: B # 执行了两次for循环中的语句end # 生成器前进到了生成器函数的末尾，但是没有产出返回值(yield关键字)，生成器对象抛出 StopIteration 异常。 for机制会捕获异常， 因此循环终止时没有报错。 惰性实现1234567class Sentence(): # ... def __iter__(self): # finditer函数构建一个迭代器,包含self.text中匹配RE_WORD的单词,产出MatchObject实例。 for match in RE_WORD.finditer(self.text): yield match.group() # match.group()方法从MatchObject实例中提取匹配正则表达式的具体文本。 生成器表达式生成器表达式可以理解为列表推导的惰性版本： 不会迫切地构建列表，而是返回一个生成器， 按需惰性生成元素。 如果说列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。 12def __iter__(self): return (match.group() for match in RE_WORD.finditer(self.text)) 这里不再是生成器函数了(没有yield)，而是使用生成器表达式构建生成器，然后将其返回。 生成器表达式是语法糖： 完全可以替换成生成器函数。 何时使用生成器表达式如果生成器表达式要分成多行写，就使用生成器函数，更灵活，提高可读性，可重用，且可以作为协程使用。 如果函数或构造函数只有一个参数，传入的生成器表达式不用自带一对括号了，只要有一对函数的括号就行了。 等差数列生成器12345678910111213def aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) # 转换类型 forever = end is None # 无穷 index = 0 while forever or result &lt; end: yield result index += 1 result = begin + step * index # 没有不断的累加step的值，为了降低处理浮点数时累积效应致错的风险i = aritprog_gen(0, 1.5)print(next(i))print(next(i))... # 可以无穷迭代 itertools模块生成等差数列： 123gen = itertools.count(0, 1.5)print(next(gen))print(next(gen)) itertools.count函数生成无穷等差数列，作用与上面的函数相同。 itertools.takewhile函数会生成一个使用另一个生成器的生成器， 在指定的条件计算结果为 False 时停止。 因此， 可以把这两个函数结合在一起使用。 12gen = itertools.takewhile(lambda n: n &lt; 5, itertools.count(0, 1.5)) # n是每次返回的产出值[print(g) for g in gen] 重写aritprog_gen函数： 123456def aritprog_gen(begin, step, end=None): result = type(begin + step)(begin) gen = itertools.count(begin, step) while end is not None: gen = itertools.takewhile(lambda n: n &lt; end, gen) return gen 标准库中的生成器函数用于“过滤”的生成器函数： 代码演示： 12345678910111213141516import itertoolsdef vowel(c): return c.lower() in 'aeiou's = 'Aardvark'print(list(filter(vowel, s))) # ['A', 'a', 'a']print(list(itertools.filterfalse(vowel, s))) # ['r', 'd', 'v', 'r', 'k']print(list(itertools.dropwhile(vowel, s))) # ['r', 'd', 'v', 'a', 'r', 'k']print(list(itertools.takewhile(vowel, s))) # ['A', 'a']print(list(itertools.compress(s, (1, 0, 1, 1, 0, 1)))) # ['A', 'r', 'd', 'a']print(list(itertools.islice(s, 4))) # ['A', 'a', 'r', 'd']print(list(itertools.islice(s, 4, 7))) # ['v', 'a', 'r']print(list(itertools.islice(s, 1, 7, 2))) # ['a', 'd', 'a'] takewhile和filter的区别： 12345def condition(e): return e &lt; 5i = itertools.takewhile(condition, itertools.count(0, 2)) # [0, 2, 4] 达成条件则停止迭代i2 = filter(condition, itertools.count(0, 1.5)) # 会卡死，应用到可迭代对象的所有元素，决定是否返回 用于”映射”的生成器函数： 代码演示： 12345678910111213141516171819202122import itertoolsimport operatorsample = [5, 4, 2, 7, 0, 3]print(list(itertools.accumulate(sample))) # [5, 9, 11, 18, 18, 21]，求和print(list(itertools.accumulate(sample, min))) # [5, 4, 2, 2, 0, 0]，求最小值print(list(itertools.accumulate(sample, max))) # [5, 5, 5, 7, 7, 7]，求最大值# [1, 2, 6, 24, 120]，计算1-5的阶乘print(list(itertools.accumulate(range(1, 6), operator.mul)))# [(1, 'a'), (2, 'b'), (3, 'c')]，从start(1)开始给每个元素编号print(list(enumerate('abc', 1)))# [0, 1, 4, 9, 16, 25] 映射求积，到短的迭代对象耗尽位置print(list(map(operator.mul, range(6), range(7))))# ['a', 'bb', 'ccc'] 对一对元素求积print(list(itertools.starmap(operator.mul, zip((1, 2, 3), ('a', 'b', 'c')))))# ['a', 'bb', 'ccc'] 同上print(list(itertools.starmap(operator.mul, enumerate('abc', 1))))# [5.0, 4.5, 3.6666666666666665, 4.5, 3.6, 3.5]，求阶段平均值print(list(itertools.starmap(lambda a, b: b/a, enumerate(itertools.accumulate(sample), 1)))) 用于“合并”的生成器函数： 123456789101112131415print(list(itertools.chain('ABC', range(2)))) # ['A', 'B', 'C', 0, 1]# [0, 'A', 1, 'B', 2, 'C']print(list(itertools.chain.from_iterable(enumerate('ABC'))))print(list(zip('ABC', range(5)))) # [('A', 0), ('B', 1), ('C', 2)]# [('A', 0), ('B', 1), ('C', 2), ('?', 3), ('?', 4)]print(list(itertools.zip_longest('ABC', range(5), fillvalue='?')))itertools.product生成器是计算笛卡尔积的惰性方式print(list(itertools.product('AB'))) # [('A',), ('B',)]# [('A', 0), ('A', 1), ('B', 0), ('B', 1)]print(list(itertools.product('AB', range(2))))# [('A', 'A'), ('A', 'B'), ('B', 'A'), ('B', 'B')]print(list(itertools.product('AB', repeat=2)))print(list(itertools.product('AB', range(2), repeat=2))) 把输入的各个元素扩展成多个输出元素的生成器函数： 1234567891011ct = itertools.count(5)ns = next(ct), next(ct), next(ct)print(ns) # (5, 6, 7)。不能使用ct构建列表，因为ct是无穷的print(list(itertools.islice(itertools.count(), 4))) # [0, 1, 2, 3]，指定大于4的数将会抛出异常cy = itertools.cycle('ABC')print(next(cy)) # Aprint(list(itertools.islice(cy, 5))) # ['B', 'C', 'A', 'B', 'C']rp = itertools.repeat(7, 3)print(next(rp), next(rp), next(rp)) # 7 7 7# [0.0, 1.5, 3.0, 4.5, 6.0]print(list(map(operator.mul, range(5), itertools.repeat(1.5)))) 扩展生成器中的“组合学”生成器函数： 123456# [('A', 'B'), ('A', 'C'), ('B', 'C')]print(list(itertools.combinations('ABC', 2)))# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]print(list(itertools.combinations_with_replacement('ABC', 2)))# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]print(list(itertools.permutations('ABC', 2))) 用于重新排列元素的生成器函数： 1234567891011121314151617print(list(itertools.groupby('AAABB')))# [('A', &lt;itertools._grouper object at ...&gt;), ('B', &lt;itertools._grouper object at ...&gt;)]for key, group in itertools.groupby('AAABB'): print(key, '-&gt;', list(group))# A -&gt; ['A', 'A', 'A']# B -&gt; ['B', 'B']animals = 'rat duck bat eagle shark bear'.split()animals.sort(key=len) # 为了使用groupby函数,输入要有序for length, group in itertools.groupby(reversed(animals), len): print(length, '-&gt;', list(group))# 5 -&gt; ['shark', 'eagle']# 4 -&gt; ['bear', 'duck']# 3 -&gt; ['bat', 'rat']g1, g2 = itertools.tee('ABC')print(next(g1)) # Aprint(list(g2)) # ['A', 'B', 'C'] yield from用于在生成器函数中方便的产出另一个生成器生成的值。 123456789101112def chain(*iterables): for it in iterables: for i in it: yield iprint(list(chain('ABC',range(3))))def chain2(*iterables): for it in iterables: yield from itprint(list(chain2('ABC',range(3)))) 可迭代的归约函数 这里的每个内置函数都可以用functools.reduce实现，内置是为了方便使用。此外，对all和any函数来说，有一项重要的优化措施是 reduce 函数做不到的： 这两个函数会短路。 1234567891011print(all([1, 2, 3])) # Trueprint(all([1, 0, 3])) # Falseprint(all([])) # Trueprint(any([1, 2, 3])) # Trueprint(any([1, 0, 3])) # Trueprint(any([])) # Falseg = (n for n in [0, 0.0, 7, 8])print(any(g)) # True，一旦确定结果就立即停止使用迭代器print(next(g)) # 8，剩余的元素 深入分析iter函数1234567def d6(): return randint(1, 6)d6_iter = iter(d6, 1) # 不断调用第一个参数（没有参数的可调用对象），产出各个值print(d6_iter) # &lt;callable_iterator object at ...&gt;for roll in d6_iter: print(roll) # 当可调用的对象返回这个值时，触发迭代器抛出StopIteration异常，而不产出(打印)哨符 上下文管理器和else块if之外的else块先做这个，再做那个。 12345for i in range(10): if i == 15: breakelse: print('else') # "如果中断了就不做了"。仅当for循环运行完毕时(即for循环没有被break语句中止)才运行else块。 while： 仅当while循环因为条件为假值而退出时（即while循环没有被break语句中止）才运行else块。 try： 仅当 try 块中没有异常抛出时才运行else块。官方文档还指出：“else 子句抛出的异常不会由前面的 except 子句处理。” EAFP风格： 上下文管理器和with块with 语句的目的是简化 try/finally 模式。 这种模式用于保证一段代码运行完毕后执行某项操作， 即便那段代码由于异常、 return 语句或sys.exit() 调用而中止， 也会执行指定的操作。 上下文管理器协议包含 __enter__ 和 __exit__ 两个方法。 with 语句开始运行时， 会在上下文管理器对象上调用 __enter__ 方法。 with 语句运行结束后， 会在上下文管理器对象上调用 __exit__ 方法， 以此扮演 finally 子句的角色。 上下文管理器举例： 123456789101112131415161718192021class LookingGlass(): def __enter__(self): import sys self.origin_write = sys.stdout.write sys.stdout.write = self.reverse_write # 猴子补丁 return 'JABBERWOCKY' # __enter__方法一般返回上下文管理器自己，也可返回别的对象 def reverse_write(self, text): self.origin_write(text[::-1]) def __exit__(self, exc_type, exc_value, traceback): """ exc_type：异常类（例如ZeroDivisionError） exc_value：异常实例。有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exc_value.args获取 """ import sys # 重复导入模块不会消耗很多资源，因为Python会缓存导入的模块 sys.stdout.write = self.origin_write if exc_type is ZeroDivisionError: print('Please DO NOT divide by zero') return True # 如果__exit__方法返回None，或者True之外的值，with块中的任何异常都会向上冒泡 1234567from mirror import LookingGlasswith LookingGlass() as g: print('Hallo') # ollaH，打印出的内容是反向的 print(g) # YKCOWREBBAJ，g就是print(g) # JABBERWOCKY，已经调用__exit__方法恢复打印方法 使用@contextmanagercontextlib.contextmanager 装饰器会把函数包装成实现 __enter__ 和 __exit__ 方法的类：yield 语句前面的所有代码在 with 块开始时（即解释器调用 __enter__ 方法时） 执行， yield 语句后面的代码在with 块结束时（即调用 __exit__ 方法时） 执行。 1234567891011121314151617181920212223import contextlib@contextlib.contextmanagerdef looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) # 在闭包中可以访问original_write sys.stdout = reverse_write yield 'JABBERWOCKY' sys.stdout.write = original_writefrom mirror import looking_glasswith looking_glass() as g: print('abc') # cba print(g) # YKCOWREBBAJprint('abc') # abcprint(g) # JABBERWOCKY 上述示例有一个严重的错误：如果在with块中抛出了异常，Python 解释器会将其捕获，然后在 looking_glass函数的yield表达式里再次抛出。但是，那里没有处理错误的代码，因此looking_glass函数会中止，永远无法恢复成原来的sys.stdout.write方法。修复代码如下： 1234567891011121314151617@contextlib.contextmanagerdef looking_glass(): import sys original_write = sys.stdout.write def reverse_write(text): original_write(text[::-1]) sys.stdout.write = reverse_write try: yield 'JABBERWOCKY' #要把yield语句放在try/finally语句中（或者放在with语句中），因为我们永远不知道上下文管理器的用户会在with块中做什么 except ZeroDivisionError: #假设的异常 msg = 'Please DO NOT divide by zero!' finally: sys.stdout.write = original_write if msg: print(msg) 协程用作协程的生成器的基本行为123456789def simple_coroutine(): print('-&gt;coroutine started') x = yield # 右边没有表达式，产出None print('-&gt;coroutine received:', x)c = simple_coroutine()print(c) # &lt;generator object simple_coroutine at ...&gt;print(next(c)) # -&gt;coroutine started Nonec.send('12') # -&gt;coroutine received: 12 抛出StopIteration 协程的四种状态，可以用inspect.getgeneratorstate(…)函数确定： ‘GEN_CREATED’，等待开始执行 ‘GEN_RUNNING’，解释器正在执行 ‘GEN_SUSPENDED’，在yield表达式处暂停 ‘GEN_CLOSED’，执行结束 仅当协程处于暂停时才能调用send方法，因此刚创建的协程必须先用next(coro)激活，也可用coro.send(None)，这一步成为“预激”（即让协程向前执行到第一个yield表达式）。 使用协程计算移动平均值1234567891011121314def averager(): total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/counta = averager()next(a)print(a.send(10))print(a.send(12)) 预激协程的装饰器自定义一个装饰器： 123456789from functools import wrapsdef coroutine(func): @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer 使用： 12345from coroutil import coroutine@coroutinedef averager(): ... 终止协程和异常处理1234567891011121314151617181920212223class DemoException(Exception): passdef demo_exc_handing(): print('coroutine started') try: while True: try: x = yield except DemoException: # 特别处理此异常 print('DemoException handled,Continuning...') else: # 如果没有异常，执行打印 print('coroutine received:&#123;!r&#125;'.format(x)) finally: # 未处理的其他异常，协程结束，执行清理等 print('coroutine ending')d = demo_exc_handing()next(d) # coroutine startedd.send('abc')d.send(2.00)d.throw(DemoException) # DemoException handled，Continuning...d.throw(ZeroDivisionError) # 先coroutine ending，后抛出ZeroDivisionError generator.throw(exc_type[, exc_value[, traceback]]) : 致使生成器在暂停的 yield 表达式处抛出指定的异常。 如果生成器处理了抛出的异常，代码会继续执行到下一个yield表达式，而产出的值会成为调用generator.throw方法得到的返回值。 如果生成器没有处理抛出的异常，协程会停止，即状态变成’GEN_CLOSED’，异常会向上冒泡，传到调用方的上下文中。 generator.close()： 致使生成器在暂停的yield表达式处抛出GeneratorExit异常。 如果生成器没有处理这个异常，或者抛出了StopIteration异常（通常是指运行到结尾），调用方不会报错。 如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。 生成器抛出的其他异常会向上冒泡， 传给调用方。 让协程返回值123456789101112131415161718192021222324from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): total = 0.0 count = 0 average = None while True: term = yield if term is None: # 为了返回值，协程必须停止，因此加一个条件 break total += term count += 1 average = total/count return Result(count, average)a = averager()next(a)print(a.send(10)) # None，没有产出值print(a.send(13))print(a.send(None)) # StopIteration: Result(count=2, average=11.5) 异常对象的 value 属性保存着返回的值。 注意，return表达式的值会偷偷传给调用方，赋值给StopIteration异常的一个属性。 这样做有点不合常理。 更合理的获取： 1234try: a.send(None)except StopIteration as e: print(e.value) # Result(count=2, average=11.5) 使用yield fromyield from x 表达式对 x 对象所做的第一件事是， 调用 iter(x)， 从中获取迭代器。 因此， x 可以是任何可迭代的对象。 yield from 的主要功能是打开双向通道， 把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值， 还可以直接传入异常， 而不用在位于中间的协程中添加大量处理异常的样板代码。 有了这个结构， 协程可以把职责委托给子生成器。 123456789101112def gen(): for c in 'AB': yield c for i in range(1, 3): yield idef gen_corountine(): yield from 'AB' yield from range(1, 3)print(list(gen()))print(list(gen_corountine())) 术语说明： 委派生成器：包含 yield from 表达式的生成器函数 子生成器：从 yield from 表达式中 部分获取的生成器 调用方：指代调用委派生成器的客户端代码。 即“客户端” 结构示意图： 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from collections import namedtupleResult = namedtuple('Result', 'count average')def averager(): """子生成器""" total = 0.0 count = 0 average = None while True: term = yield if term is None: # 子生成器的退出条件 break total += term count += 1 average = total/count return Result(count, average) # 结束时抛出StopIteration异常，把返回值赋到value属性上def grouper(result, key): """委派生成器""" while True: # 继续迭代，避免group实例执行迭代结束时抛出StopIteration异常 # grouper会在yield from表达式处暂停，发送的每个值都会经由yield from处理，通过管道传给averager实例，等待averager实例执行完毕。 # 抑制子生成器抛出的StopIteration异常，接收averager实例的返回值（从StopIteration异常的value属性中获取） result[key] = yield from averager()def main(data): results = &#123;&#125; for key, values in data.items(): group = grouper(results, key) next(group) # 预激委派生成器，使委派生成器自身在yield from处暂停，接着委派生成器预激子生成器执行到第一个yeild语句处 for value in values: # 传入的值最终到达averager函数中term = yield那一行，grouper并不知道传入的值是什么 group.send(value) # 重要！结束averager函数执行，将返回值付给grouper的result变量。 # 如果没有这一句，在下一次循环时，新创建的grouper实例将会覆盖到group变量上，前一个实例（以及它创建的尚未终止的averager子生成器实例）被垃圾回收程序回收 group.send(None) print(results)data = &#123; 'girls;kg': [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5], 'girls;m': [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg': [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3], 'boys;m': [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],&#125;if __name__ == '__main__': main(data) yield from链： 一个委派生成器使用yield from调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield表达式的简单生成器（或任何可迭代的对象）结束；任何yield from链条都必须由客户驱动，在最外层委派生成器上调用next(…)函数或.send(…)方法。可以隐式调用，例如使用for循环。 yield from 的意义yield from的特性： 子生成器产出的值都直接传给委派生成器的调用方（即客户端代码） 使用 send() 方法发给委派生成器的值都直接传给子生成器。 如果发送的值是 None， 那么会调用子生成器的 __next__() 方法。 如果发送的值不是 None， 那么会调用子生成器的 send() 方法。 如果调用的方法抛出 StopIteration 异常， 那么委派生成器恢复运行。 任何其他异常都会向上冒泡， 传给委派生成器。 生成器退出时， 生成器（或子生成器） 中的 return expr 表达式会触发 StopIteration(expr) 异常抛出。 yield from 表达式的值是子生成器终止时传给 StopIteration异常的第一个参数。 传入委派生成器的异常， 除了 GeneratorExit 之外都传给子生成器的 throw() 方法。 如果调用 throw() 方法时抛出StopIteration 异常， 委派生成器恢复运行。 StopIteration 之外的异常会向上冒泡， 传给委派生成器 如果把 GeneratorExit 异常传入委派生成器， 或者在委派生成器上调用 close() 方法， 那么在子生成器上调用 close() 方法， 如果它有的话。 如果调用 close() 方法导致异常抛出， 那么异常会向上冒泡， 传给委派生成器； 否则， 委派生成器抛出GeneratorExit 异常 yeidl from结构的伪代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546EXPR = 'AB'import sysdef yield_demo(): _i = iter(EXPR) # EXPR可以是任何可迭代对象 try: _y = next(_i) # 预激，保存第一次产出的结果 except StopIteration as e: _r = e.value # 最简单情况下的返回值（RESULT） else: while 1: # 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道 try: _s = yield _y # 产出上次子生成器的产出值，等待调用方发送值，保存在_s中 except GeneratorExit as _e: # 用于关闭子生成器和委派生成器自己 try: _m = _i.close except AttributeError: # 子生成器可能没有close方法（比如字符串），静默失败 pass else: _m() raise _e except BaseException as _e: # 处理调用方通过.throw(...)方法传入的异常 _x = sys.exc_info() try: _m = _i.throw() except AttributeError: # 子生成器可能没有throw方法，委派生成器抛出异常 raise _e else: # 有throw方法，调用 try: # 子生成器可能会处理掉出入的异常（然后继续循环），也可能抛出StopIteration异常，也可能抛出其他类型的异常 _y = _m(*_x) except StopIteration as _e: # 处理StopIteration异常，获取返回值。如果是其他异常直接冒泡 _r = _e.value break else: try: if _s is None: _y = next(_i) else: _y = _i.send(_s) except StopIteration as _e: _r = _e.value break return _r 离散事件仿真离散事件仿真（DES），定义： 出租车队运营仿真，代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from collections import namedtuplefrom queue import PriorityQueueEvent = namedtuple('Event', 'time proc action')# time 是事件发生的仿真时间# proc 是出租车进程实例的编号# action 描述活动的字符串def taxi_process(ident, trips, start_time=0): """ 每辆出租车调用一次taxi_process函数，创建一个生成器对象，表示各辆出租车的运营过程。 ident是出租车的编号，trips是出租车回家之前的行程数量，start_time是出租车离开车库的时间。 每次改变状态时传入一个time，把控制权让给仿真器，每次结束时返回一个Event对象 """ time = yield Event(start_time, ident, 'leave garage') for i in range(trips): # 每次行程运行一次 time = yield Event(time, ident, 'pick up passenger') time = yield Event(time, ident, 'drop off passenger') yield Event(time, ident, 'going home') # 一个出租车进程结束class Simulator: def __init__(self, procs_map): self.events = PriorityQueue() # 优先队列，可以按照指定优先顺序（item[0]，即time）取值 self.procs = dict(procs_map) # 副本 def run(self, end_time): # 预激、排定各辆出租车的第一个事件 for _, proc in sorted(self.procs.items()): first_event = next(proc) self.events.put(first_event) sim_time = 0 # sim_time（仿真钟）归零 while sim_time &lt; end_time: if self.events.empty(): print('*** end of events ***') break current_event = self.events.get() # 获取优先队列中time属性最小的Event对象 # 每次循环时仿真钟不会以固定的量推进，是根据各个事件持续的时间推进 sim_time, proc_id, previous_action = current_event print('taxi', proc_id, proc_id*' ', current_event) active_proc = self.procs[proc_id] next_time = sim_time + 2 # compute_duration(previous_action) try: next_event = active_proc.send(next_time) except StopIteration: del self.procs[proc_id] else: self.events.put(next_event) else: # 循环由于仿真事件到而退出，显示待完成的事件数量 msg = '*** end of simulation time: &#123;&#125; events pending ***' print(msg.format(self.events.qsize()))taxis = &#123;i: taxi_process(i, (i+1)*2, i*5) for i in range(3)&#125;sim = Simulator(taxis)sim.run(40) 事件： 驱动型框架（如 Tornado 和 asyncio） 的运作方式： 在单个线程中使用一个主循环驱动协程执行并发活动。 使用协程做面向事件编程时， 协程会不断把控制权让步给主循环， 激活并向前运行其他协程， 从而执行各个并发活动。 使用期物处理并发网络下载的三种风格依序下载的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osimport timeimport sysimport requests # 不在标准库，一个空行隔开POP20_CC = ('CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR').split()BASE_URL = 'http://flupy.org/data/flags'DEST_DIR = 'downloads/'def save_flag(img, filename): path = os.path.join(DEST_DIR, filename) if not os.path.exists(DEST_DIR): os.makedirs(DEST_DIR) with open(path, 'wb') as fp: fp.write(img)def get_flag(cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = requests.get(url) # 阻塞性I/O操作 return resp.contentdef show(text): print(text, end=' ') sys.stdout.flush() # 刷新sys.stdout，这样能在一行消息中看到进度。在Python在正常情况下，遇到换行才会刷新stdout缓冲def download_many(cc_list): for cc in sorted(cc_list): image = get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return len(cc_list)def main(download_many): t0 = time.time() count = download_many(POP20_CC) elapsed = time.time()-t0 msg = '\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s' print(msg.format(count, elapsed))if __name__ == '__main__': main(download_many) 使用concurrent.futures模块下载123456789101112131415161718192021from concurrent import futuresfrom flags import save_flag, get_flag, show, mainMAX_WORKERS = 20def download_one(cc): image = get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return ccdef download_many(cc_list): wokers = min(MAX_WORKERS, len(cc_list)) with futures.ThreadPoolExecutor(wokers) as executor: # download_one函数会在多个线程中并发调用；map方法返回一个生成器，因此可以迭代，获取各个函数返回的值 res = executor.map(download_one, sorted(cc_list)) return len(list(res))if __name__ == '__main__': main(download_many) 期物在哪里标准库中有两个名为 Future 的类： concurrent.futures.Future 和 asyncio.Future。 这两个类的作用相同： 两个 Future 类的实例都表示可能已经完成或者尚未完成的延迟计算。 这与 Twisted 引擎中的 Deferred 类、 Tornado 框架中的Future 类， 以及多个 JavaScript 库中的 Promise 对象类似。 使用as_completed函数改写download_many函数，来理解期物： 1234567891011121314151617181920212223242526272829303132333435def download_many(cc_list): cc_list = cc_list[:5] with futures.ThreadPoolExecutor(3) as executor: to_do = [] for cc in cc_list: # submit方法排定可调用对象的执行时间，返回一个期物，表示这个待执行（或正执行）的操作 future = executor.submit(download_one, cc) to_do.append(future) msg = 'Scheduled for &#123;&#125;:&#123;&#125;' print(msg.format(cc, future)) results = [] # as_completed 函数在期物运行结束后产出期物 for future in futures.as_completed(to_do): res = future.result() # 获取该期物（已结束，不会阻塞）的结果 msg = '&#123;&#125; result:&#123;!r&#125;' print(msg.format(future, res)) results.append(res) return len(results)# 打印：# Scheduled for CN:&lt;Future at 0x232955c9860 state=running&gt;# Scheduled for IN:&lt;Future at 0x232955c9f28 state=running&gt;# Scheduled for US:&lt;Future at 0x232955d9550 state=running&gt; 有三个工作线程，前三个期物的状态是running# Scheduled for ID:&lt;Future at 0x232955d9a90 state=pending&gt;# Scheduled for BR:&lt;Future at 0x232955d9b38 state=pending&gt; 后两个是pending，等待有线程可用# IN &lt;Future at 0x232955c9f28 state=finished returned str&gt; result:'IN' 第一个IN是download_one的子线程打印的，第二个'IN'是主线程获得返回后打印的# CN &lt;Future at 0x232955c9860 state=finished returned str&gt; result:'CN'# ID &lt;Future at 0x232955d9a90 state=finished returned str&gt; result:'ID'# BR US &lt;Future at 0x232955d9b38 state=finished returned str&gt; result:'BR' 子线程都先把download_one的show执行了，然后返回结果。主线程遍历打印了结果# &lt;Future at 0x232955d9550 state=finished returned str&gt; result:'US'# 5 flags downloaded in 0.88s 严格来说， 我们目前测试的并发脚本都不能并行下载。 使用concurrent.futures 库实现的两个示例受 GIL（Global InterpreterLock， 全局解释器锁） 的限制， 而 flags_asyncio.py 脚本在单个线程中运行。（GIL几乎对 I/O 密集型处理无害）。 阻塞性I/O和GILPython 线程受 GIL的限制， 任何时候都只允许运行一个线程，但 flags_threadpool.py 脚本的下载速度仍比 flags.py 脚本快 5倍。flags_asyncio.py 脚本和 flags.py 脚本都在单个线程中运行， 前者仍比后者快 5 倍。 Python 标准库中的所有阻塞型 I/O 函数都会释放 GIL， 允许其他线程运行。 time.sleep() 函数也会释放 GIL。 因此， 尽管有GIL， Python 线程还是能在 I/O 密集型应用中发挥作用。 CPython 解释器本身就不是线程安全的， 因此有全局解释器锁（GIL） ，一次只允许使用一个线程执行 Python 字节码。 因此， 一个 Python 进程通常不能同时使用多个 CPU 核心。这是 CPython 解释器的局限， 与 Python 语言本身无关。 Jython 和 IronPython 没有这种限制。不过， 目前最快的 Python 解释器 PyPy 也有 GIL。 使用concurrent.futures模块启动进程在CPU密集型作业中使用concurrent.futures模块轻松绕开GIL，ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的Executor 接口， 因此使用ProcessPoolExecutor能特别轻松地把基于线程的方案转成基于进程的方案。而在下载国旗的示例或其他I/O密集型作业使用ProcessPoolExecutor类得不到任何好处。 实验Executor.map方法123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import sleep, strftimefrom concurrent import futuresdef display(*args): print(strftime('[%H:%M:%S]'), end=' ') print(*args)def loiter(n): msg = '&#123;&#125;loiter(&#123;&#125;):start' display(msg.format('\t'*n, n, n)) sleep(n) msg = '&#123;&#125;loiter(&#123;&#125;):done' display(msg.format('\t'*n, n)) return n*10def main(): display('Starting') with futures.ThreadPoolExecutor(3) as exec: results = exec.map(loiter, range(5)) display('results', results) display('Waiting for individual results:') for i, result in enumerate(results): display('&#123;&#125;result &#123;&#125;:&#123;&#125;'.format('\t'*i, i, result))main()# 打印：# [18:55:54] Starting# [18:55:54] loiter(0):doint nothing for 0s# [18:55:54] loiter(0):done #sleep 函数总会释放 GIL，这一句可能在loiter(1)之前，也可能在后# [18:55:54] loiter(1):doint nothing for 1s# [18:55:54] loiter(2):doint nothing for 2s #因为线程池中有三个职程，可以并发运行三个函数# [18:55:54] results &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at ...&gt; #目前不会阻塞# [18:55:54] Waiting for individual results:# [18:55:54] result 0:0# [18:55:54] loiter(3):doint nothing for 3s #第一个线程可以启动第四个线程，运行loiter(3)。# [18:55:55] loiter(1):done# [18:55:55] loiter(4):doint nothing for 4s# [18:55:55] result 1:10# [18:55:56] loiter(2):done# [18:55:56] result 2:20# [18:55:57] loiter(3):done# [18:55:57] result 3:30# [18:55:59] loiter(4):done# [18:55:59] result 4:40 map的特性：这个函数返回结果的顺序与调用开始的顺序一致，如果后调用的函数早完成则会处于阻塞状态。只能处理参数不同的同一个可调用对象。 executor.submit和futures.as_completed组合更灵活，不管提交顺序，只要有结果就获取。 futures.as_completed能处理的期物集合可以来自多个Executor实例。 线程和多进程的替代方案如果futures.ThreadPoolExecutor 类对某个作业来说不够灵活， 可能要使用 threading 模块中的组件（如 Thread、 Lock、 Semaphore 等）自行制定方案， 比如说使用 queue 模块创建线程安全的队列， 在线程之间传递数据。 futures.ThreadPoolExecutor 类已经封装了这些组件。 对 CPU 密集型工作来说， 要启动多个进程， 规避 GIL。 创建多个进程最简单的方式是， 使用 futures.ProcessPoolExecutor 类。 不过和前面一样， 如果使用场景较复杂， 需要更高级的工具。 multiprocessing 模块的 API 与threading 模块相仿， 不过作业交给多个进程处理。 使用asyncio包处理并发线程与协程的对比spinner_thread.py： 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingimport itertoolsimport timeimport sysclass Signal(): go = True # 从外部控制线程关闭def spin(msg, signal): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char+' '+msg write(status) flush() write('\x08'*len(status)) # 使用退格符（\x08）把光标移回来 time.sleep(.1) if not signal.go: break write(' '*len(status)+'\x08'*len(status))def slow_function(): time.sleep(3) # 假装I/O。调用sleep函数会阻塞主线程，一定要这么做，以便释放GIL，创建子线程 return 42def supervisor(): signal = Signal() spinner = threading.Thread(target=spin, args=('thinking!', signal)) print('spinner object:', spinner) spinner.start() result = slow_function() signal.go = False spinner.join() return resultdef main(): result = supervisor() print('Answer:', result)if __name__ == '__main__': main() spinner_asyncio.py： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import asyncioimport itertoolsimport sysimport time@asyncio.coroutine # 强烈建议打算交给asyncio处理的协程要使用@asyncio.coroutine装饰def spin(msg): write, flush = sys.stdout.write, sys.stdout.flush for char in itertools.cycle('|/-\\'): status = char + ' '+msg write(status) flush() write('\x08'*len(status)) try: yield from asyncio.sleep(.1) # 这样的休眠不会阻塞事件循环 # time.sleep(.1) # 将会无限循环执行，调用方也不能中止子协程的执行 except asyncio.CancelledError: break write(' '*len(status)+'\x08'*len(status))@asyncio.coroutinedef slow_function(): yield from asyncio.sleep(3) # 表达式把控制权交给主事件循环（loop），在休眠结束后恢复这个协程。 return 42@asyncio.coroutinedef supervisor(): # 排定spin协程的运行时间（顺序），使用一个Task对象包装spin协程，并立即返回 spinner = asyncio.ensure_future(spin('thinking!')) # spinner object: &lt;Task pending coro=&lt;spin() running at .\index.py:7&gt;&gt; print('spinner object:', spinner) result = yield from slow_function() # 主循环在此处等待3秒，先去处理其他排定的协程 spinner.cancel() return resultdef main(): loop = asyncio.get_event_loop() # 获取事件循环的引用 result = loop.run_until_complete(supervisor()) # 驱动supervisor协程，让它运行完毕；这个协程的返回值是这次调用的返回值。 loop.close() print('Answer:', result)if __name__ == '__main__': main() 以上两种supervisor实现之间的主要区别： asyncio.Task对象差不多与threading.Thread对象等效。 Task对象用于驱动协程，Thread对象用于调用可调用对象。 Task对象不由自己动手实例化，而是通过把协程传给asyncio.ensure_future(..)函数或loop.create_task(…)方法获取。 获取的Task对象已经排定了运行时间。Thread实例则必须调用start方法。 没有API能从外部终止线程。可以使用Task.cancel()，在协程内部抛出CancelledError异常，协程可以在暂停的yield处捕获这个异常，处理终止请求。 supervisor协程必须在main函数中由loop.run_until_complete方法执行。 协程和线程的同步区别： 对协程来说， 无需保留锁， 在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻只有一个协程运行。 想交出控制权时， 可以使用 yield 或 yield from 把控制权交还调度程序。 asyncio.Future和concurrent.futures.Future区别期物只是调度执行某物的结果。 在asyncio 包中，BaseEventLoop.create_task(…)方法接收一个协程， 排定它的运行时间，然后返回一个asyncio.Task实例——也是asyncio.Future类的实例，因为Task是Future的子类，用于包装协程。这与调用Executor.submit(…)方法创建concurrent.futures.Future实例是一个道理。 与concurrent.futures.Future类似，asyncio.Future类也提供了.done()、.add_done_callback(…)和.result() 等方法。 因为asyncio.Future类的目的是与yield from一起使用，所以通常不需要使用以下方法： 无需调用my_future.add_done_callback(…)，因为可以直接把想在期物运行结束后执行的操作放在协程中 yield from my_future 表达式的后面。 这是协程的一大优势： 协程是可以暂停和恢复的函数。 无需调用my_future.result()，因为 yield from 从期物中产出的值就是结果（例如，result = yield from my_future）。 使用asyncio和aiohttp包下载从Python3.4起，asyncio包只支持TCP和UDP。如果想使用HTTP，可以使用aiohttp包。 123456789101112131415161718192021222324252627282930import asyncioimport aiohttpfrom flags import BASE_URL, save_flag, show, main@asyncio.coroutinedef get_flag(cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(BASE_URL, cc=cc.lower()) resp = yield from aiohttp.ClientSession().get(url) # 非阻塞I/O操作 image = yield from resp.read() return image@asyncio.coroutinedef download_one(cc): image = yield from get_flag(cc) show(cc) save_flag(image, cc.lower()+'.gif') return ccdef download_many(cc_list): loop = asyncio.get_event_loop() to_do = [download_one(cc) for cc in sorted(cc_list)] wait_coro = asyncio.wait(to_do) # wait 是一个协程，等传给它的所有协程运行完毕后结束 res, _ = loop.run_until_complete(wait_coro) loop.close() return len(res)if __name__ == '__main__': main(download_many) asyncio.wait 会分别把各个协程包装进一个 Task 对象。 最终的结果是， wait 处理的所有对象都通过某种方式变成 Future 类的实例。 wait 是协程函数， 因此返回的是一个协程或生成器对象。 在asyncio包的API中使用yield from时： 避免阻塞型调用有两种方法能避免阻塞型调用中止整个应用程序的进程： 在单独的线程中运行各个阻塞型操作 把每个阻塞型操作转换成非阻塞的异步调用使用 多个线程是可以的， 但是各个操作系统线程（Python 使用的是这种线程） 消耗的内存达兆字节（具体的量取决于操作系统种类） 。 如果要处理几千个连接， 而每个连接都使用一个线程的话， 我们负担不起。 asyncio 的基础设施获得第一个响应后， 事件循环把响应发给等待结果的 get_flag 协程。 得到响应后， getflag 向前执行到下一个 yieldfrom 表达式处， 调用 resp.read() 方法， 然后把控制权还给主循环。其他响应会陆续返回（因为请求几乎同时发出） 。 所有 get flag 协程都获得结果后， 委派生成器 download_one 恢复， 保存图像文件。 改进asyncio下载脚本把一个协程列表传给 asyncio.wait 函数， 经由loop.run_until_complete 方法驱动， 全部协程运行完毕后， 这个函数会返回所有下载结果。 可是， 为了更新进度条， 各个协程运行结束后就要立即获取结果。 为了集成进度条， 我们使用 as_completed 生成器函数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import asyncioimport collectionsimport aiohttpfrom aiohttp import webimport tqdmfrom flags2_common import main, HTTPStatus, Result, save_flagDEFAULT_CONCUR_REQ = 5MAX_CONCUR_REQ = 1000class FetchError(Exception): def __init__(self, country_code): self.country_code = country_code@asyncio.coroutinedef get_flag(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) resp = yield from aiohttp.ClientSession().get(url) if resp.status == 200: image = yield from resp.read() return image elif resp.status == 404: raise web.HTTPNotFound() else: raise aiohttp.HttpProcessingError( code=resp.status, message=resp.reason, headers=resp.headers)@asyncio.coroutine# semaphore 参数是 asyncio.Semaphore 类的实例。 Semaphore 类是同步装置， 用于限制并发请求数量def download_one(cc, base_url, semaphore, verbose): try: # 使用 with 表达式或手动在 semaphore 对象上调用 release 方法(递增)或 acquire 方法(递减)来操作内部计数器 with (yield from semaphore): # 退出这个 with 语句后， semaphore 计数器的值会递减， 解除阻塞可能在等待同一个 semaphore 对象的其他协程实例 image = yield from get_flag(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc # raise X from Y 句法链接原来的异常 else: # 1, save_flag(image, cc.lower() + '.gif') # 直接调用 save_flag 访问本地文件系统会阻塞客户代码与 asyncio 事件循环共用的唯一线程 # 2, asyncio 的事件循环在背后维护着一个 ThreadPoolExecutor 对象，我们可以调用 run_in_executor 方法， 把可调用的对象发给它执行 # 第一个参数是 Executor 实例； 如果设为None， 使用事件循环的默认 ThreadPoolExecutor 实例 loop = asyncio.get_event_loop() loop.run_in_executur(None, save_flag, image, cc.lower()+'.gif') status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc)@asyncio.coroutinedef downloader_coro(cc_list, base_url, verbose, concur_req): # 不直接调用，使用事件循环驱动 counter = collections.Counter() # 最多允许激活 concur_req 个使用这个计数器的协程，锁 semaphore = asyncio.Semaphore(concur_req) to_do = [download_one(cc, base_url, semaphore, verbose) for cc in sorted(cc_list)] # 循环调用 download_one 协程， 创建一个协程对象列表。 to_do_iter = asyncio.as_completed(to_do) # 获取一个迭代器， 这个迭代器会在期物运行结束后返回期物 if not verbose: to_do_iter = tqdm.tqdm(to_do_iter, total=len( cc_list)) # 传给 tqdm 函数， 显示进度 for future in to_do_iter: # 迭代运行结束并返回结果的期物 try: res = yield from future # 获取该期物的结果（此时已结束，不会阻塞）的最简单的方式，而不是使用future.result() except FetchError as exc: country_code = exc.country_code try: # 尝试从原来的异常（__cause__） 中获取错误消息 error_msg = exc.__cause__.args[0] except IndexError: error_msg = exc.__cause__.__class__.__name__ if verbose and error_msg: msg = '*** Error for &#123;&#125;: &#123;&#125;' print(msg.format(country_code, error_msg)) status = HTTPStatus.error else: status = res.status counter[status] += 1 return counterdef download_many(cc_list, base_url, verbose, concur_req): loop = asyncio.get_event_loop() coro = downloader_coro(cc_list, base_url, verbose, concur_req) # download_many 函数只是实例化 downloader_coro 协程， 然后通过 run_until_complete 方法把它传给事件循环。 counts = loop.run_until_complete(coro) loop.close() return countsif __name__ == '__main__': main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ) 从回调到期物和协程Python中的回调地狱：链式回调 123456789101112def stage1(response1): request2 = step1(response1) api_call2(request2, stage2)def stage2(response2): request3 = step2(response2) api_call3(request3, stage3)def stage3(response3): step3(response3)api_call1(request1, stage1) 使用协程和yield from 结构做异步编程，无需回调： 12345678910111213@asyncio.coroutinedef three_stages(request1): response1 = yield from api_call1(request1) # 第一步 request2 = step1(response1) response2 = yield from api_call2(request2) # 第二步 request3 = step2(response2) response3 = yield from api_call3(request3) # 第三步 step3(response3)loop.create_task(three_stages(request1)) # 必须显式调度执行 使用yield from 异步编程，每次下载发起多次请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@asyncio.coroutinedef http_get(url): resp = yield from aiohttp.ClientSession().get(url) if resp.status == 200: ctype = resp.headers.get('Content-Type', '').lower() if 'json' in ctype or url.endswith('json'): data = yield from resp.json() # 如果内容类型包含'json'，解析为一个字典 else: data = yield from resp.read() # 读取原始字节 return data elif resp.status == 404: raise web.HTTPNotFound() else: raise aiohttp.HttpProcessingError( code=resp.status, message=resp.reason, headers=resp.headers)@asyncio.coroutinedef get_contry(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/metadata.json'.format(base_url, cc=cc.lower()) metadata = yield from http_get(url) return metadata['country'] # 获取字典中的值@asyncio.coroutinedef get_flag(base_url, cc): url = '&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'.format(base_url, cc=cc.lower()) return (yield from http_get(url)) # 这里必须在外层加上括号@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose): try: with (yield from semaphore): image = yield from get_flag(base_url, cc) with (yield from semaphore): country = yield from get_contry(base_url, cc) except web.HTTPNotFound: status = HTTPStatus.not_found msg = 'not found' except Exception as exc: raise FetchError(cc) from exc # raise X from Y 句法链接原来的异常 else: country = country.replace(' ', '_') filename = '&#123;&#125;-&#123;&#125;.gif'.format(country, cc) loop = asyncio.get_event_loop() loop.run_in_executur(None, save_flag, image, filename) status = HTTPStatus.ok msg = 'OK' if verbose and msg: print(cc, msg) return Result(status, cc) 使用asyncio包编写服务器使用asyncio包编写TCP服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import sysimport asynciofrom charfinder import UnicodeNameIndexCRLF = b'\r\n'PROMPT = b'?&gt; '# 实例化 UnicodeNameIndex 类时， 它会使用 charfinder_index.pickle文件（如果没有则构建）index = UnicodeNameIndex()@asyncio.coroutine# 这个协程要传给start_server，接收的两个参数是，asyncio.StreamReader和asyncio.StreamWriterdef handle_queries(reader, writer): while True: # 循环处理会话， 直到从客户端收到控制字符 # 发送提示符，StreamWriter.write 方法不是协程，只是普通的函数，不能使用yield from writer.write(PROMPT) yield from writer.drain() # 刷新 writer 缓冲，因为它是协程，必须使用 yield from data = yield from reader.readline() # 协程，返回bytes对象 try: query = data.decode().strip() except UnicodeDecodeError: query = '\x00' # Telnet 客户端发送控制字符时，可能会抛出 UnicodeDecodeError异常；简单起见，假装发送的是空字符。 client = writer.get_extra_info('peername') # 返回与套接字连接的远程地址 print('Received from &#123;&#125;:&#123;!r&#125;!'.format(client, query)) if query: if ord(query[:1]) &lt; 32: break # 收到控制字符或者空字符， 退出循环 # 产出包含 Unicode 码位、真正的字符和字符名称的字符串 lines = list(index.find_description_strs(query)) if lines: # 把 lines 转换成 bytes 对象，并在每一行末尾添加回车符和换行符 # writer.writelines(line.encode()+CRLF for line in lines) writer.writelines(line.encode('utf8')+CRLF for line in '卧室的') writer.write(index.status(query, len(lines)).encode()+CRLF) yield from writer.drain() # 刷新输出缓冲 print('Sent &#123;&#125; results'.format(len(lines))) print('Close the client socket') writer.close() # 关闭StreamWriter流def main(address='127.0.0.1', port=2323): port = int(port) loop = asyncio.get_event_loop() # asyncio.start_server 协程运行结束后， 返回的协程对象返回一个 asyncio.Server 实例， 即一个 TCP 套接字服务器 server_coro = asyncio.start_server( handle_queries, address, port, loop=loop) # 驱动 server_coro 协程， 启动服务器（server） server = loop.run_until_complete(server_coro) host = server.sockets[0].getsockname() # 获取这个服务器的第一个套接字的地址和端口 print('Serving on &#123;&#125;. Hit CTRL-C to stop.'.format(host)) try: loop.run_forever() # main 函数在这里阻塞，直到在服务器的控制台中按CTRL-C 键才会关闭 except KeyboardInterrupt: # 按CTRL-C pass print('Server shutting down.') server.close() # server.wait_closed() 方法返回一个期物，调用loop.run_until_complete运行期物 loop.run_until_complete(server.wait_closed()) loop.close()if __name__ == '__main__': # 处理可选的命令行参数的简便方式：展开 sys.argv[1:]，传给main函数 main(*sys.argv[1:]) handle_queries 协程的名称是复数， 因为它启动交互式会话后能处理各个客户端发来的多次请求。代码中所有的 I/O 操作都使用 bytes 格式。 因此， 我们要解码从网络中收到的字符串， 还要编码发出的字符串。Python 3 默认使用的编码是 UTF-8， 这里就隐式使用了这个编码。run_until_complete 方法的参数是一个协程（start_server方法返回的结果）或一个 Future 对象（server.wait_closed 方法返回的结果）,如果传给 run_until_complete 方法的参数是协程， 会把协程包装在 Task 对象中。调用 loop.run_forever() 时阻塞。控制权流动到事件循环中， 而且一直待在那里。不过偶尔会回到 handle_queries 协程， 这个协程需要等待网络发送或接收数据时， 控制权又交还事件循环。在事件循环运行期间， 只要有新客户端连接服务器就会启动一个handle_queries 协程实例。 使用aiohttp包编写Web服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import sysimport asynciofrom aiohttp import webimport aiohttpfrom charfinder import UnicodeNameIndexTEMPLATE_NAME = 'http_charfinder.html'SAMPLE_WORDS = ('bismillah chess cat circled Malayalam digit' ' Roman face Ethiopic black mark symbol dot' ' operator Braille hexagram').split()ROW_TPL = '&lt;tr&gt;&lt;td&gt;&#123;code_str&#125;&lt;/td&gt;&lt;th&gt;&#123;char&#125;&lt;/th&gt;&lt;td&gt;&#123;name&#125;&lt;/td&gt;&lt;/tr&gt;'LINK_TPL = '&lt;a href="/?query=&#123;0&#125;" title="find &amp;quot;&#123;0&#125;&amp;quot;"&gt;&#123;0&#125;&lt;/a&gt;'LINKS_HTML = ', '.join(LINK_TPL.format(word) for word in sorted(SAMPLE_WORDS, key=str.upper))index = UnicodeNameIndex()template = ''with open(TEMPLATE_NAME) as tpl: template = tpl.read()template = template.replace('&#123;links&#125;', LINKS_HTML)def home(request): # 每次请求执行一遍 query = request.query.get('query').strip() print('Query:&#123;!r&#125;'.format(query)) if query: descriptions = list(index.find_descriptions(query)) res = '\n'.join(ROW_TPL.format(**descr._asdict()) for descr in descriptions) msg = index.status(query, len(descriptions)) else: descriptions = [] res = '' msg = 'Enter words describing characters' html = template.format(query=query, result=res, message=msg) print('Sending &#123;&#125; results'.format(len(descriptions))) return web.Response(content_type='text/html', charset='utf-8', text=html)@asyncio.coroutinedef init(loop, address, port): # init 协程产出一个服务器， 交给事件循环驱动 app = web.Application(loop=loop) app.router.add_route('GET', '/', home) # 返回一个 aiohttp.web.RequestHandler实例，在 app 对象上设置路由处理 HTTP 请求 handler = app.make_handler() # 创建服务器， 以 handler 为协议处理程序， 并把服务器绑定在指定的地址和端口上 server = yield from loop.create_server(handler, address, port) return server.sockets[0].getsockname()def main(address='127.0.0.1', port=8111): port = int(port) loop = asyncio.get_event_loop() host = loop.run_until_complete( init(loop, address, port)) # 执行init方法，启动服务器，获取服务器的地址和端口 print('Serving on &#123;&#125;. Hit CTRL-C to stop.'.format(host)) try: loop.run_forever() # 控制权在事件循环手上时， main 函数会在这里阻塞 except KeyboardInterrupt: pass print('Server shutting down.') loop.close()if __name__ == '__main__': main(*sys.argv[1:]) 只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方法： yield from 传给 asyncio 包中某个参数为协程或期物的函数，例如 run_until_complete。 动态属性和特性使用动态属性转换数据使用动态属性访问JSON类数据下载和加载，osconfeed.py：1234567891011121314151617from urllib.request import urlopenimport warningsimport osimport jsonURL = 'http://www.oreilly.com/pub/sc/osconfeed'JSON = 'data/osconfeed.json'def load(): if not os.path.exists(JSON): msg = 'downloading &#123;&#125; to &#123;&#125;'.format(URL, JSON) warnings.warn(msg) with urlopen(URL) as remote, open(JSON, 'wb') as local: # 同时进行下载和保存 local.write(remote.read()) with open(JSON, encoding='utf8') as fp: return json.load(fp) 动态访问属性：12345678910111213141516171819202122232425262728293031from collections import abcimport keywordclass FrozenJSON(): """一个只读接口，使用属性表示法访问JSON类对象 """ def __init__(self, mapping): self.__data = &#123;&#125; for key, value in mapping.items(): if keyword.iskeyword(key): # 判断键是否为Python关键词，特殊处理 key += '_' self.__data[key] = value def __getattr__(self, name): if hasattr(self.__data, name): # 如果 name 是实例属性 __data 的属性，返回那个属性，如 keys return getattr(self.__data, name) else: # 否则从 self.__data 中获取 name 键对应的元素， 返回调用FrozenJSON.build() 方法得到的结果。 return FrozenJSON.build(self.__data[name]) @classmethod def build(cls, obj): # 备选构造函数 if isinstance(obj, abc.Mapping): return cls(obj) elif isinstance(obj, abc.MutableSequence): return [cls.build(item) for item in obj] else: return obj 动态访问： 12345678910from osconfeed import loadfrom fronzen_json import FrozenJSONraw_feed = load()print(raw_feed['Schedule']['events'][40]['name'])feed = FrozenJSON(raw_feed)print(feed.Schedule.events[40].name) #动态访问属性 使用new方法灵活创建对象__new__： 这是个类方法（使用特殊方式处理， 因此不必使用 @classmethod 装饰器） ， 必须返回一个实例（自身类或其他类的实例，返回其他类的实例解释器不会调用 __init__ 方法）。 返回的实例会作为第一个参数（即 self） 传给 __init__ 方法。 所以 __init__ 方法其实是“初始化方法”。 真正的构造方法是 __new__。我们几乎不需要自己编写 __new__ 方法， 因为从 object 类继承的实现已经足够了。 Python构件对象的过程的伪代码： 12345678910# 构建对象的伪代码def object_maker(the_class, some_arg): new_object = the_class.__new__(some_arg) if isinstance(new_object, the_class): the_class.__init__(new_object, some_arg) return new_object# 下述两个语句的作用基本等效x = Foo('bar')x = object_maker(Foo, 'bar') 使用 __new__ 方法取代build方法，构建可能是也可能不是FrozenJSON实例的新对象： 123456789101112131415161718192021def __init__(self, mapping): #__new__构建的“原始”对象，在__init__里进行初始化 self.__data = &#123;&#125; for key, value in mapping.items(): if keyword.iskeyword(key): key += '_' self.__data[key] = valuedef __getattr__(self, name): if hasattr(self.__data, name): return getattr(self.__data, name) else: return FrozenJSON(self.__data[name])def __new__(cls, arg): # cls是类本身 if isinstance(arg, abc.Mapping): # 默认的行为是委托给超类（这里是object）的 __new__ 方法来构建“原始”对象。背后真正的构建操作由解释器调用 C 语言实现的 object.__new__ 方法执行 return super().__new__(cls) elif isinstance(arg, abc.MutableSequence): return [cls(item) for item in arg] else: return arg shelve模块略 使用特性验证属性12345678910111213141516171819class LineItem(): def __init__(self, desc, weight, price): self.desc = desc self.weight = weight # 这里赋值已经使用了特性的设值方法 self.price = price def subtotal(self): return self.weight*self.price @property def weight(self): # 读值方法 return self.__weight @weight.setter # 这个装饰器把读值方法和设值方法绑定在一起 def weight(self, value): # 设值方法 if value &gt; 0: self.__weight = value else: raise ValueError('value must be &gt; 0') 特性全解析特性会覆盖实例属性12345678910111213141516171819202122232425262728293031class Class(): data = 'class data' # 类属性 @property def prop(self): '''prop doc''' return 'prop value'obj = Class()print(dir(obj)) # 查询所有属性名列表，包括从父类继承的，返回__dir__()的结果print(vars(obj)) # &#123;&#125;，实例的属性名值对，返回__dict__属性的值print(obj.data) # class data，获取的是Class.data的值obj.data = 'bar' # 创建一个实例属性，覆盖了类属性print(vars(obj)) # &#123;'data': 'bar'&#125;print(Class.data) # class data，类属性没有改变print(Class.prop) # &lt;property object at ...&gt;，特性相当于类属性，获取的是特性对象本身，不会运行特性的读值方法print(obj.prop) # prop value，实例调用，执行了特性的读值方法# obj.prop = 'foo' # AttributeError: can't set attribute，只读特性，报错obj.__dict__['prop'] = 'foo' # 通过__dict__成功设置实例属性print(vars(obj)) # &#123;'data': 'bar', 'prop': 'foo'&#125;print(obj.prop) # prop value，仍会运行特性的读值方法，特性覆盖了实例属性Class.prop = 'baz' # 相当于销毁了特性对象print(obj.prop) # foo，现在读取的是实例属性Class.data = property(lambda self: 'class data prop', doc='data doc')print(obj.data) # class data prop，实例的data属性被类的data特性覆盖了del Class.dataprint(obj.data) # bar，恢复原样 obj.attr 这样的表达式不会从 obj 开始寻找attr，而是从 obj.__class__ 开始。而且， 仅当类中没有名为 attr的特性时， Python 才会在 obj 实例中寻找。 特性工厂12345678910111213141516171819202122232425262728293031def quantity(storage_name): def qty_getter(instance): return instance.__dict__[storage_name] def qty_setter(instance, value): if value &gt; 0: instance.__dict__[storage_name] = value else: raise ValueError('value must be &gt; 0') return property(qty_getter, qty_setter)class LineItem(): weight = quantity('weight') # 把自定义特性定义为类属性 price = quantity('price') def __init__(self, desc, weight, price): self.desc = desc self.weight = weight # 特性已经激活 self.price = price def subtotal(self): return self.weight*self.pricei = LineItem('desc', 10, 20)print(LineItem.weight)# &#123;'desc': 'desc', 'weight': 10, 'price': 20&#125;，实例也创建了属性的，真正用于存储值print(vars(i))print(i.weight) # 10，调用了特性的读值方法 处理属性删除操作1234567891011121314151617181920212223242526class BlackKnight(): def __init__(self): self.members = ['an arm', 'another arm', 'a leg', 'another leg'] self.phrases = ["'Tis but a scratch.", "It's just a flesh wound.", "I'm invincible!", "All right, we'll call it a draw."] @property def member(self): print('next member is:') return self.members[0] @member.deleter def member(self): text = 'BLACK KNIGHT (loses &#123;&#125;)\n-- &#123;&#125;' print(text.format(self.members.pop(0), self.phrases.pop(0)))knight = BlackKnight()print(knight.member)del knight.memberdel knight.memberdel knight.memberdel knight.member 处理属性的重要属性和函数特殊属性1234567b = BlackKnight()print(type(BlackKnight)) # &lt;class 'type'&gt;print(BlackKnight.__class__) # &lt;class 'type'&gt;print(type(b)) # &lt;class '__main__.BlackKnight'&gt;print(b.__class__) # &lt;class '__main__.BlackKnight'&gt; __class__：对象所属类的引用（即 obj.__class__ 与 type(obj) 的作用相同） 。Python 的某些特殊方法， 例如 __getattr__， 只在对象的类中寻找， 而不在实例中寻找。 __dict__：一个映射， 存储对象或类的可写属性（键值对）。 有 __dict__ 属性的对象，任何时候都能随意设置新属性。 如果类有 __slots__ 属性， 它的实例可能没有 __dict__ 属性。 参见下面对 __slots__ 属性的说明。 __slots__：类可以定义这个这属性， 限制实例能有哪些属性。 __slots__ 属性的值是一个字符串组成的元组， 指明允许有的属性。 如果 __slots__ 中没有 __dict__， 那么该类的实例没有 __dict__ 属性， 实例只允许有指定名称的属性。 内置函数dir([object])：列出对象的大多数属性。dir 函数的目的是交互式使用， 因此没有提供完整的属性列表， 只列出一组“重要的”属性名。 dir 函数能审查有或没有 __dict__ 属性的对象。 dir 函数不会列出 __dict__ 属性本身， 但会列出其中的键。 dir 函数也不会列出类的几个特殊属性， 例如 __mro__、 __bases__ 和 __name__。 如果没有指定可选的 object 参数， dir 函数会列出当前作用域中的名称。 getattr(object, name[, default])：从 object 对象中获取 name 字符串对应的属性。 获取的属性可能来自对象所属的类或超类。 如果没有指定的属性， getattr 函数抛出AttributeError 异常， 或者返回 default 参数的值（如果设定了这个参数的话） 。 hasattr(object, name)：如果 object 对象中存在指定的属性， 或者能以某种方式（例如继承） 通过 object 对象获取指定的属性， 返回 True。 文档说： “这个函数的实现方法是调用 getattr(object, name) 函数， 看看是否抛出AttributeError 异常。 ” setattr(object, name, value)：把 object 对象指定属性的值设为 value， 前提是 object 对象能接受那个值。 这个函数可能会创建一个新属性， 或者覆盖现有的属性。 vars([object])：返回 object 对象的 __dict__ 属性； 如果实例所属的类定义了 __slots__ 属性， 实例没有 __dict__ 属性， 那么 vars 函数不能处理那个实例（相反， dir 函数能处理这样的实例） 。 如果没有指定参数，那么 vars() 函数的作用与 locals() 函数一样： 返回表示本地作用域的字典。 特殊方法使用点号或内置的 getattr、 hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。 但是， 直接通过实例的 __dict__ 属性读写属性不会触发这些特殊方法——如果需要， 通常会使用这种方式跳过特殊方法。要假定特殊方法从类上获取， 即便操作目标是实例也是如此。 因此， 特殊方法不会被同名实例属性遮盖。例如， obj.attr 和 getattr(obj, ‘attr’, 42) 都会触发 Class.__getattribute__(obj, &#39;attr&#39;) 方法。 __delattr__(self, name)：只要使用 del 语句删除属性， 就会调用这个方法。 例如， del obj.attr 语句触发 Class.__delattr__(obj, &#39;attr&#39;) 方法。 __dir__(self)：把对象传给 dir 函数时调用， 列出属性。 例如， dir(obj) 触发 Class.__dir__(obj) 方法。 __getattr__(self, name)：仅当获取指定的属性失败， 搜索过 obj、 Class 和超类之后调用。表达式 obj.no_such_attr、 getattr(obj, ‘no_such_attr’) 和hasattr(obj, ‘no_such_attr’) 可能会触发 Class.__getattr__(obj, &#39;no_such_attr&#39;) 方法， 但是， 仅当在obj、 Class 和超类中找不到指定的属性时才会触发。 __setattr__(self, name, value)：尝试设置指定的属性时总会调用这个方法。 点号和 setattr 内置函数会触发这个方法。 例如， obj.attr = 42 和 setattr(obj,’attr’, 42) 都会触发 Class.__setattr__(obj, ‘attr’, 42) 方法。 __getattribute__(self, name)：尝试获取指定的属性时总会调用这个方法， 不过， 寻找的属性是特殊属性或特殊方法时除外。 点号与 getattr 和 hasattr 内置函数会触发这个方法。 调用 __getattribute__ 方法且抛出 AttributeError 异常时， 才会调用 __getattr__ 方法。 为了在获取 obj 实例的属性时不导致无限递归， __getattribute__ 方法的实现要使用 super().__getattribute__(obj, name)。 属性描述符描述符是对多个属性运用相同存取逻辑的一种方式。描述符是实现了特定协议的类， 这个协议包括 __get__、 __set__ 和 __delete__ 方法。 property 类实现了完整的描述符协议。 通常， 可以只实现部分协议。我们在真实的代码中见到的大多数描述符只实现了 __get__ 和 __set__ 方法， 还有很多只实现了其中的一个。Django模型的字段就是描述符。 描述符示例：验证属性把19章的把 quantity 特性工厂函数重构成 Quantity 描述符类。 术语说明： 描述符类：实现描述符协议的类 托管类：把描述符实例声明为类属性的类 描述符实例：描述符类的各个实例， 声明为托管类的类属性 托管实例：托管类的实例 储存属性：托管实例中存储自身托管属性的属性 托管属性：托管类中由描述符实例处理的公开属性， 值存储在储存属性中。 也就是说， 描述符实例和储存属性为托管属性建立了基础 123456789101112131415161718192021222324252627class Quantity(): # 基于协议实现，不用继承 def __init__(self, storage_name): self.storage_name = storage_name # 储存属性的名称 def __set__(self, instance, value): # 为托管属性赋值时调用，设置托管实例的储存属性 if value &gt; 0: # 如果使用内置的setattr 函数， 会再次触发 __set__ 方法， 导致无限递归 instance.__dict__[self.storage_name] = value else: raise ValueError('value must be &gt; 0')class LineItem(): weight = Quantity('weight') # 把描述符实例绑定到类属性 weight price = Quantity('price') def __init__(self, desc, weight, price): self.desc = desc self.weight = weight self.price = price def subtotal(self): return self.weight*self.pricetruffle = LineItem('White truffe', 100, 10)print(vars(truffle)) 自动获取储存属性的名称123456789101112131415161718192021222324252627282930class Quantity(): __counter = 0 # Quantity的私有类属性 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) # 为每个储存属性生成一个唯一的名称 cls.__counter += 1 def __get__(self, instance, owner): # instance是托管实例的引用， owner是托管类（如 LineItem） 的引用 if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): if value &gt; 0: # 因为托管属性和储存属性的名称不同， 所以把储存属性传给 getattr 函数不会触发描述符 setattr(instance, self.storage_name, value) else: raise ValueError('value must be &gt; 0')class LineItem(): weight = Quantity() price = Quantity() pass 重构描述符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import abcclass AutoStorage(): # AutoStorage 类提供了之前 Quantity 描述符的大部分功能 __counter = 0 def __init__(self): cls = self.__class__ prefix = cls.__name__ index = cls.__counter self.storage_name = '_&#123;&#125;#&#123;&#125;'.format(prefix, index) cls.__counter += 1 def __get__(self, instance, owner): if instance is None: return self else: return getattr(instance, self.storage_name) def __set__(self, instance, value): setattr(instance, self.storage_name, value)class Validated(abc.ABC, AutoStorage): def __set__(self, instance, value): # 把验证操作委托给 validate 方法 value = self.validate(instance, value) super().__set__(instance, value) @abc.abstractmethod def validate(self, instance, value): """return validated value or raise ValueError"""class Quantity(Validated): """a number greater than zero""" def validate(self, instance, value): if value &lt;= 0: raise ValueError('value must be &gt; 0') return valueclass NonBlank(Validated): """a string with at least one non-space character""" def validate(self, instance, value): value = value.strip() if len(value) == 0: raise ValueError('value cannot be empty or blank') return valueclass LineItem(): desc = NonBlank() weight = Quantity() price = Quantity() pass 12345import lineitemprint(lineitem.Quantity.__mro__) # (&lt;class 'lineitem.Quantity'&gt;, &lt;class 'lineitem.Validated'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'lineitem.AutoStorage'&gt;, &lt;class 'object'&gt;)print(LineItem5.Quantity.__mro__) 覆盖型和非覆盖型描述符对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def cls_name(obj_or_cls): cls = type(obj_or_cls) if cls is type: cls = obj_or_cls return cls.__name__.split('.')[-1]def display(obj): cls = type(obj) if cls is type: return '&lt;class &#123;&#125;&gt;'.format(obj.__name__) elif cls in [type(None), int]: return repr(obj) else: return '&lt;&#123;&#125; object&gt;'.format(cls_name(obj))def print_args(name, *args): pseudo_args = ', '.join(display(x) for x in args) print('-&gt; &#123;&#125;.__&#123;&#125;__(&#123;&#125;)'.format(cls_name(args[0]), name, pseudo_args))class Overriding(): # 有 __get__ 和 __set__ 方法的典型覆盖型描述符 def __get__(self, instance, owner): print_args('get', self, instance, owner) def __set__(self, instance, value): print_args('set', self, instance, value)class OverridingNoGet: # 没有 __get__ 方法的覆盖型描述符 def __set__(self, instance, value): print_args('set', self, instance, value)class NonOverriding: # 没有 __set__ 方法， 所以这是非覆盖型描述符 def __get__(self, instance, owner): print_args('get', self, instance, owner)class Managed: over = Overriding() over_no_get = OverridingNoGet() non_over = NonOverriding() def spam(self): # 为了对比， 因为方法也是描述符 print('-&gt; Managed.spam(&#123;&#125;)'.format(display(self)))obj = Managed() 覆盖型描述符：也叫数据描述符或强制描述符，实现 __set__ 方法的描述符属于覆盖型描述符， 因为虽然描述符是类属性， 但是实现 __set__ 方法的话， 会覆盖对实例属性的赋值操作 12345678obj.over # (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)Managed.over # (&lt;Overriding object&gt;, None, &lt;class Managed&gt;)obj.over = 7 # (&lt;Overriding object&gt;, &lt;Managed object&gt;, 7)obj.over # (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.__dict__['over'] = 8print(vars(obj)) # &#123;'over': 8&#125;obj.over # 即使有了over的实例属性，Managed.over仍会覆盖读取obj.over操作# (&lt;Overriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;) 没有 __get__ 方法的覆盖性描述符： 12345678910111213# 没有实现__get__方法，因此从类中获取描述符实例 &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;print(obj.over_no_get)# &lt;__main__.OverridingNoGet object at 0x000002A88A67B8D0&gt;print(Managed.over_no_get)# 触发__set__方法，(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get = 7# 仍是托管类中的描述符实例，&lt;__main__.OverridingNoGet object at 0x000001A913D8C908&gt;print(obj.over_no_get)obj.__dict__['over_no_get'] = 9print(obj.over_no_get) # 9，over_no_get 实例属性会遮盖描述符， 但是只有读操作是如此# 仍然经过描述符的 __set__ 方法处理。(&lt;OverridingNoGet object&gt;, &lt;Managed object&gt;, 7)obj.over_no_get = 7print(obj.over_no_get) # 9，只要有同名的实例属性存在，描述符就会被遮盖 非覆盖型描述符：也叫非数据描述符或遮盖型描述符，没有实现 __set__ 方法的描述符是非覆盖型描述符。 1234567obj.non_over # (&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.non_over = 7 # 非覆盖型描述符，没有干涉赋值操作的__set__方法print(obj.non_over) # 7，名为 non_over 的实例属性，把类的同名描述符属性遮盖掉了Managed.non_over # (&lt;NonOverriding object&gt;, None, &lt;class Managed&gt;)del obj.non_over# 删掉实例属性后，仍然触发了描述符。(&lt;NonOverriding object&gt;, &lt;Managed object&gt;, &lt;class Managed&gt;)obj.non_over 在类中覆盖描述符不管描述符是不是覆盖型， 为类属性赋值都能覆盖描述符。读类属性的操作可以由依附在托管类上定义有 __get__ 方法的描述符处理，但是写类属性的操作不会由依附在托管类上定义有 __set__ 方法的描述符处理 1234Managed.over = 1Managed.over_no_get = 2Managed.non_over = 3print(obj.over, obj.over_no_get, obj.non_over) # 1 2 3，描述符真的不见了 方法是描述符在类中定义的函数属于绑定方法（bound method） ， 因为用户定义的函数都有 __get__ 方法， 所以依附到类上时， 就相当于描述符。 方法是非覆盖型描述符。 123456789obj = Managed()# obj.spam 获取的是绑定方法对象。&lt;bound method Managed.spam of &lt;__main__.Managed object at ...&gt;&gt;print(obj.spam)# Managed.spam 获取的是函数。&lt;function Managed.spam at 0x0000013D5D3DD400&gt;print(Managed.spam)obj.spam = 7 # 为 obj.spam 赋值，创建了同名的实例属性，将会遮盖类属性，导致无法通过 obj 实例访问 spam 方法print(obj.spam) # 7print(Managed.spam) # &lt;function Managed.spam at 0x0000013D5D3DD400&gt; 与描述符一样， 通过托管类访问时， 函数的 __get__ 方法会返回自身的引用。 但是， 通过实例访问时， 函数的 __get__ 方法返回的是绑定方法对象： 一种可调用的对象， 里面包装着函数， 并把托管实例（例如 obj） 绑定给函数的第一个参数（即 self） ， 这与 functools.partial 函数的行为一致。 12345678910111213141516171819202122232425262728import collectionsclass Text(collections.UserString): def __repr__(self): return 'Text(&#123;!r&#125;)'.format(self.data) def reverse(self): return self[::-1]word = Text('forward')print(word) # forwardprint(word.reverse()) # drawrofprint(Text.reverse(word)) # drawrof，在类上调用方法相当于调用函数# &lt;class 'function'&gt; &lt;class 'method'&gt;print(type(Text.reverse), type(word.reverse))# 函数都是非覆盖型描述符。 在函数上调用 __get__ 方法时传入实例， 得到的是绑定到那个实例上的方法。# &lt;bound method Text.reverse of Text('forward')&gt;print(Text.reverse.__get__(word))# 如果 instance 参数的值是 None， 那么得到的是函数本身# &lt;function Text.reverse at 0x000001F3A93DF0D0&gt;print(Text.reverse.__get__(None, Text))# word.reverse 表达式其实会调用Text.reverse.__get__(word)， 返回对应的绑定方法# &lt;bound method Text.reverse of Text('forward')&gt;print(word.reverse)print(word.reverse.__self__) # forward，调用这个方法的实例引用。print(word.reverse.__func__ is Text.reverse) # True，依附在托管类上那个原始函数的引用 绑定方法对象还有个 __call__ 方法， 用于处理真正的调用过程。 这个方法会调用 __func__ 属性引用的原始函数， 把函数的第一个参数设为绑定方法的 __self__ 属性。 描述符用法建议 使用特性以保持简单 内置的 property 类创建的其实是覆盖型描述符， __set__ 方法和 __get__ 方法都实现了， 即便不定义设值方法也是如此。 特性的 __set__ 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性， 这能避免下一条所述的问题。 只读描述符必须有 __set__ 方法 如果使用描述符类实现只读属性， 要记住， __get__ 和 __set__ 两个方法必须都定义， 否则， 实例的同名属性会遮盖描述符。 只读属性的 __set__ 方法只需抛出 AttributeError 异常， 并提供合适的错误消息。 用于验证的描述符可以只有 __set__ 方法 对仅用于验证的描述符来说， __set__ 方法应该检查 value 参数获得的值， 如果有效， 使用描述符实例的名称为键， 直接在实例的 __dict__ 属性中设置。 这样， 从实例中读取同名属性的速度很快， 因为不用经过 __get__ 方法处理。 仅有 __get__ 方法的描述符可以实现高效缓存 如果只编写了 __get__ 方法， 那么创建的是非覆盖型描述符。 这种描述符可用于执行某些耗费资源的计算， 然后为实例设置同名属性，缓存结果。 同名实例属性会遮盖描述符， 因此后续访问会直接从实例的 __dict__ 属性中获取值， 而不会再触发描述符的 __get__ 方法。 非特殊的方法可以被实例属性遮盖 由于函数和方法只实现了 __get__ 方法， 它们不会处理同名实例属性的赋值操作。 因此， 像 my_obj.the_method = 7 这样简单赋值之后， 后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。 然而， 特殊方法不受这个问题的影响。 解释器只会在类中寻找特殊的方法， 也就是说， repr(x) 执行的其实是 x.__class__.__repr__(x)， 因此 x 的 __repr__ 属性对 repr(x) 方法调用没有影响。 出于同样的原因， 实例的 __getattr__ 属性不会破坏常规的属性访问规则。 类元编程类元编程是指在运行时创建或定制类的技艺。元类是类元编程最高级的工具： 使用元类可以创建具有某种特质的全新类种， 例如我们见过的抽象基类。 类工厂函数12345class Dog: def __init__(self, name, weight, owner): self.name = name self.weight = weight self.owner = owner 避免编写上述样板代码，我们下面创建一个类工厂函数，即可变对象版本的collections.namedtuple。 1234567891011121314151617181920212223242526272829303132333435def record_factory(cls_name, field_names): try: field_names = field_names.replace(',', ' ').split() except AttributeError: # 不能调用.replace或.split方法 pass # 假定field_names本就是标识符组成的序列 # 构建元组，这将成为新建类的 __slots__ 属性；这么做还设定了拆包和字符串表示形式中各字段的顺序 field_names = tuple(field_names) def __init__(self, *args, **kwargs): attrs = dict(zip(self.__slots__, args)) attrs.update(kwargs) for name, value in attrs.items(): setattr(self, name, value) def __iter__(self): for name in self.__slots__: yield getattr(self, name) def __repr__(self): values = ', '.join('&#123;&#125;=&#123;!r&#125;'.format(*i) for i in zip(self.__slots__, self)) return '&#123;&#125;(&#123;&#125;)'.format(self.__class__.__name__, values) cls_attrs = dict(__slots__=field_names, __init__=__init__, __iter__=__iter__, __repr__=__repr__) return type(cls_name, (object,), cls_attrs) # 调用 type 构造方法，构建新类，然后返回Dog = record_factory('Dog', 'name weight owner')rex = Dog('Rex', 30, 'Bob')print(rex) # Dog(name='Rex', weight=30, owner='Bob') type 的实例是类。 1234ty = type('MyClass', (object,), &#123;'x': 1&#125;)print(type(ty)) # &lt;class 'type'&gt;obj = ty()print(obj) # &lt;__main__.MyClass object at ...&gt; 相当于 1234class MyClass(): x = 1print(type(MyClass)) # &lt;class 'type'&gt; 定制描述符的类装饰器类装饰器与函数装饰器非常类似， 是参数为类对象的函数， 返回原来的类或修改后的类。 123456789101112def entity(cls): # 类装饰器的参数是一个类 for key, attr in cls.__dict__.items(): if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key) return cls@entityclass LineItem(): desc = NonBlank() weight = Quantity() price = Quantity() 类装饰器能以较简单的方式做到以前需要使用元类去做的事情——创建类时定制类。 类装饰器有个重大缺点： 只对直接依附的类有效。 这意味着， 被装饰的类的子类可能继承也可能不继承装饰器所做的改动，这个缺点在下面解决。 导入时和运行时比较 evaltime.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344from evalsupport import deco_alphaprint('&lt;[1]&gt; evaltime module start')class ClassOne(): print('&lt;[2]&gt; ClassOne body') def __init__(self): print('&lt;[3]&gt; ClassOne.__init__') def __del__(self): print('&lt;[4]&gt; ClassOne.__del__') def method_x(self): print('&lt;[5]&gt; ClassOne.method_x') class ClassTwo(object): print('&lt;[6]&gt; ClassTwo body')@deco_alphaclass ClassThree(): print('&lt;[7]&gt; ClassThree body') def method_y(self): print('&lt;[8]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[9]&gt; ClassFour body') def method_y(self): print('&lt;[10]&gt; ClassFour.method_y')if __name__ == '__main__': print('&lt;[11]&gt; ClassOne tests', 30 * '.') one = ClassOne() one.method_x() print('&lt;[12]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[13]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('&lt;[14]&gt; evaltime module end') evalsupport.py 1234567891011121314151617181920212223print('&lt;[100]&gt; evalsupport module start')def deco_alpha(cls): print('&lt;[200]&gt; deco_alpha') def inner_1(self): print('&lt;[300]&gt; deco_alpha:inner_1') cls.method_y = inner_1 return clsclass MetaAleph(type): print('&lt;[400]&gt; MetaAleph body') def __init__(cls, name, bases, dic): # cls（self）：这是要初始化的类对象（例如 ClassFive） print('&lt;[500]&gt; MetaAleph.__init__') def inner_2(self): # self，是初始化类的实例 print('&lt;[600]&gt; MetaAleph.__init__:inner_2') cls.method_z = inner_2print('&lt;[700]&gt; evalsupport module end') 场景1：import evaltime 12345678910111213&gt;&gt;&gt; import evaltime# evalsupport 模块中的所有顶层代码在导入模块时运行； 解释器会编译 deco_alpha 函数， 但是不会执行定义体。&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body # MetaAleph 类的定义体运行了&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassOne body # 每个类的定义体都执行了&lt;[6] &gt; ClassTwo body&lt;[7] &gt; ClassThree body&lt;[200] &gt; deco_alpha # 先计算被装饰的类 ClassThree 的定义体， 然后运行装饰器函数。&lt;[9] &gt; ClassFour body&lt;[14] &gt; evaltime module end # evaltime 模块是导入的， 因此不会运行 if __name__ == '__main__': 块 场景2：python3 evaltime.py 1234567891011121314151617181920&gt;&gt;&gt; py evaltime.py&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassOne body&lt;[6] &gt; ClassTwo body&lt;[7] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[9] &gt; ClassFour body&lt;[11] &gt; ClassOne tests ..............................&lt;[3] &gt; ClassOne.__init__&lt;[5] &gt; ClassOne.method_x&lt;[12] &gt; ClassThree tests ..............................&lt;[300] &gt; deco_alpha: inner_1&lt;[13] &gt; ClassFour tests ..............................&lt;[10] &gt; ClassFour.method_y # 类装饰器可能对子类没有影响&lt;[14] &gt; evaltime module end&lt;[4] &gt; ClassOne.__del__ # 程序结束时， 绑定在全局变量 one 上的 ClassOne 实例才会被垃圾回收程序回收。 元类基础知识元类是制造类的工厂， 不过不是函数， 而是类。元类是用于构建类的类。 根据 Python 对象模型， 类是对象， 因此类肯定是另外某个类的实例。 默认情况下， Python 中的类是 type 类的实例。 也就是说， type 是大多数内置的类和用户定义的类的元类。 123print('spam'.__class__) # &lt;class 'str'&gt;print(str.__class__) # &lt;class 'type'&gt;print(type.__class__) # 为了避免无限回溯， type 是其自身的实例。 type和object的关系 ABCMeta和type的关系 所有类都是 type 的实例， 但是元类还是 type 的子类， 因此可以作为制造类的工厂。 具体来说， 元类可以通过实现 __init__ 方法定制实例。 元类的 __init__ 方法可以做到类装饰器能做的任何事情， 但是作用更大。 元类计算时间的练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from evalsupport import deco_alphafrom evalsupport import MetaAlephprint('&lt;[1]&gt; evaltime module start')@deco_alphaclass ClassThree(): print('&lt;[2]&gt; ClassThree body') def method_y(self): print('&lt;[3]&gt; ClassThree.method_y')class ClassFour(ClassThree): print('&lt;[4]&gt; ClassFour body') def method_y(self): print('&lt;[5]&gt; ClassFour.method_y')class ClassFive(metaclass=MetaAleph): print('&lt;[6]&gt; ClassFive body') def __init__(self): print('&lt;[7]&gt; ClassFive.__init__') def method_z(self): print('&lt;[8]&gt; ClassFive.method_z')class ClassSix(ClassFive): print('&lt;[9]&gt; ClassSix body') def method_z(self): print('&lt;[10]&gt; ClassSix.method_z')if __name__ == '__main__': print('&lt;[11]&gt; ClassThree tests', 30 * '.') three = ClassThree() three.method_y() print('&lt;[12]&gt; ClassFour tests', 30 * '.') four = ClassFour() four.method_y() print('&lt;[13]&gt; ClassFive tests', 30 * '.') five = ClassFive() five.method_z() print('&lt;[14]&gt; ClassSix tests', 30 * '.') six = ClassSix() six.method_z()print('&lt;[15]&gt; evaltime_meta module end') 场景3：import evaltime_meta 1234567891011121314&gt;&gt;&gt; import evaltime_meta&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[4] &gt; ClassFour body&lt;[6] &gt; ClassFive body&lt;[500] &gt; MetaAleph.__init__ #创建 ClassFive 时调用了 MetaAleph.__init__ 方法&lt;[9] &gt; ClassSix body&lt;[500] &gt; MetaAleph.__init__ #创建 ClassFive 的子类 ClassSix 时也调用了 MetaAleph.__init__ 方法&lt;[15] &gt; evaltime_meta module end 场景4：py evaltime_meta.py 123456789101112131415161718192021222324&gt;&gt;&gt; py evaltime_meta.py&lt;[100] &gt; evalsupport module start&lt;[400] &gt; MetaAleph body&lt;[700] &gt; evalsupport module end&lt;[1] &gt; evaltime module start&lt;[2] &gt; ClassThree body&lt;[200] &gt; deco_alpha&lt;[4] &gt; ClassFour body&lt;[6] &gt; ClassFive body&lt;[500] &gt; MetaAleph.__init__&lt;[9] &gt; ClassSix body&lt;[500] &gt; MetaAleph.__init__&lt;[11] &gt; ClassThree tests ..............................&lt;[300] &gt; deco_alpha: inner_1&lt;[12] &gt; ClassFour tests ..............................&lt;[5] &gt; ClassFour.method_y #没有直接依附装饰器的 ClassFour 类不受影响&lt;[13] &gt; ClassFive tests ..............................&lt;[7] &gt; ClassFive.__init__&lt;[600] &gt; MetaAleph.__init__: inner_2&lt;[14] &gt; ClassSix tests ..............................&lt;[7] &gt; ClassFive.__init__&lt;[600] &gt; MetaAleph.__init__: inner_2 #ClassSix 类没有直接引用 MetaAleph 类， 但是却受到了影响， 因为它是 ClassFive 的子类， 进而也是 MetaAleph 类的实例， 所以由 MetaAleph.__init__ 方法初始化。&lt;[15] &gt; evaltime_meta module end 定制描述符的元类替代 @entity 装饰器： 1234567891011121314151617181920212223class EntityMeta(type): """元类， 用于创建带有验证字段的业务实体""" def __init__(cls, name, bases, attr_dict): # 在超类（在这里是 type） 上调用 __init__ 方法 super().__init__(name, bases, attr_dict) for name, attr in attr_dict.items(): # 与 @entity 装饰器的逻辑一样 if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, name)# 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类class Entity(metaclass=EntityMeta): """带有验证字段的业务实体"""import line_item as modelclass LineItem(model.Entity): desc = model.NonBlank() weight = model.Quantity() price = model.Quantity() pass 元类的特殊方法 prepare在某些应用中， 可能需要知道类的属性定义的顺序。type 构造方法及元类的 __new__ 和 __init__ 方法都会收到要计算的类的定义体， 形式是名称到属性的映射。 然而在默认情况下， 那个映射是字典； 也就是说，元类或类装饰器获得映射时， 属性在类定义体中的顺序已经丢失了。 1234567891011121314151617181920212223242526class EntityMeta(type): """元类， 用于创建带有验证字段的业务实体""" @classmethod def __prepare__(cls, name, bases): return collections.OrderedDict() def __init__(cls, name, bases, attr_dict): super().__init__(name, bases, attr_dict) cls._field_names = [] # 非私有属性 # 这里的 attr_dict 是那个OrderedDict 对象， 由解释器在调用 __init__ 方法之前调用 __prepare__ 方法时获得（prepare-&gt;new-&gt;init） # 因此， 这个 for 循环会按照添加属性的顺序迭代属性 for key, attr in attr_dict.items(): if isinstance(attr, Validated): type_name = type(attr).__name__ attr.storage_name = '_&#123;&#125;#&#123;&#125;'.format(type_name, key) cls._field_names.append(key)# 这个类的存在只是为了用起来便利： 这个模块的用户直接继承Entity 类即可， 无需关心 EntityMeta 元类class Entity(metaclass=EntityMeta): """带有验证字段的业务实体""" @classmethod def field_names(cls): for name in cls._field_names: yield name 调用： 12for name in LineItem.field_names(): print(name) __prepare__：这个特殊方法只在元类中有用， 而且必须声明为类方法（即使用@classmethod 装饰器定义） 。 解释器调用元类的 __new__ 方法之前会先调用 __prepare__ 方法， 使用类定义体中的属性创建映射。 __prepare__ 方法的第一个参数是元类， 随后两个参数分别是要构建的类的名称和基类组成的元组， 返回值必须是映射。 元类构建新类时，__prepare__ 方法返回的映射会传给 __new__ 方法的最后一个参数， 然后再传给 __init__ 方法。 框架和库会使用元类协助程序员执行很多任务， 例如： 验证属性 一次把装饰器依附到多个方法上 序列化对象或转换数据 对象关系映射 基于对象的持久存储 动态转换使用其他语言编写的类结构 类作为对象Python 数据模型为每个类定义了很多属性，除了 __mro__ 、 __class__ 和 __name__ 属性之外，还有： cls.__bases__：由类的基类组成的元组 cls.__qualname__：其值是类或函数的限定名称， 即从模块的全局作用域到类的点分路径。例如：内部类ClassTwo 的 __qualname__ 属性， 其值是字符串 ‘ClassOne.ClassTwo’， 而 __name__ 属性的值是 ‘ClassTwo’ cls.__subclasses__()：包含类的直接子类。 这个方法的实现使用弱引用， 防止在超类和子类（子类在 __bases__ 属性中储存指向超类的强引用） 之间出现循环引用。 这个方法返回的列表中是内存里现存的子类 cls.mro()：超类元组 dir(…) 函数不会列出本节提到的任何一个属性。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编程：从入门到实践_注释笔记]]></title>
    <url>%2F2018%2F07%2F30%2FPython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符串1234567name.title() # 首字母大写name.upper() name.lower() # 转换大小写name.rstrip() name.lstrip()name.strip() # 删除右边/左边/两边的空格"age" + 12 # 会报错，应使用str()方法将数字转换成字符串 列表元素操作123456list.append(item) # 新增list.insert(0,item) # 插入del list[1] # 删除某索引元素list.pop() # 删除列表末尾元素，并返回它list.pop(2) # 弹出列表中某索引的元素，并返回它list.remove('alan') # 根据值来删除元素，只删除第一个符合的 组织列表1234list.sort() # 永久排序，改变自身sorted(list) # 临时排序，不改变列表list.reverse() # 按索引反转列表，改变自身len(list) # 计算列表长度 操作列表遍历12for item in list: pass 创建数值列表1range(1,5) # 左闭右开，1,2,3,4 简单统计123min(list)max(list)sum(list) 列表推导式1squares = [item**2 for item in range(1,11)] # 返回从1-10的平方的列表 切片123list[0:3] # 返回索引为0-2的元素列表，左闭右开list[:3] # 冒号左边缺省则默认从0，右边缺省则默认列表的lengthlist[:] # 浅复制整个列表 元组tuple = (30,100)不可变的列表称为元组遍历元组同列表一样，元组元素不可修改，但是可以重新定义整个元组变量 字典dict = {} 12345678910111213141516171819dict['name'] = 'alan' # 新增/更新del dict['name'] # 删除dict.pop('name') # 删除并返回items() # 返回由字典每一对键值构成的元组的列表keys() # 返回字典所有键组成的列表values() # 返回值的列表for key,value in dict.items(): # 遍历 passfor key in sorted(dict.keys()): # 按字符顺序遍历 passfor value in set(dict.values()): # 获取唯一不重复的值 passif 'name' in dict.keys(): # 判断键值是否存在 pass while循环假值123456d = &#123;&#125;l = []set1 = set()t = tuple()i = 0str1 = '' 假值转换为bool时为False,如if not set1:/while l: 移动元素12345arr1 = ['str1', 'str2', 'str3']arr2 = []while arr1: arr2.append(arr1.pop()) 删除特定元素1234arr1 = ['str1', 'str2', 'str3', 'str1']while 'str1' in arr1: arr1.remove('str1') 函数定义1234567891011121314151617181920def funcname(p1, p2='dog'): # 可选参数 passfuncname('123', p2='cat') # 通过关键字传递实参funcname( arr[:] ) # 传递列表副本，避免被函数内部修改def make(name,*args): # 可传递任意数量的实参，必须放在其他形参之后 print(args) # 创建一个参数组成的元组make('a1','a2','3') make() # 空元组 def make(name, **kwargs): # 传递任意数量的关键字实参 profile = &#123;'name': name&#125; for key, value in kwargs.items(): profile[key] = value return profileprint make('alan', age=20, gender='male') 导入123import make as m # 设置别名from make import remake # 导入特定函数from make import * # 导入所有函数，调用时不再需要模块名前缀 类定义类和方法123456789class Dog(): # python 3.x def __init__(self, name): # self代表实例自身的引用 self.name = name def sit(self): print(self.name+"is sitting")class Dob(object): # python 2.7 pass 继承12345678910111213141516171819202122232425262728# car.py"""this is a car module"""class Car(): def __init__(self, model): self.model = model def fill_gas(self): print('filling')class ElectricCar(Car): def __init__(self, model): super().__init__(model) def fill_gas(self): print('not need gas')from car import ElectricCarc = ElectricCar('ss')c.fill_gas()from car import Car,ElectricCar # 导入模块中的多个类import car # 导入整个模块from car import * # 导入模块中的所有类 Python标准库123456789# OrderedDictfrom collections import OrderedDictdict = OrderedDict()dict['sarah'] = 'c'dict['jen'] = 'python'dict['phil'] = 'ruby'print(dict) 有序字典，保留数据初始时的顺序 编码风格：类名：驼峰命名法，首字母大写，不使用下划线实例名和模块名：小写，单词之间加下划线模块和类都要包含一个文档字符串空行的使用：类中使用一个空行分隔方法，模块中使用两个空行来分隔类导入模块时，先导入标准库模块，再添加一个空行，然后导入自己编写的模块 文件和异常文件读取1234567891011with open('test.txt') as txt: # 一次读取一行 for row in txt: print(row.strip()) # 读取全部内容 print(txt.read()) # 加载到list中 lines = txt.readlines() # list 写入123with open('test.txt','w') as txt: txt.write()('123123\n') txt.write()('abcabc\n') 参数说明：r - 读取模式r+ - 读取和写入w - 写入模式a - 附加模式w和a模式，当文件不存在时则创建 异常ZeroDivisionError：除以0时抛出FileNotFoundError：文件未找到时抛出 1234567try: --skip--except FileNotFoundError as e: #发生异常 pass else: #未发生异常时 --skip-- 存储数据json存储和读取12345678import jsondic = &#123;'name': 'alan', 'age': 12&#125;with open('text.txt', 'a') as txt: json.dump(dic, txt) # 存储with open('text.txt', 'r') as txt: re = json.load(txt) #读取 print(type(re)) #dict，自动转换类型 单元测试12345678910111213141516import unittestfrom car import Carclass TestCarMethod(unittest.TestCase): #测试用例，包含多个单元测试 def setUp(self): self.c = Car() #setUp方法，初始化下面要用到的数据 def test_set(self): re = self.c.set_wheels(5) self.assertFalse(re) #断言方法，表达式是否为False def test_get(self): wheels = self.c.get_wheels() self.assertIn(wheels, range(1, 5)) #值是否包含于列表中unittest.main() 运行测试用例时，每完成一个单元测试，通过时打印一个句点。引发错误时打印一个E，断言失败时打印F]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级程序设计_注释笔记]]></title>
    <url>%2F2018%2F02%2F04%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本概念解释型和编译型语言的区别 编译型 需要编译器。把高级语言编译为机器码文件，编译期代码检查，执行速度更快，一次编译处处执行，可移植性更好。如：Java，C#等。 解释性 需要解释器。解释器直接读入源代码，边解释（编译）边执行。错误只能等到解释器执行的有关代码时才能被发现，再次运行，需要重新解释，速度较慢。如：JS，Python等。 完整的JavaScript的三个部分 核心（ECMAScript） 与Web浏览器没有依赖关系，是基础。定义了： 语法，类型，语句，关键字，保留字，操作符，对象 文档对象模型（DOM） 针对XML但经过扩展用于HTML的API。 DOM1级，包括DOM核心（DOM Core）和DOM HTML。 浏览器对象模型（BOM） 处理浏览器和框架 严格模式&quot;use strict&quot; 编译指示，为了不破坏ECMAScript 3语法，一些不确定的行为将得到处理，对于某些不安全的操作也会抛出错误。 局部域定义全局变量123function test()&#123; msg = "hi"; // 全局变量&#125; 并不推荐，很难维护。相应变量不会马上就有定义导致混乱。 数据类型undefined,null,boolean,number,string typeof 操作符未定义 - undefined布尔值 - boolean字符串 - string数值 - number对象或null - object函数 - function 从技术上来讲，函数在ECMAScript中是对象，不是一种数据类型。然后函数有一些特殊的属性，typeof得到的值也不同于对象 undefined类型12345var v1; //声明之后默认取得undefined值alert(v1); //"undefined"alert(v2); //引用错误alert(typeof v1) //"undefined"alert(typeof v2) //"undefined" null类型typeof null //返回 object 适用于，准备将变量用于保存对象，那么最好将变量初始化为null，而不是其他值。使用 if(obj != null)来判断是否已经保存对象的引用。 undefined值派生自null值，所以null == undefined 返回ture。 boolean类型123456if (true) &#123; //通过，区分大小写 alert(1)&#125;if (True) &#123; //不通过，不是Boolean值，只是标识符 alert(1)&#125; Boolean()函数，传入任何参数总会返回Boolean值。规则如下： 类型 返回true 返回false Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined N/A（不适用） undefined 不传参数，返回false。 if()语句，自动执行Boolean()函数。 Number类型 整数值： 整数值可以以十进制，八进制，十六进制来表示。 1234var num=070; //前导0，十进制的56var num=079; //无效，前导0被忽略，解析为79var num=0xA; //前导0x，十进制的10var num=0x1z //无效，报错 浮点数值： 12345var num=1.; //解析为整数，1var num=10.0; //解析为整数，10简写：var num=3.12e7; //3.12乘以10的7次方var num=3.12e-7; //3.12乘以0.1的7次方 PS：0.1+0.2 == 0.3 返回false，因为ECMAScript的浮点运算基于IEEE754，存在二进制和十进制的小数点转换问题，并非独此一家。 数值范围 12345alert(Number.MAX_VALUE + Number.MAX_VALUE) //返回Infinityalert(-1 * (Number.MAX_VALUE + Number.MAX_VALUE)) //返回-InfinityNumber.POSITIVE_INFINITY //保存着InfinityNumber.NEGATIVE_INFINITY //保存着-InfinityisFinite() //判断是否是有穷的，Infinity返回false，MAX_VALUE返回ture，MAX_VALUE+1返回ture NaN 任何涉及NaN的计算，返回都是NaN。 NaN与任何值都不相等，包括NaN本身。NaN == NaN ，返回false。 12345isNaN(NaN) //trueisNaN(10) //falseisNaN("10"/"") //false ，可被转换成数值10/0isNaN("blue") //true，不能转换isNaN(ture/false) //false，可别转换成数值1 数值转换 Number()，用于任何数据类型 规则： Boolean，ture和false分别转换为1和0 数字，直接返回 null，返回0 undefined，返回NaN 字符串：整数，浮点数，对应的十进制。有效的十六进制，等值的十进制整数。空字符串，0；包含其他字符，NaN 对象，先调用valueOf()方法，然后按照前面的规则转换返回的值，如果结果为NaN。再调用toString()方法。然后转换返回的字符串 parseInt()，parseFloat()，转换字符串。 String类型123var num=10;num.toString() //'10'num.toString(2) //'1010' 2/8/10/16，转换成相应的进制 Object类型常用属性/方法： Constructor：保存着用于创建当前对象的构造函数。 hasOwnProperty(name)：检查给定的属性在当前对象实例中是否存在。 toString() valueOf()，返回对象的字符串，数值或布尔值表示 BOM和DOM中的对象，属于宿主对象。可能不会集成Object。 操作符乘法有一个数是NaN，结果是NaN。Infinity与0相乘，结果是NaN。Infinity与非0相乘，结果是Infinity或-Infinity，取决于操作数的符号。如果是Infinity与Infinity相乘，结果是Infinity。如果一个不是数值，则调用Number()转换为数值后再相乘。 除法一个数是NaN，结果NaN。Infinity被Infinity除，结果是NaN。0被0除，结果NaN。非零有限数被0除，结果是Infinity或-Infinity，取决于符号。(-1/0)Infinity被非零数除，结果是Infinity或-Infinity，取决于符号。一个操作数不是数值，同乘法。 加法123Infinity+Infinity=Infinity-Infinity-Infinity=-InfinityInfinity-Infinity=NaN 如果一个操作数是字符串，调用他们的toString()得到字符串（undefined和null调用String()返回字面量），然后拼接。两个都是字符串，则直接拼接。没有字符串，则先调用Number()转换为数值，再进行加法。 减法1234Infinity-Infinity=NaN-Infinity+Infinity=NaNInfinity+Infinity=Infinity-Infinity-Infinity=-Infinity 如果一个操作数是字符串，布尔值，null或undefined，则先调用Number()函数转换为数值，再根据规则进行减法。如果转换为NaN，则结果是NaN。 +/- 操作符对非数值应用一元操作符时，会先执行Number()函数转换，然后在转为正/负数。 123456+"01" //1-"01" //-1+"z" //NaN-"z" //NaN+false //0-false //0 比较操作符两个字符串，比较两个字符串对应的字符编码值。一个数值，一个非数值，先进行数值转换。一个对象，则调用valueOf()方法，没有则调用toString()方法。再比较。 12345"a" &gt;/&lt; 3 //false，先进行转换"a"-&gt;NaN"a" &gt; "3" //true"23" &lt; "3" //true"23" &gt; 3 //true任何数与NaN比较，结果都是false 相等和不相等默认先进行强制转型，再比较。字符串/布尔，先转换，再比较。一个对象，一个不是，则调用对象的valueOf方法。两个都是对象，则比较是不是同一个对象。null和undefined是相等的，且比较时都不会执行转换。 特殊情况： 1234567891011null == undefined //trueundefined == 0 //falsenull == 0 //false"NaN" == NaN //falseNaN == 5 //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //false"5" == 5 //true 语句for-in语句可以用来枚举对象的属性1234for (var prop in window) &#123; var element = window[prop]; console.log(prop + ' ' + element)&#125; switch语句可以使用任何数据类型，case的值可以是常量，变量，或者表达式123456789101112var num = 12;switch (true) &#123; case num &gt; 10: alert("&gt;") break; case num &lt; 10: alert("&lt;") break; default: alert("=") break;&#125; 函数定义时不必制定是否返回值。 严格模式下，不能把函数/参数命名为eval或arguments，不能有连个同名参数。 参数ECMAScript函数不介意传递进多少个参数，不也在乎参数类型。定义和实际传递的参数没有个数与对应关系的限制。因为，参数在内部是用一个类似数组的对象（Arguments对象，并不是真的数组）来表示的。而不关心数组中包含哪些参数。12345name(1) //length 为1name(1,2) //length 为2function name() &#123; alert(arguments[0]) &#125; 命名参数只提供便利，但不是必须的。解析器不会验证命名参数。1234function add(num1,num2)&#123; arguments[1]=10; alert(arguments[0]+num2);&#125; 修改了arguments[1]的值，也就修改了num2，他们的值都会改变。不过它们的内存空间是独立的，但它们的值会同步。 arguments.callee返回的是当前执行的函数。 js的函数没有重载，重复定义的函数不论参数列表，后定义的函数会覆盖前面的函数。但可以使用arguments对象来模拟实现。 变量、作用域和内存基本类型和引用类型传递参数ECMAScript所有函数的参数都是按值传递。对于引用类型(对象)来说，不会改变原始引用，只会根据引用改变对象的成员。12345678910var p = &#123; name: 'bily' &#125;;set(p);alert(p.name)①function set(p) &#123; p = &#123;&#125;; p.name = 'alan';&#125;②function set(p) &#123; p.name = 'alan';&#125; ①，弹出bily。②，弹出alan。 检测类型12345678910111213141516171819typeof：var s = "Nicholas";var b = true;var i = 22;var u;var n = null;var o = new Object();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //Booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof o); //objectinstanceof： 检测对象的具体类型alert(&#123;&#125; instanceof Object); //所有对象，都返回turealert([] instanceof Array); alert(/^.$/ instanceof RegExp); 执行环境与作用域 每个函数都有自己的执行环境和作用域，但js没有块级作用域。例如if和for等语句。但是也有例外，例如catch和with语句。 查询标识符在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。从作用域链的前段开始，向上逐级查询。局部找到，则搜索停止。否则一直向上追溯到全局环境的变量对象，如果都没有找到，则意味着该变量未声明。 垃圾回收 引用类型Object类型Array类型创建12345var colors = ["red", "blue", "green"];colors[colors.length] = "black"; //结尾添加colors[99] = "black";alert(colors.length); //100alert(colors[50]); //undefined 检测arr instanceof Array //true/false 假定单一的全局执行环境，如果网页包含多个框架，则可能出现问题。为了解决这个问题，ECMAScrit新增了能检测iframes的方法 Array.isArray(arr) //true/false IE9+ 转换方法12345var colors = ["red", "blue", "green"]; alert(colors.toString()); //red,blue,greenalert(colors.valueOf()); //red,blue,greenalert(colors); //red,blue,green。自动执行toString()方法alert(colors.join("||")); //red||green||blue。改变分隔符。 栈方法：LIFO123456var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); var item = colors.pop(); //弹出末端最后的元素 alert(item); //"black"alert(colors.length); //2 队列方法：FIFO1234567891011121314var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); alert(count); //3var item = colors.shift(); //移除头部第一个元素alert(item); //"red"alert(colors.length); //2//反向的队列：var colors = []; var count = colors.unshift("red", "green"); // 0,1 count = colors.unshift("black"); //从头部插入，成为第一个元素，索引为0var item = colors.pop(); alert(item); //"green" 排序方法1234var values = [0, 1, 5, 10, 15];values.sort(); //正向 0,1,10,15,5 //sort方法默认会调用每项的toString()转型方法，然后比较得到的字符串。values.reverse(); //反向 自定义排序1234567function compare(value1, value2) &#123; return value2-value1;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);values.reverse(compare); 操作方法：增，减，替换 concat 返回新构建的数组副本 1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]); alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice 返回当前数组截取的副本 12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice 删除，插入，替换数组元素。返回删除项组成的数组，直接影响原数组 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); alert(colors); //green,bluealert(removed); //red (数组)removed = colors.splice(1, 0, "yellow", "orange"); alert(colors); //green,yellow,orange,bluealert(removed); //空数组removed = colors.splice(1, 1, "red", "purple"); alert(colors); //green,red,purple,orange,bluealert(removed); //yellow(数组) 数组的迭代方法 every()，对每一项运行给定函数，如果该函数对每一项都返回ture，则返回ture some()，对每一项运行给定函数，如果该函数对任一项返回ture，则返回ture filter()，对每一项运行给定函数，返回该函数会返回ture的项组成的数组 map()，对每一项运行给定函数，返回每次函数调用的结果组成的数组 forEach()，对每一项运行给定函数。无返回值。 1234567891011121314151617181920var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(someResult); //truevar filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3]var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 缩小方法接受4个参数，前一个值，当前值，当前索引，数组对象。函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight从反方向执行。 Date类型创建1234567var now = new Date() //新创的对象自动获得当前日期时间。var someDate = new Date(Date.parse("May 25, 2004"));var someDate = new Date("May 25,2004"); //默认调用Date.parse()var y2k = new Date(Date.UTC(2000, 0));var y2k = new Date(2000, 0);var allFives = new Date(2005, 4, 5, 17, 55, 55); 格式化 RegExp类型正则表达式模式 12var pattern=/[bc]at/i;var pattern=new RegExp("[bc]at","i"); 实例属性 exec()12345678910var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text); //返回包含第一个匹配项信息和额外信息的数组。alert(matches.index); //0alert(matches.input); //"mom and dad and baby"alert(matches[0]); //"mom and dad and baby"alert(matches[1]); //" and dad and baby"alert(matches[2]); //" and baby" [0]，与整个模式匹配的字符串[1][2]，与模式中的捕获组（？）匹配的字符串。没有捕获组则不存在。模式g，不设置则多次调用exec()将始终返回第一个匹配项的信息。设置则每次调用exec()都会在字符串中继续查找剩余的新匹配项。 构造函数属性123456789101112var text = "this has been a short summer";var pattern = /(.)hort/g;if (pattern.test(text))&#123; //可换成exec()，不反回ture/false。返回一个数组 alert(RegExp.input); //this has been a short summer alert(RegExp.leftContext); //this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); //short alert(RegExp.lastParen); //s alert(RegExp.multiline); //false 。IE，Chrome等不支持 alert(RegExp.$1); //$1~$9，自动存储匹配的捕获组，exec()和test()方法时自动填充。&#125; Function类型定义“函数是对象，函数名是指针”每个函数都是Function类型的实例，具有属性和方法。函数名不与某个函数绑定，只是一个指向函数对象的指针。 function sum(){…} 等于 var sum=function(){…}所以JS没有重载，声明同一个函数两次，函数名指向最后赋值的函数对象。 函数声明与函数表达式12345678910111213①alert(sum(10,10)); //20function sum(num1, num2)&#123; return num1 + num2;&#125; //不会报错。解析器会进行函数声明提升的过程，率先读取函数声明，并使其在执行任何代码之前可访问。②alert(sum(10,10)); var sum = function(num1, num2)&#123; return num1 + num2;&#125;; //报错，解析器进行到表达式时，sum才被保存对函数的引用。 作为值的函数12345678910111213141516171819202122function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var data = [&#123;name: "Zachary", age: 28&#125;, &#123;name: "Nicholas", age: 29&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //Nicholasdata.sort(createComparisonFunction("age"));alert(data[0].name); //Zachary 函数内部属性arguments.callee，指向拥有arguments对象的函数12345678910111213function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) ; //如果return num*factorial(num-1);，则代码和函数名紧耦合 &#125;&#125;var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;;alert(trueFactorial(5)); //120。代码执行不因函数名的指向而改变。 this，引用的是函数所在的执行环境。全局作用域中调用函数时，this引用的是window12345678window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redo.sayColor = sayColor;o.sayColor(); //blue caller，保存着调用当前函数的函数的引用，全局作用域中调用当前函数，它为null1234567function outer()&#123; inner();&#125; function inner()&#123; alert(arguments.callee.caller); //或inner.caller&#125;outer(); 函数属性和方法length，函数定义的命名参数的个数。function sum(num1,mum2){…} //length为2 apply()和call()，每个函数都包含两个非继承而来的方法，用途都是在特性的作用域中调用函数，可以设置函数体内this对象的值。apply(obj,[ … ])接收数组参数，call(obj,arg1,arg2…)接收连续参数 bind()创建一个函数的实例，this值绑定到传递给bind()函数的参数值。 12345678910function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); //this为window对象。arguments对象 //或者 sum.apply(this, [num1, num2]) //或者 sum.call(this,num1,num2)&#125;alert(callSum1(10,10)); //20 扩充函数赖以运行的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //bluevar objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型12var s1 = "text"; //string 是基本类型var s2 = s1.substring(2); //基本类型并不具有此方法 每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。相当于下面的过程 12345678s1 = new String('text');var s2 = s1.substring(2);s1 = null; //即刻销毁var o = new Object('text');alert(o instanceof Object); //truealert(o instanceof String); //turealert(typeof o); //object Boolean类型123456789var falseObject = new Boolean(false);var falseValue = false;var result = falseObject &amp;&amp; true;alert(result); //truealert(typeof falseObject); //objectalert(typeof falseValue); //booleanalert(falseObject instanceof Boolean); //truealert(falseValue instanceof Boolean); //false Number类型1234567891011121314151617var numberObject = new Number(10);var numberValue = 99;alert(numberObject.toString(2)); //"1010"alert(numberObject.toString(16)); //"a"alert(numberObject.toFixed(2)); //outputs "10.00"alert(numberObject.toExponential(2)); // 1.00e+1numberObject = new Number(99);alert(numberObject.toPrecision(1)); //"1e+2"alert(numberObject.toPrecision(2)); //"99"alert(numberObject.toPrecision(3)); //"99.0" alert(typeof numberObject); //objectalert(typeof numberValue); //numberalert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false String类型1234567var stringObject = new String("hello world");var stringValue = "hello world";alert(typeof stringObject); //"object"alert(typeof stringValue); //"string"alert(stringObject instanceof String); //truealert(stringValue instanceof String); //false 字符方法x.charAt()，x.charCodeAt() //字符编码，x[n]。 字符串操作方法concat()接受任意个参数，拼接返回新字符串1234567891011121314var stringValue = "hello world";alert(stringValue.slice(3)); //"lo world" 总长度作为结束位置alert(stringValue.slice(3, 7)); //"lo w"alert(stringValue.substring(3)); //"lo world"alert(stringValue.substring(3,7)); //"lo w"alert(stringValue.substr(3)); //"lo world"alert(stringValue.substr(3, 7)); //"lo worl" 第二个参数指定长度alert(stringValue.slice(-3)); //"rld" 将负的参数与总长度相加alert(stringValue.slice(3, -4)); //"lo w" alert(stringValue.substring(-3)); //"hello world" 将所有负参数转为0alert(stringValue.substring(3, -4)); //"hel" (3,0)=&gt;(0,3 )alert(stringValue.substr(-3)); //"rld" 将第一个负的参数与总长度相加alert(stringValue.substr(3, -4)); //"" 将第二个负的参数转为0 字符串位置方法12345var stringValue = "hello world";alert(stringValue.indexOf("o")); //4alert(stringValue.lastIndexOf("o")); //7alert(stringValue.indexOf("o", 6)); //7。从第二个参数往后搜索alert(stringValue.lastIndexOf("o", 6)); //4。从第二个参数往前搜索 trim()返回去除字符串两端空格的副本。 大小写转换12alert(stringValue.toUpperCase()); //"HELLO WORLD"alert(stringValue.toLowerCase()); //"hello world" 字符串的模式匹配方法 match()，本质上与调用RegExp的exec()方法相同。唯一参数，正则表达式。 1234567var text = "cat, bat, sat, fat"; var pattern = /.at/;var matches = text.match(pattern); alert(matches.index); //0alert(matches[0]); //"cat"alert(pattern.lastIndex); //0 search()，由开头向后查找，返回字符串中第一个匹配项的索引，如果没找到，返回-1。唯一参数，正则表达式。 var pos = text.search(/at/); //1 replace()，第一个参数，正则表达式或字符串，第二个参数字符串或者一个函数。 第一个参数为字符串，只替换第一个匹配项 12var result = text.replace("at", "ond");alert(result); //"cond, bat, sat, fat" 全局替换，使用正则表达式 12result = text.replace(/at/g, "ond");alert(result); //"cond, bond, sond, fond" 第二个参数为字符串，还可以使用一些特殊的字符序列 12result = text.replace(/(.at)/g, "word ($1)");alert(result); //word (cat), word (bat), word (sat), word (fat) $n，匹配的第n个捕获组 第二个参数，为函数。 split()第一个参数，分隔符字符串或RegExp。第二个参数，结果数组的大小。1234var colorText = "red,blue,green,yellow";var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]var colors2 = colorText.split(",", 2); //["red", "blue"]var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""] localeCompare()比较两个字符串在字母表中的位置。1234var stringValue = "yellow"; alert(stringValue.localeCompare("brick")); //1alert(stringValue.localeCompare("yellow")); //0alert(stringValue.localeCompare("zoo")); //-1 fromCharCode()接受一或多个字符编码。转换成一个字符串。 alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot; 单体内置类型Global对象URI编码encodeURI()，不会对本属于URI的特殊字符进行编码，如冒号，正斜杠问号和井号。encodeURIComponet()，对任何非标准字符进行编码。1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.htm#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"alert(encodeURIComponent(uri)); URI解码decodeURI()，只对非URI特殊字符解码。decodeURIComponet()，解码所以非标准字符。1234567var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri)); //http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); eval()像是一个完整的ECMAScript解析器，只接受一个参数。传入的参数当做实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码，被认为是包含调用的执行环境的一部分，因此被执行代码具有该执行环境相同的作用域链。但在eval()中创建的任何变量或函数都不会被提升。 eval(&quot;var msg=&apos;hello world&apos;;&quot;); alert(msg); //严格模式中会导致错误 Global对象的属性 window对象Web浏览器都是将Global对象作为window对象的一部分加以实现的。因此全局作用域中声明的所有变量和函数都成为了window对象的属性。 Math对象 min()和max()1234567var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3//想要直接传递数组，可以使用下面的技巧var arr=[3, 54, 32, 16];var max = Math.max.apply(Math,arr); 舍入方法12345alert(Math.ceil(25.1)); //26alert(Math.floor(25.9)); //25alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25 random()123456789function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10); //2-10的整数var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];var color = colors[selectFrom(0, colors.length-1)]; 对象理解对象属性类型ECMAScript中属性分两种：数据属性和访问器属性。“特性”描述了属性的各种特征，只为了实现JS引擎，不能直接访问。 数据属性 123456789var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, //只读属性 value: "Nicholas"&#125;);alert(person.name);person.name = "Michael"; //严格模式下，抛出错误alert(person.name); //Nicholas 一旦把属性定义为不可配置的，就不能再把它便回可配置了。再调用Object.defineProperty()修改除writable之外的特性，都将导致错误。 访问器属性不包含数据值，包含一对getter和setter函数。都不必需，可创建只读，只写属性。 123456789101112131415161718192021var book = &#123; _year: 2004, edition: 1&#125;; Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 定义/修改多个属性12345678910111213141516var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, //其他特性默认为false，undefined edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125; &#125;); 读取属性的特性123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //"undefined"var descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //"function" 创建对象构造函数模式1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; //弊端，每个对象的此属性指向不同方法对象 alert(this.name); &#125;; &#125;var person1 = new Person("Nicholas", 29, "Software Engineer");person1.sayName(); //"Nicholas"alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person1.constructor == Person); //true new 操作符，执行步骤：1，创建1个新对象。2，将构造函数的作用域赋给新对象，this就指向了这个新对象3，执行构造函数中的代码。4，返回新对象 如果直接调用构造函数，则和普通函数一样。 Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); //adds to window window.sayName(); //&quot;Greg&quot;。通过this，赋值给了window对象。 原型模式理解原型对象 每一个函数都有一个prototype属性，是一个指针，指向通过构造函数而创建的那个对象实例的原型对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。通过原型，可以把需要定义在构造函数中的实例信息，转移到原型对象中。 1234567function Person()&#123; &#125; Person.prototype.name = "Nicholas";Person.prototype.sayName = function()&#123; //每个实例的此属性指向同一方法 alert(this.name);&#125;; var person1 = new Person();person1.sayName(); //"Nicholas"。通过查找对象属性得过程来实现查找调用 确定对象间是否存在原型关系 alert(Person.prototype.isPrototypeOf(person1)); //true 取得[[Prototype]]的值 alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(person1.constructor.prototype == Person.prototype); //true 屏蔽原型属性 person1.name = &quot;Greg&quot;; alert(person1.name); //&quot;Greg&quot; 读取实例的属性时，先搜索实例本身，然后搜索原型对象。 删除实例属性，解除屏蔽。 delete person1.name; 检测属性是否存在于实例中 alert(person1.hasOwnProperty(&quot;name&quot;)); 原型与in操作符in操作符会在通过对象能够访问给定属性时返回ture，无论属性存在于实例或原型中 1234567var person1 = new Person(); alert(person1.hasOwnProperty("name")); //falsealert("name" in person1); //truefunction hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; //判断属性是否存在于原型中 使用for-in循环时，返回的是所有能通过对象访问的，可枚举（[[Enumerable]]）的属性。其中既包括实例中的属性和原型中的属性。屏蔽原型中不可枚举属性得实例属性也会在for-in循环中返回。 Object.keys()。接收一个对象，返回一个只包含在此实例中的所有可枚举属性的字符串数组。 12345var keys = Object.keys(Person.prototype);alert(keys); //"name,age,job,sayName"var p=new Person();var keys = Object.keys(p);alert(keys); //"" Object.getOwnPropertyNames()。接收一个对象，返回一个只包含在此实例中的无论是否可枚举的属性的字符串数组。 1234var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor,name,age,job,sayName"var keys = Object.getOwnPropertyNames(p);alert(keys); //"" 更简单的原型语法1234567function Person()&#123; &#125; Person.prototype = &#123; name : "Nicholas", sayName : function () &#123; alert(this.name); &#125;&#125;; 重写了prototype对象。因此constructor属性变成了Object构造函数，不在指向Person函数12345var friend = new Person(); alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //false。实际访问的是原型对象的constructor属性alert(friend.constructor == Object); //true 重设constructor属性 Person.prototype = { constructor: Person, ... }; 缺点：导致constructor属性的枚举特性为ture。改良如下： Object.defineProperty(Person.prototype，&quot;constructor&quot;，{ enumerable：false, value：Person })； 原型的动态性因为实例和原型之间的连接是一个指针，而非一个副本。创建实例后，对原型对象做的任何修改都能立即从实例上反应出来。如果先创建实例，又重写了其原型对象，则切断了新原型对象与实例的关系。实例指向的仍是原来的原型对象。 原生对象的原型123456alert(typeof Array.prototype.sort); //"function"alert(typeof String.prototype.substring); //"function"String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;; //给原生引用类型增加扩展方法（不推荐，容易引起冲突） 组合构造函数模式和原型模式组合两种模式，创建自定义类型。构造函数用于定义实例不同的属性，原型模式用于定义方法和共享的属性。 继承原型链 确定原型和实例之间的关系123456instance instanceof Object; //trueinstance instanceof SuperType; //trueinstance instanceof SubType; //trueObject.prototype.isPrototypeOf(instance); //trueSuperType.prototype.isPrototypeOf(instance); //trueSubType.prototype.isPrototypeOf(instance); //true 原型链的问题12345678910function SuperType()&#123; this.colors = ["red", "blue", "green"];&#125;function SubType()&#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"。所有子类型实例共享一个原型对象var instance2 = new SubType();alert(instance2.colors); //"red,blue,green,black"。所有子类型实例都受影响 组合继承1234567891011121314151617function SuperType(name)&#123; //父类型 私有属性 this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; //父类型 私有方法 alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //子类型 借用父类型构造函数，生成自己的私有属性（与父类型一致） this.age = age; //子类型 私有属性&#125;SubType.prototype = new SuperType(); //父类型实例作为子类型的原型，继承父实例原型的方法和实例属性。父实例的私有属性将被子实例相同的私有属性覆盖，而不再被子实例共享，避免篡改。SubType.prototype.sayAge = function()&#123; //子类型 私有方法 alert(this.age);&#125;;var instance1 = new SubType("Nicholas", 29); //拥有：父类型原型方法，子类型原型方法，子实例私有属性 优点：重用了父类型的方法，避免二次定义与父类型相同的属性缺点：实例了两次相同的属性，子实例覆盖了父实例创建的私有属性 原型式继承123456789101112function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; var person = &#123; //原型（基础）对象 name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = object(person); //传递父类型（非实例）进行浅复制，创建了2个副本，拥有相同的原型对象var yetAnotherPerson = object(person);anotherPerson.prototype.sayHello=function()&#123; ... &#125; //对子类型的扩展，并不影响父类型 ECMAScript 5 规范了原型式继承12345var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = Object.create(person); 寄生组合式继承1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); //创建一个中间层，继承了父类型的原型方法。 prototype.constructor = subType; //增强 subType.prototype = prototype; //子类型的原型引用此中间层，对子类型的扩展应用在此层上，并不影响父类型。&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //借用，避免二次定义相同的属性 this.age = age;&#125;inheritPrototype(SubType, SuperType); //应用中间层，继承父类型原型方法，且并不实例化父类型，避免实例后覆盖带来的浪费 SubType.prototype.sayAge = function()&#123; //扩展子类型 alert(this.age);&#125;; 函数表达式闭包一个函数，有权访问其他函数作用域变量对象的函数。 创建时，创建一个预先包含全局变量对象及外层变量对象的作用域链（根据函数是否引用外层函数的变量来决定是否加入外部函数的变量对象，未引用则外部函数的变量对象销毁），保存在内部的[[ Scope ]]属性中。 调用时，为此函数创建一个执行环境。 复制函数的[[ Scope ]]属性中的对象（指针）构建执行环境的作用域链。 创建次函数的活动对象（在此作为变量对象）并被推入执行环境作用域链的前端。 作用域链本质上是一个指向变量对象的指针列表。 闭包与变量12345678910111213141516function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; //创建，作用域链引用createFunctions的变量对象 return i; &#125;; &#125; //不存在块级作用域，变量i仍然存在，最终的值为10 return result;&#125; //被引用createFunctions的变量对象未销毁var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; document.write(funcs[i]() + "&lt;br /&gt;"); //调用函数，全部都返回createFunctions变量对象中的i变量，10&#125; 关于this对象this对象在运行时基于函数的执行环境绑定的。当函数作为某个对象的方法被调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。1234567891011121314var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function() &#123; ① return this.name; ③ var that=this; ② return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 作为对象的方法调用，this等于此对象。”My Obeject” 匿名函数，此时this表示window。”The Window” 。（内部函数搜索this和arguments变量时，只会搜索到其活动对象位置，不可能直接访问到外部函数中的这连个变量。） 把外部作用域中的this对象保存在一个闭包能够访问 到的变量，就可以让闭包访问此对象了。 特殊情况，123alert(object.getName()); //"My Object"alert((object.getName)()); //"My Object"alert((object.getName = object.getName)()); //"The Window" 非严格模式 第三行的赋值表达式等于函数本身，this没有得到保持，等于window对象。 闭包导致的内存泄漏IE9之前的版本对JS对象和COM对象使用不同的垃圾收集例程。BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。 123456function assign() &#123; var ele=document.getElementById('id'); ele.onclick=function()&#123; alert(ele.id); &#125;&#125; 循环引用，导致内存泄漏解决方案12345678function assign()&#123; var ele=document.getElementById('Id'); var id=ele.id; ele.onclick=function()&#123; alert(id); &#125; ele=null;&#125; 模仿块级作用域JS没有块级作用域的概念，在for或if中定义的变量，实际上是在包含函数中而非语句中创建的。 12345678function outputNumbers(count)&#123; (function () &#123; //内部为块级作用域 for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //出错&#125; 私有变量1234567891011function Person()&#123; //私有变量 var name; //特权方法 this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125; 静态私有变量1234567891011121314151617(function()&#123; var name = ""; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person("Nicholas"); var person2 = new Person("Michael");alert(person1.getName()); //"Michael"alert(person2.getName()); //"Michael" 模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); //初始化 return &#123; //匿名对象 getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125; &#125;;&#125;(); 增强模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); var app = new BaseComponent(); //属于某种类型 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125;; return app;&#125;(); BOMwindow对象全局作用域window对象扮演着Global对象的角色。定义在全局作用域中的变量都会成为window对象的属性区别： 123456var age = 29; //[[Configurable]]特性为falsewindow.color = "red";delete window.age; //false &lt;IE 9报错delete window.color; //true alert(window.age); //29alert(window.color); //undefined 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中（通过从0开始的数值索引或者框架名称来访问对应的window对象）。 top.frames[0] //top始终指向最高层的框架，也就是浏览器窗口 parent对象 //当前对象直接上层框架，如果没有框架的话。parent=top=window 窗口位置浏览器在屏幕左边和上边的位置。12var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY; 窗口大小页面大小，不包括工具栏等浏览器本身。123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS1Compat")&#123; //是否是标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 间歇调用和超时调用JS是单线程语言，一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JS任务队列，这些任务会按照它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行。否则它就要等前面的代码执行完了之后再执行。 系统对话框window.print() //调用打印窗口 window.find(&apos;xx&apos;) //查找页面是否包含&apos;字符串&apos;，返回ture/false location对象位置操作1234567location.hash = "sec1"; // http://..../#sec1 不刷新页面，跳转到页内锚记location.search = "q=22"; // http://..../?q=22#sec1 location.hostname = "www.yahoo.com"; // http://www.yahoo.com/?q=22#sec1 location.pathname = "mydir"; // http://..../mydir/t1/dd/?q=22#sec1location.port = 8080; // http://...:8080/mydir/t1/dd/?q=22#sec1location.replace("http://www.wrox.com/"); //不会产生历史记录，不能回到前一个页面location.reload([true]); //true，忽略浏览器缓存，强制从服务器重新加载 navigator对象浏览器及客户端系统相关信息 screen对象表示客户端的能力，包括浏览器窗口外部的显示器信息，如像素宽度和高度等。 history对象因history也是window对象的属性，因此每个浏览器窗口，每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 12345history.go(-1)history.go(1)history.go("www.baidu.com") //跳转到最近的baidu页面，可能前进，也可能倒退history.back()history.forward() DOM节点层次Node类型每个节点都有一个childNodes属性，保存着NodeList对象。NodeList是一种类数组对象，动态实时更新，使用时最好先缓存起来，可以通过索引[i]或者item(i)访问，也有length属性，但并不是Array的实例。可以通过 var arr=Array.protptype.slice.call(some.childNodes，0); 来进行转换成数组。 Node之间的关系 操作节点1234567var retNode=someNode.appendChild(someNode.firstChild)； //成为第二个节点var retNode=someNode.insertBefore(newNode,null); //插入为最后一个节点var retNode=someNode.insertBefore(newNode,someNode.firstChild); //插入成为第一个节点var retNode=someNode.replaceChild(newNode,someNode,firstChild); //替换第一个节点。该节点的所有关系指针都会被替换。var retNode=someNode.removeChild(someNode.firstChild); //移除第一个子节点var deepList=myList.cloneNode(true); //复制节点及整个子节点数var shallowList=myList.cloneNode(false); //只复制节点本身 Document类型包括HTML元素，HTML声明等。12345var html=document.documentElement; //HTML元素html==document.childNodes[0]; //truehtml==document.firstChild; //truevar body=document.body; //body的引用var doctype=document.doctype; //&lt;!DOCTYPE&gt;的引用 在jQuery的$(function(){ … });页面加载事件里，this对象引用的即为Document对象。且直接通过var 声明的变量不会成为Document对象的属性(与全局作用域不同，如全局声明var变量，此变量即成为window对象的属性)。 文档信息1234567document.title='new title';var url=document.url;var domain=document.domain;var referrer=document.referrer;images.nemedItem('name'); 或iamges["name"] //取得HTMLCollection对象中name为'name'的元素 特殊集合1234document.anchores，带name的a元素document.links，带href的a元素document.forms，所有form元素document.images，所有img元素 一致性检测document.implementation对象，DOM1级只为此对象规定了一个方法，hasFeature()。传入两个参数，要检测的DOM功能名称和版本号。 var hasXmlDom=document.implementation.hasFeature(&apos;XML&apos;,&apos;1.0&apos;); Element类型特征1234nodeType //1nodeName/tagName //标签名nodeValue //nullparentNode HTML元素HTMLElement，所有HTML元素都是HTMLELment活它的子类型表示。继承了Element的属性，新增了部分属性：id，title，lang，dir(语言方向,类似text-align)，className(所有class)。 操作特性1234var div=document.getElementById('my');div.getAttribute('id');div.setAttribute('class','123');div.removeAttribute('name'); 直接通过属性名访问和getAttribute()方法得到的结果不一样的两种特性：style，get得到的CSS文本，属性访问得到对象，用于访问元素样式。事件，onclick等，get访问代码文本，属性访问得到function对象。 attributes属性包含一个NamedNodeMap“动态”集合，拥有下列方法：1234getNamedItem(name) //返回指定nodeName(tagName)的节点removedNamedItem(name) //从列表移除指定nodeNamesetNamedItem(node) //向列表添加节点item(id) //返回位于数字id处的节点 取值 ele.attributes[&apos;age&apos;].nodeValue 创建元素1234var div = document.createElement("div");div.id = "myNewDiv";div.className = "box";document.body.appendChild(div); 动态创建的元素特点：不能通过表单reset，与已有同name单选框无关系。 元素的子节点ele.childNodes 除了IE，其他浏览器会把各子元素之间的回车等空白也计算为一个节点。所以需要遍历子元素时，需要判断元素类型。123if(chiEle.nodeType==1)&#123; //do some&#125; Text类型特征123456nodeType //3nodeName //#textnodeValue //节点文本parentNode //Element没有子节点length属性 方法123appendData(txt)，deleteData(offset,count)，insertData(offset,count,text)，replaceData(offset,count,text)，splitText(offset)，substringData(offset,count) 创建document.createTextNode(&apos;&lt;strong&gt;Hello&lt;/strong&gt;&apos;); Comment类型特征12345nodeType //8nodeName //'#comment'nodeValue //注释的内容parentNode //Document或Element无子节点 CDATASection类型特征123456只针对XML文档，CDATA区域。与Comment类似，继承自Text类型nodeType //4nodeName //#cdata-sectionnodeValue //CDATA区域的内容parentNode //Document或Element无子节点 DocumentType类型很少有浏览器支持。表示文档类型，对应&lt;!DOCTYPE&gt;等。 Attr类型元素的特性 DOM操作技术动态脚本页面加载时不存在，将来通过修改DOM动态添加的脚本。 外部引用 1234567function addScript()&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.text = "function sayHi()&#123;alert('hi');&#125;"; document.body.appendChild(script); sayHi();&#125; 行内方式 12345678910function loadScriptString(code)&#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; //IE特定，不支持对Script添加子节点 &#125; document.body.appendChild(script);&#125; 动态样式 外部引用 1234567function addStyle()&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;)); //error in IE var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 嵌入方式 1234567891011function loadStyleString(css)&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex)&#123; style.styleSheet.cssText = css; //IE &#125; var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 选择符API使用CSS选择符查询匹配的DOM元素。 querySelector()接受一个CSS选择符，返回与该模式匹配的第一个元素，没找到则返回null。 1234var body = document.querySelector("body");var myDiv = document.querySelector("#myDiv");var selected = document.querySelector(".selected");var img = document.body.querySelector("img.button"); querySelectorAll()返回所有匹配的元素，一个NodeList实例（此方法返回的实际上是一组元素的快照，避免不断动态查询带来的性能影响）。没有匹配则返回一个空的NodeList。1234var ems = document.getElementById("myDiv").querySelectorAll("em");var selecteds = document.querySelectorAll(".selected");var strongs = document.querySelectorAll("p strong");var s1=strongs[0]; matchesSelector()如果调用元素与该选择符匹配，返回ture，否则返回false。123if (matchesSelector(document.body, "body.page1"))&#123; alert("It's page 1!");&#125; 支持不完善，需要做跨浏览器兼容。12345678910111213function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error("Not supported."); &#125;&#125; 元素遍历对于元素见得空格，IE9及之前版本不会返回文本节点，其他浏览器都会返回文本节点。子节点查询的元素版：childElementCount属性，子元素（不含文本和注释节点啊）个数。firstElementChild，lastElementChild，previousElementSibling，nextElementSiblingchildren属性，HTMLCollection实例，只包含元素子节点。childNodes的元素版。 跨浏览器兼容123456789101112if (document.body.firstElementChild)&#123; var i, len, child = document.body.firstElementChild; while(child != document.body.lastElementChild)&#123; document.write("&lt;p&gt;" + child.tagName + "&lt;/p&gt;"); child = child.nextElementSibling; &#125;&#125; else &#123; document.write("&lt;p&gt;Element Traversal API not supported.&lt;/p&gt;");&#125; HTML5document.head，head部分引用document.charset，字符集 类的扩充getElementsByClassName() 所有元素都可调用12345classList //DOMTokenListadd(value) //添加或忽略contains(value) //是否包含remove(value) //删除toggle(value) 滚动scrollIntoView() 任何元素可调用，出现在视口中。传入true或不传，顶部与视口对齐。传入false，底部对齐。 DOM2和DOM3变化Node类型localName，不带命名空间前缀的节点名称namespaceURI，不带命名空间前缀的节点名称prefix，命名空间或者null Document类型新增了带NS后缀的方法，表示特定命名空间下的操作，比如：createElementNS(ns,tagName)：创建属于ns命名空间的元素createAttributeNS(ns,attr)：使用给定attr创建一个ns命名空间的新特性getElementsByTagNameNS(ns,tagName)：返回特定命名空间的元素NodeList 元素大小偏移量 某个元素在页面上的偏移量计算：12345678910function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 客户区大小 元素内部空间大小，因此滚动条占用的空间不计算。确定浏览器视口大小： document.documentElement.clientWidth //document.body代表body，document.documentElement //代表html标签 滚动大小scrollHeight，没有滚动条的情况下，元素总高度scrollWidth，同上，元素内容总宽度scrollLeft，被隐藏在内容区域左侧的像素数。设置可以改变元素滚动位置scrollTop，上方的元素，设置可以改变元素滚动位置(需要设置overflow属性才能滚动) 确定文档的总高度时，必须获得scrollHeight/clientHeight中的最大值，才能跨浏览器得到准确的结果。 Math.max(ducment.documentElement.scrollHeight,document,documentElement.clientHeight) 遍历TreeWalker12345678910111213141516function makeList() &#123; var div = document.getElementById("div1"); var filter = function(node)&#123; return (node.tagName.toLowerCase() == "li") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;; var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false); var output = document.getElementById("text1"); var node = walker.nextNode(); while (node !== null) &#123; output.value += node.tagName + "\n"; node = walker.nextNode(); &#125;&#125; NodeFilter.FILTER_SKIP，跳过节点前进道子树种的下一个节点NodeFilter.FILTER_REJECT，跳过节点及该节点整个子树。walker可以眼任何方向移动 walker.firstChild(); walker.nextSibling(); walker.currentNode，当前节点。 范围 事件事件流 事件处理程序需DOM0级事件处理程序1234bar btn=document.getElementById('my');btn.onclick=fuction()&#123; alert(this.id);&#125;; DOM0级方法指定的事件处理程序被认为是元素的方法，在元素的作用域中运行，this引用当前元素。 DOM2级事件处理程序1234var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); false，冒泡阶段调用，true，捕获阶段调用。作用域同DOM0级方法一样。好处是，可以添加多个事件处理程序，且按添加顺序执行。 通过此方法添加的事件只能使用removeEventListener()移除，传入的参数与添加时使用的参数相同(同一个函数对象)，所以通过addEventListener()添加的匿名函数将无法移除。 事件对象所有事件都会有的成员 12345document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById("myBtn")); //true&#125;; 事件类型 UI事件 在window上发生的任何事件都可以在body元素上通过相应的特性来指定，因为HTML无法访问window元素，为了向后兼容例：window的load事件， unload事件兼容性很不好，chrome不会显示文本，IE显示乱码12345EventUtil.addHandler(window, "beforeunload", function(event) &#123; var msg = "will you leave？"; event.returnValue = msg; return msg;&#125;); scroll事件document.body.scrollTop获取滚动高度。火狐使用document.documentElement.scrollTop。 焦点事件 鼠标与滚轮事件 客户区(可视)坐标 event.clientX和event.clientY 页面坐标 event.pageX，event.pageY 屏幕坐标 event.screenX，event.screenY 修改键 e.shiftKey，e.ctrlKey，e.altKey，e.metaKey。布尔值，代表是否按下了相应按键，支持同时按。 关联元素 e.relatedTarget，只对mouseover和mouseout事件才包含值，代表与target发生关系的元素。 鼠标按钮 e.button，按下或释放的按钮。0，主按钮，1，滚轮，2，次按钮。 滚轮事件 mousewheel，任何元素上出发，最终会冒泡到document或window对象。event对象包含一个特殊的wheelDelta属性，向前滚动wheelDelta是120的倍数，向后滚动wheelDelta是-120的倍数。 触摸设备 键盘与文本事件keydown，按下键盘上任意键时触发，按住不放会重复触发。keypress，按下奸商上字符键时触发，按住不放会重复触发。keyup，释放键盘上的键时触发keydown-&gt;keypress-&gt;keyup。支持4个修改键。键码，event.keyCode，表示触发keydown或keyup事件特定的键，如回车-13，空格-32。字符编码，event.key，事件产生的相应文本字符或键名。 文本事件textInput。按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发。event.data，实际输入的字符文本。event.inputMethod，代表文本是如何输入到控件中的，从而验证有效性（只有IE支持）。 HTML5事件contextmenu事件windows中，右键单击。Mac，Ctrl+单击。冒泡，可以为document指定一个事件处理程序自定义右键菜单。 12345678910document.oncontextmenu=function(event)&#123; event.preventDefault() var menu = document.getElementById("myMenu"); menu.style.left = event.clientX + "px"; menu.style.top = event.clientY + "px"; menu.style.visibility = "visible";&#125;;document.addEventListener('click',function()&#123; document.getElementById("myMenu").style.visibility = "hidden"; //隐藏右键菜单&#125;); beforeUnload事件必须添加给window对象。firefox和opera不支持。chrome不显示message。123456EventUtil.addHandler(window, "beforeunload", function(event)&#123; event = EventUtil.getEvent(event); var message = "I'm really going to miss you if you go."; event.returnValue = message; return message;&#125;); DOMContentLoaded事件DOM树加载完毕之后触发，不理会图片，js，css等。 pageShow，pageHide事件必须添加给window对象。pageShow在load后触发，pageHide在unload之前触发。兼容性不好。 hashchange事件必须添加给window对象。url发生变化时触发，包含oldURL和newURL两个属性。 设备事件只在移动设备上实现。 orientationchange事件横向纵向查看模式。只有Safari支持 deviceorientation事件123456EventUtil.addHandler(window, "deviceorientation", function(event)&#123; var output = document.getElementById("output"); var arrow = document.getElementById("arrow"); arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)"; output.innerHTML = "Alpha=" + event.alpha + ", Beta=" + event.beta + ", Gamma=" + event.gamma + "&lt;br&gt;";&#125;); devicemotion事件12345678EventUtil.addHandler(window, "devicemotion", function(event)&#123; var output = document.getElementById("output"); if (event.rotationRate !== null)&#123; output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" + event.rotationRate.beta + ", Gamma=" + event.rotationRate.gamma; &#125;&#125;); 触摸和手势事件触摸事件都会冒泡。 Touch对象包含：identifier，唯一ID，clientX/Y，pageX/Y，screenX/Y，target，触摸的DOM节点。 12345678910111213141516171819202122function handleTouchEvent(event)&#123; //只触发一次 if (event.touches.length == 1)&#123; var output = document.getElementById("output"); switch(event.type)&#123; case "touchstart": output.innerHTML = "Touch started (" + event.touches[0].clientX + "," + event.touches[0].clientY + ")"; break; case "touchend": output.innerHTML += "&lt;br&gt;Touch ended (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; case "touchmove": event.preventDefault(); //阻止滚动 output.innerHTML += "&lt;br&gt;Touch moved (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; &#125; &#125;&#125;document.addEventListener("touchstart", handleTouchEvent, false);document.addEventListener("touchend", handleTouchEvent, false);document.addEventListener("touchmove", handleTouchEvent, false); 模拟事件模拟鼠标事件1234var event = document.createEvent("MouseEvents");event.initMouseEvent("click", true, true, document.defaultView, 0, 100, 0, 0, 0, false, false, false, false, 0, btn2);btn.dispatchEvent(event); 模拟键盘事件1234567891011121314151617181920212223242526EventUtil.addHandler(btn, "click", function(event)&#123; var event; //DOM Level 3 if (document.implementation.hasFeature("KeyboardEvent", "3.0"))&#123; event = document.createEvent("KeyboardEvent"); event.initKeyboardEvent("keydown", true, true, "a", 0, "Shift"); &#125; else &#123; try &#123; //Firefox event = document.createEvent("KeyEvents"); event.initKeyEvent("keydown", true, true, document.defaultView, false, false, true, false, 65, 65); &#125; catch (ex)&#123; //others event = document.createEvent("Events"); event.initEvent("keydown", true, true); event.view = document.defaultView; event.altKey = false; event.ctrlKey = false; event.shiftKey = false; event.metaKey = false; event.keyCode = 65; event.charCode = 65; &#125; &#125; textbox.dispatchEvent(event);&#125;); 表单脚本选择框脚本：HTMLOptionElement对象，属性有：index，label，selected，text，value。 取得选择的option，select.options[select.selectedIndex];选择，select.option[0].selected = true; 对其他option无影响。select.selectedIndex = 0，影响多选框其他option。 JSONJSON序列化：1234567891011121314151617181920var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == "releaseDate")&#123; return undefined; &#125; else &#123; return value; &#125;&#125;);var jsonText = JSON.stringify(book, ["title", "edition"], 4); //只序列化字段，格式化缩进个数var jsonText = JSON.stringify(book, null, "--"); //缩进占位符var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON: function()&#123; return this.title; &#125; &#125;; AjaxXHR默认头部信息 发送请求通过setRequestHeader()设置自定义头部，jQuery方式：12345678910$.ajax(&#123; type: "GET", url: "...", beforeSend: function(request) &#123; request.setRequestHeader("Test", "content"); &#125;, success: function(result) &#123; alert(result); &#125;&#125;); XHR2级FormData1234567891011121314151617181920212223242526272829var data = new FormData();data.append("file" , files[i]);var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(event)&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "FileAPIExample06Upload.php", true);xhr.send(data);var formData = new FormData();var upload = document.getElementById('file');if (upload.files.length &gt; 0) &#123; formData.append('upload', upload.files[0]); $.ajax(&#123; url: '/Customers/Import', method: 'POST', data: formData, contentType: false, processData: false, cache: false, success: function (data) &#123;&#125; &#125;);&#125; 进度事件123456789var xhr = createXHR();xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize + " bytes"; &#125;&#125;;xhr.open("get", "altevents.php", true); xhr.send(null); 跨域XHR对象，默认只能访问与它同一个域中的资源。CORS：发送请求时，需要添加一个额外的Origin头部，Origin：http://www.xxx.com。服务器如果任何请求，就在Access-Control-Allow-Origin头部中挥发相同的源（如果不需要跨域保护，可会回发 *），例如Access-Control-Allow-Origin：http://www.xxx.com大部分浏览器默认实现CORS的原声支持，访问时，使用绝对URL即可。但跨域XHR对象也有一些限制：不能自定义头部，不能发送和接受cookie，获取自定义头部总会返回空 其他跨域技术图像Ping，JSONP，Comet，Web sockets。 WebSockets在一个单独的持久链接上提供全双工、双向通信。第一次取得服务器响应后，建立的链接会从HTTP协议升级成Web Socket协议（需要服务器支持）。 Web Sockets协议：’ws://‘和’wss://‘（加密）。1234567891011121314151617var socket = new WebSocket('ws://www.xxx.com/handler'); // 不受同源策略影响，可以跨域// readState 属性：WebSocket.CONNECTING(0) / OPEN(1) / CLOSING(3) / CLOSED(2)socket.send('xxx'); //只能发送纯文本，发送复杂数据结构，需要先序列化socket.onmessage = function(event)&#123; // 获取服务器消息 var data=event.data; &#125;socket.close() //关闭链接 ，状态由2到3WebSocket事件：不支持DOM2级事件侦听器，必须使用DOM0级语法定义事件。socket.onopen = function()&#123;&#125;;socket.onerror = function()&#123;&#125;;socket.onclose = function(e)&#123; // e.wasClean 是否明确关闭 // e.code 服务器返回码 // e.reason 服务器发回的消息&#125;; 高级技巧高级函数安全的类型检测检测是否为数组/函数/正则表达式： Object.prototype.toString.call(obj) == &apos;[object Array]&apos;/&apos;[object Function]&apos;/&apos;[object RegExp]&apos;; 作用域安全的构造函数假设一个构造函数没有搭配new 关键词而调用，那么this默认绑定到window对象，则可能导致意外的错误。123456789function Person(name, age, job)&#123; if (this instanceof Person)&#123; //判断是否为指定类型的对象，再进行操作 this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125; 函数绑定绑定后返回一个函数，无论再对此函数调用什么apply或call改变this的引用，都不会改变执行结果handleClick.bind(obj)。123456function bind(context)&#123; var fn=this; return function()&#123; return fn.apply(context, arguments); &#125;;&#125; 柯里化使用闭包创建一个已经设置了部分参数的函数。123456789101112131415function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments), finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125;function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); //8 bind的柯里化实现123456789var handler = &#123; message: "Event handled", handleClick: function(name, event)&#123; alert(this.message + ":" + name + ":" + event.type); &#125;&#125;;var btn = document.getElementById("my-btn");EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler, "my-btn")); //第一个参数是绑定的this，第二个参数开始是预设置的参数。 防篡改对象不可扩展1234var person = &#123; name: "Nicholas" &#125;;Object.preventExtensions(person);alert(Object.isExtensible(person)); //falseperson.age = 29; 静默失败undefined，严格模式抛出异常 密封不可扩展，[[Configurable]]特性被设置为false，不能删除属性和方法。但是属性值是可以修改的。1234567var person = &#123; name: "Nicholas" &#125;;Object.seal(person);alert(Object.isSealed(person)); //trueperson.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas" 冻结最严格。及不可扩展，又是密封的，对象的[[Writable]]特性被设置为false，如果定义了[[Set]]，则访问器属性仍是可写的。1234567891011var person = &#123; name: "Nicholas" &#125;;Object.freeze(person);person.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas"person.name = "Greg";alert(person.name); //"Nicholas"alert(Object.isExtensible(person)); //falsealert(Object.isSealed(person)); //truealert(Object.isFrozen(person)); //true 分隔执行过程当执行数据量过大，为避免造成JS线程一直在进行中，导致UI线程被卡住。推荐对数据分割处理123456789101112131415161718var data = [12,123,1234,453,436,23,23,5,4123,45,346,5634,2234,345,342];function chunk(array, process, context)&#123; // context可选的 setTimeout(function()&#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0)&#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100); // 100毫秒 给线程一个协调的时间&#125;function printValue(item)&#123; var div = document.getElementById("myDiv"); div.innerHTML += item + "&lt;br&gt;"; &#125;chunk(data.concat(), printValue); // 不想改变原数组的数据，可以使用concat或slice创建一个副本 函数节流一些会被反复执行的事件，如果频率太高容易导致浏览器挂起或崩溃。需要对该函数进行节流适用于resize事件或over事件等。123456789101112131415function throttle(method, scope) &#123; // 可选的scope return function() &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(scope); &#125;, 100); &#125;&#125;function resizeDiv() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;window.onresize = throttle(resizeDiv); 自定义拖动功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function DrapDrop() &#123; var drag var dragging = null; var diffLeft, diffTop, diffRight, diffBottom; var count = 0; function handlerEvent(event) &#123; var target = event.target; switch (event.type) &#123; case 'mousedown': if ($(target).hasClass('draggable')) &#123; dragging = target; diffLeft = event.clientX - target.offsetLeft; diffTop = event.clientY - target.offsetTop; diffRight = target.clientWidth - diffLeft; diffBottom = target.clientHeight - diffTop; console.log(event.clientX, target.offsetLeft) &#125; break; case 'mousemove': if (dragging != null) &#123; var parentWidth = target.offsetParent.clientWidth; var parentHeight = target.offsetParent.clientHeight; var left, top; if (event.clientX - diffLeft &lt;= 0 || event.clientX + diffRight &gt;= parentWidth) &#123; if (event.clientX - diffLeft &lt;= 0) left = 0; if (event.clientX + diffRight &gt;= parentWidth) left = parentWidth - target.clientWidth; &#125; else &#123; left = event.clientX - diffLeft; &#125; if (event.clientY - diffTop &lt;= 0 || event.clientY + diffBottom &gt;= parentHeight) &#123; if (event.clientY - diffTop &lt;= 0) top = 0; if (event.clientY + diffBottom &gt;= parentHeight) top = parentHeight - target.clientHeight; &#125; else &#123; top = event.clientY - diffTop; &#125; dragging.style.left = left + 'px'; dragging.style.top = top + 'px'; &#125; break; case 'mouseup': dragging = null; break; &#125; &#125; return &#123; enable: function() &#123; document.addEventListener('mousedown', handlerEvent) document.addEventListener('mousemove', handlerEvent) document.addEventListener('mouseup', handlerEvent) &#125;, disable: function() &#123; document.removeEventListener('mousedown', handlerEvent) document.removeEventListener('mousemove', handlerEvent) document.removeEventListener('mouseup', handlerEvent) &#125; &#125;&#125; 离线应用和客户端存储离线应用离线检测navigator.onLine 离线事件123456EventUtil.addHandler(window, "online", function()&#123; document.getElementById("status").innerHTML = "Online";&#125;);EventUtil.addHandler(window, "offline", function()&#123; document.getElementById("status").innerHTML = "Offline";&#125;); 数据存储cookie限制：存在客户端计算机上，每个域最多几十个。只能保存单一文本，总共最大尺寸4k。 属性：key，名称，必须经过URL编码value：值，必须经过URL编码域：在某些域下才有效并携带发送到服务器。（.baidu.com对baidu.com的所有子域都有效）路径：指定路径有效并携带。（http://www.baidu.com/news/，跟路径则不会发送cookie）失效时间：时间戳，什么时候删除cookie。安全标志：secure（非名值对儿），只有在SSL链接下才发送。 Set-Cookie: name=value; domain= .wrox.com; path=/; secure Http专有cookie可以从浏览器和服务器设置，但是只能从服务器端读取，JS无法获取。 Web StorageStorage类型clear()：清空所有值getItem(name)：获取name的值key(index)：获取index处值的名称removeItem(name)：删除setItem(name,value)：设置PS：只能存储字符串 sessionStorage对象会话存储，存储某个特定会话的数据，保持到浏览器关闭。sessionStorage中的数据只能由最初设置的页面访问，不能跨页面 localStorage对象限制：同一来源有效，即同一个域（子域名无效），同一种协议，同一个端口。每个来源2~5MB大小限制。有效期：一直存在，直到JS删除或用户清楚缓存 IndexedDB替代了Web SQL Database API。保存结构化数据的一种数据库。操作完全是异步进行，因此，大多数操作会以请求的方式进行，异步返回成功结果或失败错误。限制：不能跨域，必须同源（域，协议，端口），大小5MB左右。 获取：（因为浏览器厂商提供的API都有前缀） var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778(function() &#123; var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB, // 消除厂商差异 IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction, // 定义事务的访问模式 IDBCursor = window.IDBCursor || window.webkitIDBCursor, IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange, request, store, database, users = [&#123; username: "007", firstName: "James", lastName: "Bond", password: "foo" &#125;, &#123; username: "ace", firstName: "John", lastName: "Smith", password: "bar" &#125;, &#123; username: "foobar", firstName: "Michael", lastName: "Johnson", password: "secret" &#125;]; request = indexedDB.open("example"); request.onerror = function(event) &#123; alert("Something bad happened while trying to open: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; database = event.target.result; initializeDatabase(); &#125;; function initializeDatabase() &#123; if (database.version != "1.0") &#123; // 默认无版本，最好先定义版本，避免产生不同的版本 request = database.setVersion("1.0"); request.onerror = function(event) &#123; alert("Something bad happened while trying to set version: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; store = database.createObjectStore("users", &#123;keyPath: "username"&#125;); // 定义对象存储空间和主键 users.forEach(function(user) &#123; store.add(user); // 如果主键重复了，add返回错误，put直接覆盖。 // get取得值，delete删除对象，clear删除所有对象 &#125;); outputValues(); &#125;; &#125; else &#123; outputValues(); &#125; &#125; function outputValues() &#123; // 事务组织所有的操作 var store = database.transaction("users", IDBTransaction.READ_WRITE).objectStore("users"), index = store.createIndex("username","username",&#123;unique:false&#125;); // 取得索引 sotre.index("username") range = IDBKeyRange.bound("007", "ace", false, false), // 指定游标范围。下界，上界，是否跳过下，上 request = store.openCursor(range, IDBCursor.PREV); // 指定游标的方向。NEXT/NEXT_NO_DUPLICATE request.onsuccess = function(event) &#123; var cursor = event.target.result; if (cursor) &#123; // 必须要检查 console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value)); cursor.value.password = 'xxx'; var updateRequest = cursor.update(cursor.value); // 请求更新 // cursor.delete() 删除当前项 cursor.continue(); // 移动到下一项，可以指定key // cursor.advance(count) 移动指定位数 &#125; else &#123; console.log("Done!"); &#125; &#125;; request.onfailure = function(event) &#123; console.error("Iteration did not succeed."); &#125;; &#125;&#125;)(); 最佳实践性能优化避免不必要的属性查找访问数组元素是一个O(1)的操作，访问对象的属性则是O(n)的操作。避免多次查找统一属性，可以先存储起来。 优化循环 减值迭代，从最大值到0，更高效。 简化终止条件，避免属性查找或O(n)的操作。比如：i&lt;arr.length。 简化循环体。 使用do-while，避免最初的终止条件计算。 Duff装置仅在处理大数据集时使用，更加高效。12345678910111213141516171819var arr = []var iterations = Math.floor(arr.length / 8);var leftover = arr.length % 8;var i = 0;if (leftover &gt; 0) &#123; do &#123; process(arr[i++]); &#125; while (--leftover &gt; 0);&#125;do &#123; process(arr[i++]); //循环再开，比单纯的循环调用更加高效 process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]);&#125; while (--iterations &gt; 0); 最小化语句数多个声明合一，更高效： var count=5, color=&apos;red&apos;, arr=[1,2,3]; 初始化数组和对象时使用字面量var arr=[1,2,3]; var obj={age:20}; 优化DOM交互 最小化更新DOM次数。 使用innerHTML，一次性更新。 使用事件代理，利用事件冒泡，在祖先节点上处理事件。减少事件绑定数量。 减少使用HTMLCollection对象 getElementByxxx()，childNodes，attributes，document.forms，document.images等都会返回HTMLCollection，每次访问它的属性时都会在文档上进行实时的查询，开销昂贵。 其他 原生方法更快 switch语句更快 位运算符更快 新兴的API这些API都不在H5的规范中，只是与H5相关。 Page Visibility API探测页面是否最小化或者隐藏在其他标签后面。方便资源的暂停。 var isHide = document.hidden || document.msHidden || document.webkitHidden; document.visibilityState：4种表示不同状态的值 visibilitychange事件EventUtil.addHandler(document, &quot;msvisibilitychange&quot;, handleVisibilityChange); EventUtil.addHandler(document, &quot;webkitvisibilitychange&quot;, handleVisibilityChange); Geolocation API获得用户当前地理位置，需要用户授权。12345678910111213navigator.geolocation.getCurrentPosition(function(position)&#123; // position.coords对象有以下属性：latitude 维度，longitude 经度，accuracy 单位 &#125;, function(error)&#123; // error.message &#125;);var id = navigator.geolocation.watchPosition(function(position) &#123; // 方法第一次会取得当前位置，然后在系统发生位置改变时被调用&#125;, function(error) &#123; //&#125;);clearWatch(id); //取消追踪 File APIFileReaderFile类型，包含name,size,type属性。event.files12345678910111213141516171819202122232425262728293031323334353637var filesList = document.getElementById("files-list");EventUtil.addHandler(filesList, "change", function(event)&#123; var info = "", output = document.getElementById("output"), progress = document.getElementById("progress"), files = EventUtil.getTarget(event).files, type = "default", reader = new FileReader(); if (/image/.test(files[0].type))&#123; reader.readAsDataURL(files[0]); type = "image"; &#125; else &#123; reader.readAsText(files[0]); type = "text"; &#125; reader.onerror = function()&#123; output.innerHTML = "Error code :" + reader.error.code; //1,未找到。2,安全错误。3,读取中断。4,文件不可读。5,编码错误 &#125;; reader.onprogress = function(event)&#123; if (event.lengthComputable)&#123; progress.innerHTML = event.loaded + "/" + event.total; &#125; &#125;; reader.onload = function()&#123; var html = ""; switch(type)&#123; case "image": html = "&lt;img src=\"" + reader.result + "\"&gt;"; break; case "text": html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;); 部分读取返回blob类型（file的父类型）12345678910111213function blobSlice(blob, startByte, length)&#123; if (blob.slice)&#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice)&#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice)&#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125;var blob = blobSlice(files[0], 0, 32); 对象URLbloblURL，指向一块内存地址1234567891011function createObjectURL(blob)&#123; if (window.URL)&#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL)&#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125;var url = createObjectURL(files[0]);output.innerHTML = "&lt;img src=\"" + url + "\"&gt;"; 文件拖放并上传1234567891011121314151617181920212223242526272829303132333435var droptarget = document.getElementById("droptarget");function handleEvent(event)&#123; var info = "", output = document.getElementById("output"), data, xhr, files, i, len; EventUtil.preventDefault(event); if (event.type == "drop")&#123; data = new FormData(); files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; data.append("file" + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open("post", "xxx", true); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; alert(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, "dragenter", handleEvent);EventUtil.addHandler(droptarget, "dragover", handleEvent);EventUtil.addHandler(droptarget, "drop", handleEvent); //取消dragenter、dragover和drop的默认行为 Web workers使用worker使用后台线程/进程执行复杂的运行实现异步。如加/解密，图片处理等 123456789var data = [23,4,7,9,2,14,6,651,87,41,7798,24],worker = new Worker("WebWorkerExample01.js");// 下载js文件，但并不立即执行worker.onmessage = function(event)&#123; console.log(event);&#125;;worker.postMessage(data); // 可以传递文本，也可以传递对象（副本）worker.terminate(); // 终止worker worker中12345678910111213self.onmessage = function(event)&#123; var data = event.data; data.sort(function(a, b)&#123; return a - b; &#125;); self.postMessage(data);&#125;;self.onerror = function(event)&#123; // event.filename // event.lineno // event.message&#125;self.close(); // 停止工作 全局方法importScripts(&quot;com1.js&quot;,&quot;com2.js&quot;); // 异步加载。按顺序执行。 worker全局作用域worker单独一个作用域，不能访问DOM元素和标签。this引用的是worker对象。限制版本的navigator对象。制度的location对象。setTimeout()、setInterval()、clearTimeout()、clearInterval()方法XMLHttpRequest函数。 工具 链接 描述 client.js 浏览器及版本检测工具 EventUtil.js 跨浏览器事件处理工具 CookieUtil.js cookie操作工具 EventTarget.js 自定义事件操作工具 richtext.html 自制富文本编辑器]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通C#_注释笔记]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%B2%BE%E9%80%9AC_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言，然而，IL却包含一些抽象概念(比如：类、异常)，这也是这种语言被称为中间语言的原因。IL被打包在DLL或EXE文件中，而DLL和EXE在.NET中的主要区别就是：只有EXE可以直接被运行，而二者都可被某个正在执行的进程动态装载。由于机器的CPU只能执行本地汇编语言，而不是IL，进一步将IL编译成汇编语言的工作(也就是第二阶段)需要在运行时进行，这个过程由即时编译器(JIT)完成。 高级语言在初次被编译时，编译器做两件事：首先把编译得到的IL存储在DLL或EXE中，然后为类的每个方法创建一个stub函数，此函数会调用即时编译器，并将自身的地址作为参数传给编译器。即时编译器则从DLL或EXE中获取相应的IL，编译成机器语言，并将内存中的原零时调用函数替换成机器语言。这个过程的思想，是用已编译的方法调用未编译的方法，实质上被调用的是stub函数；stub函数再调用编译器，将自身编译为本地机器语言；最后，.NET会重新调用该方法，方法此时才被真正地执行。函数被反复调用时，机器指令会被直接执行，而只由编译器对方法进行初次编译需要花费时间。至于那些没有被调用的方法，则不会被编译。 当编译器生成一个EXE文件后， 该程序的入口函数为Main() 方法。装载器将这个EXE 文件载入，探测到该这是一个托管EXE，于是又载入 .NET运行时库文件(包括即时编译器)， 接着调用了EXE 的Main() 方法。这将触发对Main()方法的即时编译， Main()方法在内存中被替换为本地机器语言，于是 .NET应用程序开始运行。在被编译为本地语言后，应用程序便可以自由调用本地代码了。当程序中止时，本地代码从内存中释放，所以在下次运行时，IL需要被即时编译器重新编译。 CTS类型规范，规定了类型必须如何定义才能被CLR承载。內建的CTS数据类型： CLS不同的语言有不同的表示，理想情况是所有支持.NET的语言都有一个可遵循的基准。描述了支持.NET的编译器必须支持的最小的和完全的特征集。以生成可由CLR承载的代码。 mscoree.dll工作流 .NET命名空间举例 Microsoft根命名空间包含的类型用于和那些只属于Windows操作系统的服务进行交互。 .NET SKD配置Path或者 开始-所有程序-Vs-VS Tools-开发人员命令提示 csc /t:exe[/target:exe] 1.cs csc 1.cs（默认） csc /t:library 1.cs（输出dll） 响应文件外部引用 /r:System.Windows.Forms.dll 输出 /target:exe /out:TestApp.exe *cs 默认响应文件csc.rsp（与csc.exe同目录），包含大部分常用程序集引用。默认被csc.exe引用。可以简写为： csc /out:TestApp.exe *.cs ## 第二/三部分：C#核心编程结构/C#面向对象编程char的静态方法123456char.IsDigit; //是否为数字 char.IsLetter; //是否为字母char.IsWhiteSpace; //是否为空白char.IsPunctuation; //是否为标点char.IsLower; //是否为小写char.IsUpper; //是否为大写 改变枚举底层存储类型1234567enum EmpType&#123; Manager, Grunt, Contractor, VicePresident&#125; 可以节省内存。但小心溢出。可以定义未核心系统类型（byte,short,int或long）。 获取底层存储类型： 1Enum.GetUnderlyingType(typeof(EmpType)) -&gt; System.Int32 获取名值对： 12345var ret = Enum.GetValues(typeof(EmpType));foreach (var item in ret)&#123; Console.WriteLine("&#123;0&#125;，&#123;0:D&#125;", item);&#125; System.ValueType枚举，结构都隐式派生自此类型。分配在栈上运行。 浅/深复制当一个值类型中包含一个引用类型。如结构中包含对象引用，直接等号赋值时会有两个独立的结构，内部生成一个引用的副本，指向内存中同一个对象的引用。（浅复制）。 默认访问修饰符类型成员（变量，方法），是隐式【私有】的。类型（对象）是隐式【内部】的。 1234class Radio //内部&#123; Radie()&#123;&#125; //私有&#125; Const,readonly,staticconst(常量)=readonly(只读)+static(静态)。编译期确定 运行期确定都不可再更改。 ## 第四部分：高级C#编程结构delegate关键字使用此关键字创建委托时，就间接声明了一个派生自MulticastDelegate的类。不会直接派生自这些基类，但这个类“是”MulticastDelegate。 委托一个委托对象维护一个可调用方法的列表，而不是一个单独的方法。添加方法，使用+=即可。编译器会将+=转换为Delegate.Combine()方法调用。+=更简洁，-=则转换为Delegate.Remove()。 event事件事件会扩展为两个隐藏的公共方法，一个add_xx，一个remove_xx。调用者仅需使用+=和-=操作符（操作符将在后台触发正确的add_xx和remove_xx方法，来对原委托进行操作）。 EventHanlder自定义EventArgs的泛型委托： 123456789101112class My&#123; public event EventHandler&lt;MyEventArgs&gt; Display; public void Do(MyEventArgs msg) &#123; if (Display != null) &#123; Display(this, msg); &#125; &#125;&#125; 不再需要定义一个自定义委托类型。 操作符重载的思考通常仅在构建原子数据类型时才有用。文本，点，举行，分数等都是操作符重载的很好候选。人，经理，汽车，数据库连接等却不是。如果一个重载操作符会使用户更难于理解该类型的功能，那就别用它。 Try catch的CIL实现对一个实现了IDispose对象的using{}语句块会被CIL解析为一个try{}finally{}块。确保Dispose的执行。 new关键字的CIL实现使用new时，等同于CIL指令newobj： 执行： 计算分配对象需要总内存数 检查托管堆，如果空间足够，则调用类型构造函数，最终将内存中新对象的应用返回给调用者。它的地址恰好是下一个对象的上一个位置。如果空间不足，则执行一次垃圾回收来尝试是否内存。 返回引用之前，移动下一个对象的指针，指向托管堆上的下一个可用的位置。 自动属性的CIL实现自动属性的get;set;标记会在元数据中被编译器映射成一个私有字段Name和两个方法get_Name(),set_Name()。 应用程序根根(root)就是一个存储位置，保存着对托管堆上对象的引用。垃圾回收时，CLR判读托管堆上的对象，判断应用程序是否仍然可访问它们(是否还有根)。为此，CLR建立一个对象图。不可访问的对象被标记为终结(finalize，垃圾)，它们就会从内测中清除。此时，堆上剩余的空间被压缩调整，引起CLR修改活动应用程序根的集合，指向正确的内存位置。下一个对象的指针被重新调整指向下一个可用位置。 对象的代设计思路：对象在堆上存在的时间越长，他就更可能应该保留。(WinForm主窗口)最近才放在堆上的对象可能很快就不可访问了。(一个方法中创建的对象)。 第0代：从没有被标记为回收的新分配对象。第1代：在上一次垃圾回收中没有被回收的对象(曾被标记为回收，但因为已经从其他对象获取了足够的堆空间而没有被删除)。第2代：在一次以上的垃圾回收后仍然没被回收的对象。 通过给对象赋一个表示代的值，尽快的删除一些较新的对象(本地变量)，而不会经常打扰一些旧对象(主窗体) 强制垃圾回收123GC.Collect(); //强制回收所有代//GC.Collect(1, GCCollectionMode.Forced); //回收0-1代GC.WaitForPendingFinalizers(); //挂起线程，等待回收结束 适用： 程序将进入一段代码，后者不希望被可能得垃圾回收中断。 刚刚分配分厂多的对象，想尽可能多地删除已获得的内存。 GC测试12345678910111213141516171819202122232425262728//输出堆上估计得字节数Console.WriteLine(GC.GetTotalMemory(false));//目前最高代Console.WriteLine(GC.MaxGeneration);//某对象处于多少代object obj = new object();Console.WriteLine(GC.GetGeneration(obj));//测试数组object[] objs = new object[500000];for (int i = 0; i &lt; 500000; i++) objs[i] = new object();//输出堆上估计得字节数Console.WriteLine(GC.GetTotalMemory(false));//回收第1代GC.Collect(0, GCCollectionMode.Forced);GC.WaitForPendingFinalizers();Console.WriteLine(GC.GetGeneration(obj));//看一下9000是否还活着if (objs[9000] != null) Console.WriteLine("活着：处于" + GC.GetGeneration(objs[9000]) + "代");else Console.WriteLine("死了");//某代被回收次数Console.WriteLine("0代：&#123;0&#125;，1代：&#123;1&#125;，2代：&#123;2&#125;", GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2));//跳过对象的终结阶段，通知CLR不在调用对象的析构函数GC.SuppressFinalize(this); 资源包装器引用托管或非托管宝贵的资源(数据库，文件句柄等)时，希望尽可能快的释放资源。而不能依靠GC的回收。 12345678910111213141516171819202122232425262728293031323334class MyResourceWrapper : IDisposable&#123; //判断Dispose()是否被调用过 private bool disposed = false; //用户忘了Dispose()，垃圾回收器会调用这个方法 ~MyResourceWrapper() &#123; //调用辅助方法，指定false表示GC触发了清理 CleanUp(false); &#125; //用户可以主动调用，来尽快清除资源 public void Dispose() &#123; //调用辅助方法，指定true表示用户触发了清理 CleanUp(true); GC.SuppressFinalize(this); &#125; private void CleanUp(bool disposing) &#123; if (!disposed) &#123; //如果disposing为true，释放所有托管资源。如果disposing为false，不确定托管资源是否还在内存中，不执行释放。 if (disposing) &#123; //释放托管的资源 &#125; //在这里释放非托管的资源 &#125; disposed = true; &#125;&#125; 测试： 1234567891011121314~MyResourceWrapper()&#123; Console.Beep(); //命令行一声响声 CleanUp(false);&#125;static void Main(string[] args)&#123; MyResourceWrapper m = new MyResourceWrapper(); m.Dispose(); MyResourceWrapper m1 = new MyResourceWrapper(); //此时会响一声&#125; Lazy 延迟加载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Program&#123; static void Main(string[] args) &#123; MP3 m = new MP3(); //不使用Lazy，此句加载SDCard，然后初始化Song[] var r = m.Card; var v = r.Value; //使用Lazy，此句加载SDCard，然后初始化Song[] //或 var c = m.GetCard(); Console.ReadKey(); &#125;&#125;class Song&#123; public string FileName &#123; get; set; &#125; public string FileLength &#123; get; set; &#125;&#125;class SDCard&#123; public decimal Price &#123; get; set; &#125; private Song[] allSongs = new Song[100000]; public SDCard() &#123; Console.WriteLine("装满歌曲"); &#125;&#125;class MP3&#123; //public void Play() //播放 //public void Pause() //暂停 //public void Stop() //停止 public Lazy&lt;SDCard&gt; Card = new Lazy&lt;SDCard&gt;(() =&gt; //不传参或传一个Lambda表达式 &#123; var newCard = new SDCard &#123; Price = 50 &#125;; return newCard; &#125;); public SDCard GetCard() &#123; return Card.Value; &#125;&#125; 第五部分：用.NET程序集编程.NET程序集的作用 促进代码重用。一个代码库(.dll或.exe)被打包后，可以被外部应用程序调用。.NET平台允许我们以语言无关的方式来重用其中的类型，如C#创建，其他.NET语言调用。 确定类型便捷。类型的完全限定名需要加上类型所在程序集。如两个不同程序集中命名空间相同的类，被认为是不同的。 可版本化的单元。每个程序集被分配一个...的四部分数字版本号(默认1.0.0.0，默认VS项目设置)。版本号加上可选的公钥值(即程序集强名)使一个程序集的不同版本可在同一台机器共存而不冲突 。通过强名，CLR保证客户端调用程序能加载正确版本的程序集。 自描述。程序集记录了清单数据(自身运行需要的外部程序集)，还包含了一些元数据(程序集包含的每一个类型的组成，成员名称，接口，基类，构造等)。由于信息被详细的记录了，CLR不需要访问注册表来解析程序集的位置(区别于与微软原来的COM编程模型) 可配置的。程序集可“私有”或“共享”。私有：与调用它的客户端应用程序处于同一个目录或子目录下，共享：被部署在全局程序集缓存（GAC）的特定目录中。通过编写XML的配置文件，CLR可以指定位置朝赵，加载指定版本的程序集。查阅本地，网络或URL上的任意目录。 程序集和托管模块一个团队（程序集），是一个逻辑单位。里面有很多成员（托管模块），成员分2类： 普通成员（托管模块，后缀.netModule。持有元数据和CIL代码）。领导成员（主模块，后缀.exe或.dll。持有程序集清单），了解每个成员。一般与这个团队（程序集）沟通或合作是面向它的领导（主模块），同样以领导名称来称呼这个团队。 C#生成的程序集一般为单模块程序集（只有主模块）。 .NET程序集的格式(.dll或.exe)包含： Windows文件首部可被Windows操作系统加载，标识了应用程序以什么类型（控制台，图形用户界面还是*.dll代码库）驻留于Windows操作系统中。 CLR文件首部使CLR了解托管文件的布局，位置和强名等 CIL代码独立于平台和CPU的中间语言，运行时才被JIT变异成特定平台和CPU的指令。 类型元数据内含类型和外部应用类型的格式。 程序集清单记录了每一个模块，版本和引用的外部程序集。 可选的嵌入资源图标，图像，声音，字符串表。卫星程序集(附属程序集)可构建国际化软件系统。 代码中的每个字符串字面量都记录在元数据的User Strings 标记下，所以不能储存敏感信息。 私有程序集应用程序添加外部程序集引用的时候，把副本文件放在本地bin文件夹下。调用时，CLR只是加载本地的副本。并不查询系统注册表。 配置私有程序集：Test.exe //一个Console控制台程序Carlib.dll //控制台会调用的程序集 以下三种情况会正常运行： 把Test.exe和Carlib.dll放在同一个文件夹下 找不到Carlib.dll的文件，会查找同一个文件夹下具有相同友好名称的可执行程序集.exe文件 找与程序集同名的文件夹下是否有此程序集。如Carlib/Carlib.dll 如果有Test.exe.config配置文件，CLR会根据配置的“规则”探测指定文件夹下是否有此程序集 例： 12345678&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt; &lt;probing privatePath="CarLibChg/" /&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt;&lt;/configuration&gt; 如果还是找不到，会引发FileNotFoundException异常。VS的App.config会在编译的时候，把App.config的数据复制到bin/debug/文件下，并改一个合适的名称。如Test.exe.config，FrontWeb.dll.config。 共享程序集例如mscorlib.dll，旨在多个项目中服用的类型的集合，共享程序集的一个副本可供一台机器上的多个应用程序使用，是机器级别的类库（machine wide）。 全局程序集缓存：.NET 3.5以前的位置在，C:\Windows\assembly下。.NET 4.0以上的在C:\Windows\Microsoft.NET\assembly\GAC_MSIL下的v4.0_major.minor.build.revision_publicKeyTokenValue子文件夹下。例如：v4.0_4.0.0.0__b77a5c561934e089。 强名称 需要.NET的sn.exe工具生成公钥/私钥对。生成一个.snk（Strong Name Key）文件。C#编译器确定.snk文件的位置后，会在编译时把公钥值记录在程序集清单的.publickey标记中。 产生一个基于整个程序集内容（CIL代码，元数据等）的散列值（某一固定输入的独一无二的数值输出，如果更改了程序集的内容，就算只一个字符，陈胜的讲师完全不同的散列码）。散列码结合私钥组成数字签名，并把它嵌入到程序集的CLR首部数据中。 用命令行生成强名：developer Command Prompt下 sn -k 文件名.snk 再在AssemblyInfo.cs文件中指定位置 [assembly: AssemblyKeyFile(@&quot;C:\MyTestKeyPair.snk&quot;)] 编译时，公钥被压缩成散列值加入到清单中 .publicKeyToken标记 用VS生成强名：Properties -&gt; 签名 -&gt;新建便会在根目录下生成一个*.snk文件 在GAC中安装强名称的程序集使用Developer Command Prompt定位到*.dll所在目录（bin\debug）使用 gacutil -i test.dll/test.exe //安装 gacutil -l test //核实 gacutil -u test //卸载 VS引用程序集时，如果清单中含有.publickey值时，VS会嘉定这个具有强名称的程序集以备部署到GAC中，那么引用的属性窗口中的，复制本地就为false。不会对该程序集进行复制到本地debug文件夹中的工作。 配置共享程序集发布了1.0.0.0版本后，添加了一些新的功能，产生了2.0.0.0版本。如果客户端应用程序想要使用2.0.0.0版本的新功能，可以把2.0.0.0版本发布到目标机器，让2和1版本和平共处。需要的时候修改*.config文件，动态的定向到2.0.0.0版本。这一切并不需要重新编译和部署。 动态重定向到共享程序集： 1234&lt;dependentAssembly&gt; &lt;assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" /&gt; &lt;bindingRedirect oldVersion="0.0.0.0-5.2.3.0" newVersion="5.2.3.0" /&gt;&lt;/dependentAssembly&gt; 定义了程序清单当前指向的版本(oldVersion)和GAC中的替代版本(newVersion) 元素用于指示CLR探测位于任意位置（网络重点，其他本地目录）的依赖程序集。当指向远程计算机时，相关程序集会下载到GAC的下载缓存中。通过此元素加载的程序集必须具有强名称。 例： &lt;codeBase version=&quot;2.0.0.0&quot; href=&quot;http://www.MySite.con/Assemblies/CarLibrary.dll&quot; /&gt; Type类型12345678Car c = new Car();Type t1 = c.GetType(); //编译器获得Type实例，需要类型实例Type t2 = typeof(Car); //同上，不需类型实例Type t3 = Type.GetType("ConsoleApplication2.Person", false, true); //完全限定名（不抛出异常，忽略大小写）Type t4 = Type.GetType("ConsoleApplication2.Person+Sex", false, true); //获得类型中的嵌套类型，加“+”Type t5 = Type.GetType("CarLib.Car,CarLib", false, true); //引用外部程序集类型，加“,”Type t6 = Type.GetType("System.Collections.Generic.List`1", false, true); //对于泛型，加“`”+数字（类型参数的个数）Console.ReadKey(); 动态加载程序集123Assembly asm = Assembly.Load("Carlib"); //需要保证程序集二进制文件在Debug文件夹下asm = Assembly.LoadFrom(@"C:\Code\Carlib.dll"); //绝对路径，以编程的形式提供&lt;codeBase&gt;值asm.GetTypes().ToList().ForEach(Console.WriteLine); 反射共享程序集123456789string displayName = @"System.Windows.Form.dll,Version=4.0.0.0,PublicKeyToken=b77a5c561934e089,Culture=""";//显示名称：标识一个程序集的一组术语//加载共享程序集必须指定公钥标记值AssemblyName asmName = new AssemblyName();asmName.Version = new Version(4, 0, 0, 0); //或者使用面向对象的类来传递Version,PublicKeyToken等参数Assembly asm = Assembly.Load(displayName);asm = Assembly.Load(asmName); 晚期绑定12345678910Assembly asm = Assembly.Load("CarLib"); //无需引用，只需把程序集文件放在Debug文件夹下Type car = asm.GetType("CarLib.Car"); object obj = Activator.CreateInstance(car); //建立一个晚期绑定类型的实例，类型为object。object obj1 = Activator.CreateInstance("CarLib", "CarLib.Car").Unwrap();MethodInfo mi = car.GetMethod("Run"); //无法转换类型，使用反射调用实例方法。默认搜索公共方法成员mi.Invoke(obj, null); //调用无参方法MethodInfo mi2 = car.GetMethod("Stop", BindingFlags.Instance | BindingFlags.NonPublic); //指定私有成员包含在搜索内mi2.Invoke(obj, new object[] &#123; "停车" &#125;); //指定参数列表 关键在于，在没有某个程序集清单数据的情况下，创建程序集的类型实例。 特性用于类型，成员，程序集或模块的代码注解。把更多的元数据嵌入到程序集中。 程序集级别特性使用[assembly:]标签，给特定程序集所有类型应用特性。例：[assembly: CLSCompliant(true)]，强制所有程序集中的公共类型符合CLS。 构建可扩展的应用程序比如VS，开发的时候允许其他软件提供商向IDE开发环境中插入各种“钩子”（自定义模块），一个可能得思路如下： 可扩展的应用程序必须提供一些输入手段，允许用户指定被插入的模块。这需要动态加载。 必须要确定模块是否支持正确的功能（一组需要的接口）。这需要反射。 必须获取一个需要的基础架构的引用（例如接口类型）并调用成员触发底层功能。这经常需要晚期绑定。 构建每个插件对象需要实现的类型定义 应用于插件对象和承载应用程序，保证功能统一。 1234567891011121314namespace CommonSnappableTypes&#123; public interface IAppFunctionality &#123; void DoIt(); &#125; [AttributeUsage(AttributeTargets.Class)] public sealed class CompanyInfoAttribute : Attribute &#123; public string CompanyName &#123; get; set; &#125; public string CompanyUrl &#123; get; set; &#125; &#125;&#125; 构建C#插件 123456789101112131415161718namespace CSharpSnapIn&#123; [CompanyInfo(CompanyName = &quot;JetBrains&quot;, CompanyUrl = &quot;www.xxx.com&quot;)] public class CSharpModule : IAppFunctionality &#123; void IAppFunctionality.DoIt() //显示的接口实现，DoIt方法没有在CSharpModule中公开 &#123; Console.WriteLine(&quot;使用了自定义插件&quot;); &#125; 或 public void DoIt() &#123; Console.WriteLine(&quot;使用了自定义插件&quot;); &#125; &#125;&#125; 构建承载的应用程序 12345678910111213141516171819202122namespace ConsoleApplication2&#123; class Program &#123; static void Main(string[] args) &#123; string path = "..."; //可以从WinForm等应用程序中选择程序集文件 Assembly asm = Assembly.LoadFrom(path); //注意非空判断 //得到程序集中所有兼容IAppFunctionality的类 var types = asm.GetTypes().Where(m =&gt; m.IsClass &amp;&amp; m.GetInterface("IAppFunctionality") != null); foreach (var item in types) &#123; IAppFunctionality app = (IAppFunctionality)asm.CreateInstance(item.FullName, true); //用晚期绑定获得实例 或 IAppFunctionality app1 = (IAppFunctionality)Activator.CreateInstance(item); app.DoIt(); &#125; Console.ReadKey(); &#125; &#125;&#125; dynamic允许我们在类型安全的强类型世界里使用校本化的行为。可以认为dynamic关键字是一个特殊形式的System.Object。但提供了更多特性，并且动态数据不是强类型的，或者说动态数据不是静态类型。 作用范围：字段，属性，返回值，参数。 调用动态声明的数据成员动态数据不属于静态类型，和js一样，直到运行时你才会直到所调用的动态数据是否支持指定的成员，参数以及成员的拼写是否无误等。编译时不能触发智能感知提示。 dynamic实际用途构建一个需要大量使用后期绑定（通过反射）的.NET应用程序时。或者构建一个需要与遗留的COM库（如Office）进行交互的.NET应用程序。使用dynamic可以大大减少打字时间，简化代码。但代价是失去了类型的安全性。 DLR(dynamic language runtime，动态语言运行时)的特性 机器灵活的代码库，重构时不需要频繁修改数据类型。 不同平台和语言所构建的对象类型之间进行互操作非常简便。 可以在运行时为内存中的类型添加或移除成员。 使用dynamic简化晚期绑定Type type=...; 通过反射 1234object obj=Activator.CreateInstance(type);MethodInfo mi=tpe.GetMethod("Run");object[] param=10,20;mi.Invoke(obj,param); 通过dynamic 12dynamic obj=Activator.CreateInstance(type);obj.Run(10,20); 简化了查询程序集元数据和打包参数等操作。 互操作程序集IDE以COM库为基础生成的全新程序集，包含了COM元数据的.NET描述和一小部分将COM事件转换为.NET事件的代码。封装，避免了内部COM的复杂性。 CLR（如果使用dynamic就是DLR）自动对.NET数据类型和COM类型进行映射，因此可以直接在C#代码中使用互操作程序集。在后台，使用RCW（Runtime Callable Wrapper，一个动态生成的代理）对数据进行封送，使其在.NET和COM应用程序之间交互。 主互操作程序集许多COM库供应商提供了一个“官方”的互操作程序集，成为主互操作程序集，简称PIA。PIA是优化的互操作程序集，比通过IDE添加COM库引用生成的代码更整洁，也更具扩展性。PIA存在的情况下，添加应用一个COM库，VS会使用提供的PIA，而不是生成一个新的互操作程序集。 嵌入互操作元数据添加COM库（PIA或其他）时，IDE会自动将该库的“嵌入互操作类型”置为true。这样，必要的互操作元数据（你真正使用的那部分，而不是全部）已经硬编码到.NET程序中，我们就不必在.NET应用程序中携带互操作程序集的副本了。减少了安装包的尺寸，客户端计算机也不必包含改互操作程序集的副本。 表达式树当使用DLR进行处理动态数据时，自动创建的“表达式树”将被传递给正确的动态语言帮顶起。帮顶起解析表达式树并传递给正确的对象成员。 进程一个正在运行的应用程序的固定的安全的边界。用来描述一组资源（外部代码库和主线程）和程序运行所必须的内存分配。 应用程序域：对该进程的逻辑细分。一个应用程序域进一步被细分成多个上下文边界，用来分组目的相似的.NET对象。 进程，应用程序域，上下文的关系： 线程：进程中的独立的基本的执行单元。每一个进程都有一个（在可执行入口处创建的）主线程和其他包含以编程方式创建的额外线程。 进程和线程的关系：当一个线程的时间片用完的时候，会被挂起，以便执行其他线程。线程把挂起前的情况写到线程本地存储中（Thread Local Storage，TLS），并且它们还要获得一个独立的调用栈（call stack）。 Process类12345678910111213using System.Diagnostics;var procs = Process.GetProcesses(".");procs.OrderBy(m =&gt; m.Id).ToList().ForEach(m =&gt; Console.WriteLine("&#123;0&#125;：&#123;1&#125;", m.Id, m.ProcessName));var proc = Process.GetProcessById(4); //进程不存在则引发异常//PID为0的System Idle Prcess，表示系统核心虚拟出来的表示CPU空闲的状态。输入会出错。Console.WriteLine(proc.Id + "：" + proc.ProcessName);//ProcessThread并不用于操作线程，只是用户获取运行进程中线程的诊断信息foreach (ProcessThread item in proc.Threads)&#123; Console.WriteLine("&#123;0&#125;：&#123;1&#125;：&#123;2&#125;：&#123;3&#125;", item.Id, item.PriorityLevel, item.StartTime, item.ThreadState);&#125; 查看进程中的模块123456var proc = Process.GetProcessById(10284);var modls = proc.Modules;foreach (ProcessModule item in modls)&#123; Console.WriteLine("&#123;0&#125;：&#123;1&#125;", item.ModuleName, item.ModuleMemorySize);&#125; 编程方式启动或结束进程1234var proc = Process.Start("Chrome", "www.baidu.com");Console.WriteLine("启动：" + proc.ProcessName + "，PID：" + proc.Id);Console.ReadKey();proc.Kill(); //如果进程已关闭，或附加到别的进程上。则此处会抛出异常 ProcessStartInfo启动进程1234567ProcessStartInfo info = new ProcessStartInfo&#123; FileName = "Chrome", Arguments = "www.baidu.com", WindowStyle = ProcessWindowStyle.Hidden&#125;;var proc = Process.Start(info); 应用程序域传统的非托管程序直接承载在进程上，而.NET可执行程序承载在进程的一个逻辑分区中，即应用程序域（AppDomain）。运行在某个应用程序域中的应用程序将无法访问其他应用程序域中的数据（无论是全局变量还是静态字段），除非使用分布式编程协议（如WCF）。好处在于： 应用程序域是.NET平台操作系统独立性的关键特性。将不同操作系统表现加载可执行程序的差异抽象化了。 和一个完整的进程相比，应用程序域的CPU和内存占用都有小的多。因此CLR加载和卸载应用程序域比起来完整的进程来说也快得多，并且可以快速提升服务器应用程序的可扩展性。 应用程序域为承载的应用程序提供了深度的隔离。如果进程中一个应用程序域失败了，剩余的应用程序域也能保持正常。 .NET平台不允许从内存中卸载指定的程序集。已编程方式卸载库的唯一方式是使用Unload()方法销毁承载的应用程序域。 默认程序域一个.NET可执行文件启动时，CLR会自动将其放置到宿主进程的默认应用程序域中。访问当前线程的应用程序域 123AppDomain app = AppDomain.CurrentDomain;Console.WriteLine("&#123;0&#125;：&#123;1&#125;：&#123;2&#125;：&#123;3&#125;",app.FriendlyName,app.Id,app.IsDefaultAppDomain(),app.BaseDirectory);//BaseDirectory，程序集解约程序用它来探测程序集 应用程序域中加载的.NET程序集123456AppDomain app = AppDomain.CurrentDomain;var asms = app.GetAssemblies();foreach (Assembly item in asms)&#123; Console.WriteLine(item.GetName().Name + "：" + item.GetName().Version);&#125; 接收程序集加载通知12345AppDomain app = AppDomain.CurrentDomain;app.AssemblyLoad += (o, s) =&gt;&#123; Console.WriteLine(s.LoadedAssembly.GetName().Name);&#125;; 创建新的应用程序域1234567891011AppDomain app = AppDomain.CreateDomain("Second");foreach (Assembly item in app.GetAssemblies())&#123; //只加载了mscorlib。如果调试的话还会加载用于调试的额外程序集 Console.WriteLine(item.GetName().Name);&#125;app.Load("CarLib"); //向自定义应用程序域中加载程序集，此时加载的程序集多了一个AppDomain.Unload(app); //卸载自定义应用程序域 上下文边界给定对象“特定的家”，一个进程定义了默认的应用程序域，每个应用程序域都有一个默认的上下文（总是第一个创建），也成为上下文0（context 0）。用于组合那些对上下文没有具体的或唯一性需求的.NET对象（大多数对象）。 不需要指定特定上下文的.NET类型称为上下文灵活（context-agile）对象，可以从应用程序域的任何位置访问，与对象的运行时需求没有关系。需要指定特定上下文的对象称为上下文绑定（context-bound）对象，只能在其被创建的那个上下文中正常运行。必须派生自System.ContextBoundObject基类。 定义上下文绑定对象自动线程安全的类。 123456789101112131415161718192021using System.Runtime.Remoting.Contexts;using System.Threading;[Synchronization]public class ContextObject : ContextBoundObject&#123; public void Do() &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(i + "：当前线程-" + Thread.CurrentThread.ManagedThreadId); &#125; &#125;&#125;static void Main(string[] args)&#123; ContextObject obj = new ContextObject(); Task.Run(() =&gt; obj.Do()); Task.Run(() =&gt; obj.Do());&#125; 研究上下文1234567891011121314151617181920212223242526272829303132333435363738394041using System.Runtime.Remoting.Contexts;using System.Threading;[Synchronization]public class ContextObjectBound : ContextBoundObject&#123; public ContextObjectBound() &#123; Context ctx = Thread.CurrentContext; Console.WriteLine(this + " 在上下文中： " + ctx.ContextID); foreach (var item in ctx.ContextProperties) &#123; Console.WriteLine(item.Name); &#125; &#125;&#125;public class ContextObject&#123; public ContextObject() &#123; Context ctx = Thread.CurrentContext; Console.WriteLine(this + " 在上下文中： " + ctx.ContextID); foreach (var item in ctx.ContextProperties) &#123; Console.WriteLine(item.Name); &#125; &#125;&#125;static void Main(string[] args)&#123; ContextObject obj = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObject obj1 = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObjectBound objTs = new ContextObjectBound(); //1，LeaseLifeTimeServiceProperty，Synchronization Console.ReadKey();&#125; CIL.NET平台语言（C#，VB，F#等）的母语，某个语言相关联的编译器会把源代码翻译成CIL CIL标记分为3类 CIL指令以.前缀，例如：.namespace、.class、.pulickeytoken、.method、.assembly CIL特性例如：public，extends（指定这个类型的基类），implements（支持的一系列接口） CIL操作码例如：ldstr（LoadString，定义一个字符串变量），实际上是操作码的助记符。真正的操作码是二进制码，add - 0x58，sub - 0x59，newobj - 0x73。 CIL基于栈的本质CIL不允许直接访问一个数据（本地变量、参数变量或属性）。而是通过虚拟执行栈来访问。 12string myMessage="Hello"; //分为1-3Console.WriteLine(myMessage); //分为4-5 .locals init ([0] string myMessage)定义一个本地字符串变量（在Call Stack本地变量索引0处） ldstr “Hello”将字符串的引用放在了Envaluation Stack中，而真正的字符串放在了Managed Heap中 stloc.0将Envaluation Stack中的值保存到 Call Stack中索引为0的本地变量中（V0，栈低已存在args[最底]和return address），因为Envaluation Stack中存放的是“hello”字符串的地址，所以变量中存放的也是字符串的地址。 ldloc.0把Call Stack中索引0处变量的的值（引用地址），加载到Envaluation Stack中 call void [mscorlib]System.Console::WriteLine(string)从 Evaluation Stack 中取出一个值，此值为 Reference Type，调用方法 Managed Heap（托管堆）：这是动态配置（Dynamic Allocation）的记忆体，由GC在执行时自动管理，整个 Process 共用一个 Managed Heap，可以理解为引用类型的东西都放在这个Managed Heap中。 Call Stack（调用栈）：CLR在执行时自动管理的记忆体，每个Thread都有自己的Call Stack堆栈。每调用一次method，就会使得Call Stack上多了一个Record Frame；调用完毕之后，此Record Frame会被丢弃。一般来说，Record Frame内记录着method参数（Parameter）、返回位址（Return Address）、以及局部变量（Local Variable）。CLR使用零基索引的方式来识别局部变量。 Evaluation Stack（虚拟执行栈）：这是由 CLR在执行时自动管理的记忆体，每个Thread都有自己的Evaluation Stack。压入的到Evaluation Stack的值，当方法调用结束时必须保持这个堆栈的平衡（清空），这里面存放例如局部变量值，以及引用类型的地址。如果忘记清空，ilasm仍然会编译成功。可以用peverify.exe工具诊断。peverify test.dll ld，加载，用于压栈到虚拟执行栈 st，存储，用于弹栈虚拟执行栈顶的值到内存调用栈中 CIL的代码标签例如：IL_0001：，IL_000c。大多数标签是可选的，完全可以移除。只有编写有多个分支和循环结构的CIL代码时，通过这些标签指定逻辑流转到哪里的时候，才是必需的。 使用ilasm.exe编译CIL代码ilasm /exe Hello.il /output=NewAssembly.exe -?查看选项参数 CIL指令和特性 指定外部应用程序集 12345.assembly extern mscorlib&#123; .publickeytoken=(B7 7A 5C 56 19 34 E0 89) .ver 4:0:0:0&#125; 定义当前程序集 123456.assembly CILTypes&#123; .ver 1:0:0:0&#125;.module CILTypes.dll //单模块程序集 定义命名空间 12.namespace MyNamespance&#123;&#125;.namespace Myconpany.MyNamespace&#123;&#125; 定义类类型 123456.namespace MyNamespace&#123; .class public MyBaseClass extends [BaseEntity]BaseEntity.AuditEntityBase&#123;&#125; //CIL要求使用完整的名字&#125; 定义和实现接口 12345678.class public interface IMyInterface&#123;&#125;.class public MyBaseClass&#123;&#125;.class public MyDerivedClass extends MyNamespace.MyBaseClass implements MyNamespace.IMyInterface&#123;&#125; //同一程序集下可以省略“[]”前缀。 //extends在前，implements在后，多个接口用“，”分隔 //接口派生接口使用implements 定义结构 1.class public sealed MyStruct extends [mscorlib]System.ValueType&#123;&#125; 简化： 1.class public sealed value MyStruct&#123;&#125; 定义枚举 1.class public sealed MyEnum extends [mscorlib]Sytem.Enum&#123;&#125; 简化： 1.class public sealed enum MyEnum&#123;&#125; 定义泛型 C#： 1List&lt;int&gt; myIntes=new List&lt;int&gt;(); CIL： 1newobj instance void class [mscorlib]Sytem.Collections.Generic.List`1&lt;int32&gt;::.ctor() 定义数据字段 1234567.class public sealed enum MyEnum&#123; .field public static literal valuetype MyNamespace.MyEnum A=int32(0) .field public static literal valuetype MyNamespace.MyEnum B=int32(1)&#125; 私有成员 12345.class public MyBaseClass&#123; .filed private string stringField="hello!" .filed private int32 intField=int32(42)&#125; 定义属性 12345678910111213141516.class public MyBaseClass&#123; .method public hidebysig specialname instance string get_TheString() cil managed &#123; //实现 &#125; .method public hidebysig specialname instance void set_TheString(string 'value') cil managed &#123; //实现 &#125; .property instance string TheString() &#123; .get instance string MyNamespace.MyBaseClass::get_TheString() .set instance void MyNamespace.MyBaseClass::set_TheString(string) &#125; &#125; 定义构造函数 123456789.class public MyBaseClass&#123; .fileld private int32 intField .method public hidebysig specialname rtsspecialname instance void .ctor(string s,int32 i) cil managed &#123; //实现 &#125; //.ctor指令和instance特性结合使用 //cil managed标识出这个方法包含的是CIL代码而不是非托管代码&#125; 定义参数 C#： 1234public static void MyMethod(int inputInt,ref int refInt,ArrayList ar,out outputInt)&#123; outputInt=0; &#125; CIL： 1234567.method public hidebysig static void MyMethod(int32 inputInt, int32&amp; refInt, class [mscorlib]System.Collections.ArrayList ar, [out] int32&amp; outputInt) cil managed&#123; //... &#125; .NET 基础类库、C#和CIL数据类型的映射 .maxstack指令确定一个在方法执行阶段可以被压入栈中的最大变量数目。默认值是8 在CIL中映射参数到本地变量C#： 1234public static int Add(int a,int b)&#123; return a+b;&#125; CIL： //已简化 12345678.method public hidebysig static int32 Add(int32 a,int32 b) cilmanaged&#123; .maxstack 2 ldarg.0 //加载'a'到栈中 ldarg.1 //加载'b'到栈中 add //从栈中弹出这2个值，并求和，并将计算结果存回栈中 ret //将和弹出栈，并通过ret操作码返回到调用者&#125; this隐式引用虚拟执行栈索引是从0开始。在使用CIL代码时，任何非静态函数在接收传入参数时都自动隐式地接受了一个附加参数，即当前对象的引用（this）。C#： 1234public int Add(int a,int b)&#123; return a+b;&#125; CIL：//伪代码，this是隐式的接受的 123456.method public hidebysig static int32 AddTwoInt(MyClass_HiddenThisPointer this,int32 a,int32 b) cil managed&#123; ldarg.0 //加载MyClass_HiddenThisPointer到虚拟执行栈上 ldarg.1 //加载'a' ldarg.2 //加载'b'&#125; 循环结构C#： 1234public static void CountToTen()&#123; for(int i=0;i&lt;10;i++);&#125; CIL： 12345678910111213141516.method public hidebysig static void COuntToTen() cil managed&#123; .maxstack 2 .locals init ([0] int32 i) //初始化本地变量'i' IL_0000: loc.i4.0 //压栈'0'到栈中 IL_0001: stloc.0 //弹栈'0'，并存储这个值到调用栈变量索引'0' IL_0002: br.s IL_0008//跳转到IL_0008 IL_0004: ldloc.0 //压栈索引0的值 IL_0005: ldc.i4.1 //压栈'1' IL_0006: add //两值弹栈，相加，结果压栈 IL_0007: stloc.0 IL_0008: ldloc.0 //压栈索引0的值 IL_0009: ldc.i4.s 10 //压栈'10‘ IL_000b: blt.s IL_0004 //两值弹栈，比较。小于10？如果是，跳转IL_0004 IL_oood: ret //&#125; 动态程序集静态程序集：存在于磁盘的.NET二进制文件动态程序集：运行中通过使用System.Reflection.Emit命名空间提供的类型在内存中创建程序集及其模块，类型定义以及CIL实现逻辑。并可以保存到磁盘上生成一个新的静态程序集。用处： 构建需要根据用户输入来生成程序集文件的.NET开发工具构建需要在运行时通过元数据来生成远程类型的代理的程序加载静态程序集并能动态插入新类型到二进制图像中。 System.Reflection.Emit命名空间的成员 ILGenerator注入CIL操作码到一个给定的类型成员。 产生动态程序集，保存并实现延迟绑定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Program&#123; static void Main(string[] args) &#123; CreateMyAm(AppDomain.CurrentDomain); Assembly asm = Assembly.Load("MyAssembly"); Type type = asm.GetType("MyAssembly.HelloWorld"); var mi = type.GetMethod("SayHello"); object obj = Activator.CreateInstance(type, "123"); mi.Invoke(obj, null); mi = type.GetMethod("GetMsg"); Console.WriteLine(mi.Invoke(obj, null)); Console.ReadKey(); &#125; static void CreateMyAm(AppDomain app) &#123; //建立通用程序集特征 AssemblyName asmName = new AssemblyName &#123; Name = "MyAssembly", Version = new Version(1, 0, 0, 0), KeyPair = new StrongNameKeyPair(File.ReadAllBytes(@"C:\test.snk")) //产生强名，才可以直接引用，并使用using &#125;; //在当前应用程序域中创建一个新的程序集 AssemblyBuilder asm = app.DefineDynamicAssembly(asmName, AssemblyBuilderAccess.Save); //因为是单文件程序集，模块的名字就是程序集的名字 ModuleBuilder module = asm.DefineDynamicModule("MyAssembly", "MyAssembly.dll"); //定义一个公共类 TypeBuilder myClass = module.DefineType("MyAssembly.HelloWorld", TypeAttributes.Public); //定义一个私有字符串成员变量 FieldBuilder strField = myClass.DefineField("theMessage", typeof(string), FieldAttributes.Private); //创建自定义的构造函数 ConstructorBuilder ctor = myClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] &#123; typeof(string) &#125;); ILGenerator ilCtor = ctor.GetILGenerator(); ilCtor.Emit(OpCodes.Ldarg_0); ConstructorInfo superCtor = typeof(object).GetConstructor(new Type[0]); ilCtor.Emit(OpCodes.Call, superCtor); //调用基类构造函数 ilCtor.Emit(OpCodes.Ldarg_0); //压栈对象的this指针 ilCtor.Emit(OpCodes.Ldarg_1); //压栈参数 ilCtor.Emit(OpCodes.Stfld, strField); //存储在this的strField ilCtor.Emit(OpCodes.Ret); //创建默认构造函数 myClass.DefineDefaultConstructor(MethodAttributes.Public); //创建GetMsg()方法 MethodBuilder getMsg = myClass.DefineMethod("GetMsg", MethodAttributes.Public, typeof(string), null); ILGenerator ilMethod = getMsg.GetILGenerator(); ilMethod.Emit(OpCodes.Ldarg_0); ilMethod.Emit(OpCodes.Ldfld, strField); ilMethod.Emit(OpCodes.Ret); //创建SayHello()方法 MethodBuilder sayHello = myClass.DefineMethod("SayHello", MethodAttributes.Public); ilMethod = sayHello.GetILGenerator(); ilMethod.EmitWriteLine("Hello World!"); ilMethod.Emit(OpCodes.Ret); //创建类Hello World myClass.CreateType(); //保存程序集 asm.Save("MyAssembly.dll"); &#125;&#125; 第六部分：.NET基础类库应用程序域和线程一个应用程序域可以承载多个线程，线程可以跨越不同的应用程序域 1AppDomain ad=Thread.GetDomain(); 获取正在承载当前线程的应用程序域 1Context ctx=Thread.CurrentContext; 获取当前操作线程所处的上下文 委托的异步性12345678910111213141516171819202122232425262728293031323334353637383940class Program&#123; public delegate int MyMethod(int x, int y); private static bool isDone = false; static void Main(string[] args) &#123; Console.WriteLine("Main，线程ID：" + Thread.CurrentThread.ManagedThreadId); MyMethod m = Add; IAsyncResult ar = m.BeginInvoke(10, 10, AddComplete, "R U Ok?"); //开启异步，使用的是线程池的工作者线程（后台线程） //轮询方式 //while (!ar.AsyncWaitHandle.WaitOne(1000,true)) //&#123; // Console.WriteLine("Working..."); //&#125; //回调方式 while (!isDone) &#123; Thread.Sleep(1000); Console.WriteLine("Working..."); &#125; Console.ReadKey(); &#125; static int Add(int x, int y) &#123; Console.WriteLine("Add，线程ID：" + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(3000); return x + y; &#125; static void AddComplete(IAsyncResult result) &#123; Console.WriteLine("Complete，线程ID：" + Thread.CurrentThread.ManagedThreadId + "，Msg" + result.AsyncState); AsyncResult ar = (AsyncResult)result; MyMethod m = (MyMethod)ar.AsyncDelegate; Console.WriteLine("Result：" + m.EndInvoke(result)); isDone = true; &#125;&#125; Threading命名空间 AutoResetEvent类线程同步的通知类 123456789public static AutoResetEvent waitHandle = new AutoResetEvent(false);//阻塞一个线程，直到收到通知waitHandle.WaitOne();//通知一个或多个线程事件终止，允许继续waitHandle.Set(); TimerCallBack定时任务 123456789101112static void Main(string[] args)&#123; Timer t = new Timer(Print, "时间：", 0, 1000); Console.ReadKey();&#125;static void Print(object state)&#123; Console.Clear(); Console.WriteLine(state + DateTime.Now.ToLongTimeString());&#125; ThreadPool的好处1，减少了线程创建、开始和停止的次数，这提高了效率2，能够使我们将注意力放到业务逻辑上而不是多线程架构上 某些情况仍应优先使用手工线程管理：1，需要前台线程或设置优先级别，线程池中的线程总是后台线程，优先级是默认的。无法修改2，需要一个带有固定标识的线程便于退出、挂起或通过名字发现它。 Parallel类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Program&#123; private static CancellationTokenSource cts = new CancellationTokenSource(); static void Main(string[] args) &#123; string filePath = @"C:\Pictures"; string[] files = Directory.GetFiles(filePath, "*.jpg", SearchOption.TopDirectoryOnly); string newPath = @"C:\Pictures\new"; if (!Directory.Exists(newPath)) &#123; Directory.CreateDirectory(newPath); &#125; //并行方式 ParallelOptions option = new ParallelOptions &#123; CancellationToken = cts.Token, MaxDegreeOfParallelism = System.Environment.ProcessorCount &#125;; try &#123; //主线程仍然被阻塞，等待其他线程完成工作 Parallel.ForEach(files, option, m =&gt; &#123; option.CancellationToken.ThrowIfCancellationRequested(); string fileName = Path.GetFileName(m); using (Bitmap map = new Bitmap(m)) &#123; map.RotateFlip(RotateFlipType.RotateNoneFlipX); //左右翻转 map.Save(Path.Combine(newPath, fileName)); Console.WriteLine("Id：" + Thread.CurrentThread.ManagedThreadId); &#125; &#125;); &#125; catch (Exception e) &#123; //处理 &#125; Console.WriteLine("等待中...（最后才显示）"); Console.ReadKey(); &#125;&#125;Parallel.Invoke(() =&gt;&#123; var ret = DoSomething();&#125;, () =&gt;&#123; var ret = DoAnthor();&#125;); 次线程访问UI线程的控件1234this.Invoke((Action)delegate&#123; this.Text=....;&#125;); WinForm中，线程创建的控件具有“线程相关性”。次线程不能直接访问主线程（UI线程）创建的控件，可以通过此方法传递异步委托执行。 async await关键字123456789101112131415161718192021222324252627282930313233class Program&#123; static void Main(string[] args) &#123; Console.WriteLine("Main Id:" + Thread.CurrentThread.ManagedThreadId); //主线程 new Program().Entry(); Console.WriteLine("等待中..."); //先出现 Console.WriteLine("Main Id:" + Thread.CurrentThread.ManagedThreadId); //主线程 Console.ReadKey(); &#125; public async Task&lt;string&gt; DoItAsync() //约定以Asynv后缀 &#123; Console.WriteLine("DoIt Id:" + Thread.CurrentThread.ManagedThreadId); //主线程 var r = await Task.Run(() =&gt; //开启新线程，主线程在执行完await标记的代码（Task.Run创建新线程部分，不包含内部的委托部分）后跳出 &#123; Thread.Sleep(3000); Console.WriteLine("DoIt Id:" + Thread.CurrentThread.ManagedThreadId); //新线程 return "haha"; &#125;); Console.WriteLine("DoIt Id:" + Thread.CurrentThread.ManagedThreadId); //新线程 return r; &#125; public async void Entry() &#123; Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId); //主线程 string ret = await DoItAsync(); //await 负责提取包含在Task对象中的内在返回值。 //主线程把具有await标记的DoIt() 执行完毕之后，跳出此方法到调用处继续执行。 Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId); //新线程 Console.WriteLine(ret); &#125;&#125; 返回void的异步方法返回非泛型的Task类，并忽略return 1234567private asynv Task MethodVoidAsync()&#123; await Task.Run(() =&gt; &#123; //... &#125;&#125; 多个await的异步方法123456789101112131415public async void Entry()&#123; //调用者线程 Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId); //调用者跳出返回，开启新线程1 await Task.Run(() =&gt; Thread.Sleep(3000)); //新线程1 Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId); //新线程1销毁，开启新线程2 await Task.Run(() =&gt; Thread.Sleep(3000)); //下同 Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId); await Task.Run(() =&gt; Thread.Sleep(3000)); Console.WriteLine("Entry Id:" + Thread.CurrentThread.ManagedThreadId);&#125; System.IO 获取计算机上驱动器的细节1DriveInfo[] drives = DriveInfo.GetDrives(); StreamWriter和StreamReader123456using (StreamWriter writer = File.CreateText("1.txt"))&#123; writer.WriteLine("hahaha"); writer.WriteLine("hahaha"); writer.Write(writer.NewLine);&#125; 等于 1234using (StreamWriter writer=new StreamWriter("1.txt"))&#123; &#125; 12345678using (StreamReader reader = File.OpenText("1.txt"))&#123; string buffer; while ((buffer = reader.ReadLine()) != null) &#123; Console.WriteLine(buffer); &#125;&#125; 等于 1234using (StreamReader reader=new StreamReader("1.txt"))&#123; &#125; BinaryWriter类允许我们从基层流中以简洁的二进制格式读取或写入离散数据类型 12345678910111213using (BinaryWriter bw=new BinaryWriter(File.OpenWrite("1.txt")))&#123; Console.WriteLine("Type："+bw.BaseStream); bw.Write('1'); bw.Write("123"); bw.Write(123); bw.Write(12.3);&#125;using (BinaryReader br=new BinaryReader(File.OpenRead("1.txt")))&#123; Console.WriteLine(br.ReadString()); //只有"123"&#125; 文件监视12345678910111213141516FileSystemWatcher watcher = new FileSystemWatcher&#123; Path = Directory.GetCurrentDirectory(), Filter = "*.txt", NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName&#125;;watcher.Changed += (o, e) =&gt; Console.WriteLine(e.FullPath + "\t" + e.ChangeType);watcher.Created += (o, e) =&gt; Console.WriteLine(e.FullPath + "\t" + e.ChangeType);watcher.Deleted += (o, e) =&gt; Console.WriteLine(e.FullPath + "\t" + e.ChangeType);watcher.Renamed += (o, e) =&gt; Console.WriteLine(e.OldFullPath + "\t" + e.FullPath);watcher.EnableRaisingEvents = true; 对象序列化12345678910111213141516171819202122[Serializable]class Program&#123; public string Name &#123; get; set; &#125; static void Main(string[] args) &#123; Program p = new Program &#123; Name = "Main" &#125;; BinaryFormatter format = new BinaryFormatter(); using (var stream = File.OpenWrite("1.txt")) &#123; format.Serialize(stream, p); &#125; using (var stream = File.OpenRead("1.txt")) &#123; Program p1 = (Program)format.Deserialize(stream); Console.WriteLine(p1.Name); &#125; Console.ReadKey(); &#125;&#125; 对象图 持久化对象的格式123using System.Runtime.Serialization.Formatters.Binary;using System.Xml.Serialization;using System.Runtime.Serialization.Formatters.Soap; XmlSerializer和SoapFormatterXmlSerializer:持久化为XML文档，只会保存公有已赋值字段或公共属性。可以保存偏好设置（颜色，文字大小等）。SoapFormatter:持久化为一个SOAP消息（传递消息到Web服务或从Web服务传递消息的标准XML格式）。 12345678910111213141516171819202122232425262728293031323334static void Main(string[] args)&#123; List&lt;Picture&gt; list = new List&lt;Picture&gt; &#123; new Picture&#123; Id=0,Url="1.jpg"&#125;, new Picture&#123; Id=1,Url="2.jpg"&#125; &#125;; XmlSerializer format = new XmlSerializer(typeof(List&lt;Picture&gt;), "Carousels"); 或 SoapFormatter format = new SoapFormatter(); using (var stream = File.OpenWrite("config.xml")) //从头覆盖内容，不会重建文件 或 using (var stream = new FileStream("config.xml", FileMode.Create, FileAccess.Write, FileShare.None)) //重建文件 &#123; format.Serialize(stream, list); &#125; using (var stream = File.OpenRead("config.xml")) &#123; List&lt;Picture&gt; p1 = (List&lt;Picture&gt;)format.Deserialize(stream); p1.ForEach(m =&gt; Console.WriteLine("/images/CSharp/" + m.Url)); &#125; Console.ReadKey();&#125;[Serializable]public class Picture&#123; private int size; //XmlSerializer不会包含 public string Name = "轮播图"; public int Id &#123; get; set; &#125; public string Url &#123; get; set; &#125;&#125; 格式化程序中的类型保真BinaryFormatter，持久化对象图中对象的字段数据，和每个类型的完全限定名城和定义程序集的完整名称（强名）。这些数据使跨越.NET应用程序机器边界传递对象成为理想的选择。SoapFormatter，XmsSerializer，没有序列化完整的.NET类型元数据（完全限定名称或程序集），可用于标准的.NETWeb服务，可被任何平台中的客户端调用（Windows、MAC OS X和Linux）。 控制生成的XML数据1234567891011121314151617181920212223242526272829303132333435static void Main(string[] args)&#123; Picture pic = new Picture &#123; Id = 1, Url = "2.jpg", Date = DateTime.Now.ToShortDateString(), Details = new List&lt;string&gt; &#123;"遍", "历" &#125; &#125;; XmlSerializer format = new XmlSerializer(typeof(Picture)); using (var stream = new FileStream("config.xml", FileMode.Create, FileAccess.Write, FileShare.None)) &#123; format.Serialize(stream, pic); &#125; using (var stream = File.OpenRead("config.xml")) &#123; Picture p1 = (Picture)format.Deserialize(stream); &#125; Console.ReadKey();&#125;[Serializable, XmlType(TypeName = "SinglePicture")]public class Picture&#123; public int Id &#123; get; set; &#125; public string Url &#123; get; set; &#125; [XmlEnum] public List&lt;string&gt; Details; [XmlAttribute] public string Date &#123; get; set; &#125;&#125; 生成的XML部分如下： 123456789&lt;?xml version="1.0"?&gt;&lt;SinglePicture xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Date="2017/4/15"&gt; &lt;Details&gt; &lt;string&gt;遍&lt;/string&gt; &lt;string&gt;历&lt;/string&gt; &lt;/Details&gt; &lt;Id&gt;1&lt;/Id&gt; &lt;Url&gt;2.jpg&lt;/Url&gt;&lt;/SinglePicture&gt; 使用特性定制序列化1234567891011121314151617181920[Serializable]public class Picture&#123; public int Id &#123; get; set; &#125; public string Url &#123; get; set; &#125; public string Name &#123; get; set; &#125; [OnSerializing] private void OnSerializing(StreamingContext context) &#123; Name += " Date:" + DateTime.Now.ToShortDateString(); &#125; [OnDeserialized] private void OnDeserialized(StreamingContext context) &#123; Url = Url.ToLower(); Name = Name.ToUpper(); &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#高级编程_注释笔记]]></title>
    <url>%2F2017%2F04%2F04%2FC-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Type类型1234var i = 2.0;var t1 = i.GetType();var t2 = i.GetTypeCode();Console.WriteLine("类型：" + t1 + "，类型码：" + t2 + "，类型码的值：" + (int)t2); 输出：类型：System.Double，类型码(enum)：Double，类型码的值：14 123456789101112var t = typeof(Person);Console.WriteLine(t.Assembly);Console.WriteLine(t.Attributes);Console.WriteLine(t.BaseType);Console.WriteLine(t.FullName);Console.WriteLine(t.GetProperties()[0].Name);Console.WriteLine(t.GUID);Console.WriteLine(t.Name);Console.WriteLine(t.Namespace);Person p1 = new Person();if (p1.GetType()==t) Console.WriteLine("Ok"); Type的成员方法123456GetConstructor[s]() //返回ConstructorInfoGetEvent[s]() //返回EventInfoGetField[s]() //返回FieldInfoGet[Default]Member[s]() //返回MemberInfoGetMethod[s]() //返回MethodInfoGetProperty[s]() //返回PropertyInfo Assembly和Type1234Assembly ass = Assembly.Load("ConsoleApplication1");Type t = typeof(Book);var b = ass.CreateInstance(t.FullName);var b1 = ass.CreateInstance("ConsoleApplication1.Book"); 程序集dll，逻辑单元。包含模块，资源等。 程序集强名：共享程序集使用强名唯一地标识该程序集，保证全局唯一，包括： 程序集本身的名称 版本号。不同版本可以共存于一个进程。 公钥。保证独一无二。 文化 应用程序域图解 不同域加载程序集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758namespace AssemblyA&#123; // [Serializable]//只序列化，则仍由调用应用域访问 public class Demo : MarshalByRefObject //继承这个基类（已序列化），才能通过另一个应用程序域来访问。 &#123; public Demo() &#123; &#125; public Demo(int val1, int val2) &#123; Console.WriteLine("domain：&#123;0&#125;中带有参数&#123;1&#125;和&#123;2&#125;的构造函数被调用", AppDomain.CurrentDomain.FriendlyName, val1, val2); &#125; public void DoSome() &#123; Console.WriteLine("domain：&#123;0&#125;调用方法DoSome", AppDomain.CurrentDomain.FriendlyName); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("domain：&#123;0&#125;的主函数被调用", AppDomain.CurrentDomain.FriendlyName); &#125; &#125;&#125;namespace AssemblyB&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("当前域：" + AppDomain.CurrentDomain.FriendlyName); AppDomain firstDomain = AppDomain.CreateDomain("First AppDomain"); firstDomain.ExecuteAssemblyByName("AssemblyA"); //需要添加引用或复制程序集，执行exe形式的程序集 firstDomain.ExecuteAssembly("AssemblyA.exe"); //上方主函数被调用 AppDomain secondDomain = AppDomain.CreateDomain("Second AppDomain"); var ret = secondDomain.CreateInstance("AssemblyA", "AssemblyA.Demo", true, BindingFlags.CreateInstance, null, new object[] &#123; 7, 3 &#125;, null, null); //上方Demo类构造函数被调用 var obj = (Demo)ret.Unwrap(); //解除包装 obj.DoSome(); //实例化程序集中的类的示例 Demo demo = (Demo)secondDomain.CreateInstanceAndUnwrap("AssemblyA", "AssemblyA.Demo"); demo.DoSome(); //显示：Second AppDomain调用方法DoSome //适用：如果程序集是动态加载的，用完后卸载。 //主应用程序域中，无法删除已加载程序集。但可以终止应用程序域，该域中加载的程序集会从内存中清楚。 AppDomain.Unload(secondDomain); //string fullName = namespaceName + "." + Controller + "Controller"; //object obj = Assembly.Load(assemblyName).CreateInstance(fullName); //result = (ServerController)obj; Console.ReadKey(); &#125; &#125;&#125; 当前域加载程序集 123456//动态加载程序集，创建实例//配合接口降低耦合，也可以逆向引用调用对象方法string fullName = "AssemblyA.Demo";object obj = Assembly.Load("AssemblyA").CreateInstance(fullName);var result = (Demo)obj;result.DoSome(); 方法和函数函数&gt;方法。函数包括：方法，非数据成员：索引器，构造函数，析构函数，属性。 构造函数初始化器123456789public Car(string des) : this(des , 4)&#123; //...&#125;public Car(string des,int wheel)&#123; //... &#125; 实现构造函数之间的重用: this 或: base 之后的构造函数先执行，然后再执行此构造函数。 partial关键词编译时，两个不分类的属性，XML注释，接口，泛型类型的参数属性，特性和成员会合并。 泛型中的default关键字初始化泛型参数T时，可以使用detault(T)。在不知道T是引用类型还是值类型的情况下，分别赋予引用类型null或者值类型0 委托类似于C++中的函数指针（但类型不安全，参数和返回值未知）。 面向对象编程，没有方法是孤立的。如果要传递方法， 就要把方法细节（签名和返回类型）封装在一种新类型对象中，即委托。委托是一种特殊对象，普通对象都包含数据，而委托包含的只是一个或多个方法的地址（指针）。 委托的定义和使用：（面向对象的角度） 定义一个委托（类似定义一个类） private delegate string GetAString(); 实例化一个GetAString的委托实例（实例化一个对象）。委托语法上总是接收一个参数的构造函数。 GetAString me=new GetAString(x.ToString); 或者委托推断： GetAString me=x.ToString; me();或者me.Invoke(); 编译器会用me.Invoke()；代替me()； 浅表复制，深度复制浅表复制，成员对象，直接复制引用。成员值，创建值副本。深度复制，成员对象，创建副本。成员值，创建值副本。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[Serializable] //可被序列化，实现深度复制public class CloneDemo // : ICloneable，可继承接口，实现方法复制&#123; public int State &#123; get; set; &#125; public StateObject innerObj &#123; get; set; &#125; [Serializable] public class StateObject &#123; public int InnerState &#123; get; set; &#125; &#125; public CloneDemo() &#123; State = 1; innerObj = new StateObject &#123; InnerState = 1, &#125;; &#125; //浅表复制 public CloneDemo ShadowClone() &#123; return this.MemberwiseClone() as CloneDemo; &#125; //深度复制 public CloneDemo DeepClone() &#123; using (var stream = new MemoryStream()) &#123; var formatter = new BinaryFormatter(); formatter.Serialize(stream, this); stream.Seek(0, SeekOrigin.Begin); return formatter.Deserialize(stream) as CloneDemo; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; var demo = new CloneDemo(); var shadow = demo.ShadowClone(); var deep = demo.DeepClone(); Console.WriteLine("demo：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", demo.State, demo.innerObj.InnerState); Console.WriteLine("shadow：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", shadow.State, shadow.innerObj.InnerState); Console.WriteLine("deep：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", deep.State, deep.innerObj.InnerState); demo.State = -1; demo.innerObj.InnerState = -1; Console.WriteLine("====================\n分别对属性和引用赋值...\n===================="); Console.WriteLine("demo：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", demo.State, demo.innerObj.InnerState); Console.WriteLine("shadow：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", shadow.State, shadow.innerObj.InnerState); Console.WriteLine("deep：属性State = &#123;0&#125;，引用innerObj.State = &#123;1&#125;", deep.State, deep.innerObj.InnerState); Console.ReadKey(); &#125;&#125; Array抽象类1234Type t=...;Array intArr=Array.CreateInstance(typeof(t),5);intArr.SetValue(33,2);intArr.GetValue(2); 事先不知类型，可由此创建数组。 Array.Sort(数组,IComparer 比较器); EnumeratorGetEnumerator()方法用IEnumerable接口定义。foreach语句并不真的需要集合实现这个接口。有一个名为GetEnumerator()的方法，返回实现了IEnumerator接口的对象就行了。 IEnumerator接口定义了Reset()方法，以与COM交互操作。 foreach解析为下面的代码段： 123456789var enumerator = list.GetEnumerator();while (enumerator.MoveNext())&#123; var item = enumerator.Current; if (item != null) &#123; Console.WriteLine(item.Name); &#125;&#125; yield语句包含yield语句的方法或属性也成为迭代块。必须声明为返回IEnumerator或IEnumerable接口。可包含yield return或yeild break，不能有return语句。 使用迭代块，编译器会生成一个yield类型，包含一个状态机。记录了迭代的当前位置。 foreach访问迭代器，一次访问一个。无需一次加载完所有数据。可以把yeild类型看作内部类Enumerator。 12345678910111213141516171819202122232425class My&#123; public class Enumerator : IEnumerator&lt;string&gt;, IEnumerator, IDisposable &#123; private int state; public string Current &#123; get; private set; &#125; public void Dispose() &#123; //... &#125; public bool MoveNext() &#123; //... &#125; public void Reset() &#123; //... &#125; object IEnumerator.Current &#123;get &#123; return Current; &#125;&#125; &#125;&#125; 默认迭代是：定义为返回Enumerator的GetEnumerator()方法，是foreach默认采用的方法。自定义命名迭代返回IEnumerable。 集合特性 IEnumerabel：GetEnumerator()，返回一个实现了IEnumerator接口的枚举。可以被foreach。 ICollection：由泛型集合实现。Count属性。CopyTo()方法（把集合复制到数组中）。Add()，Remove()，Clear()方法。 IList：派生自ICollection。定义了索引器，可通过指定位置，Insert()或RemoveAt()。 ISet：派生自ICollection。由集实现。合并，交集，并集。 IDictionary：键值集合。索引器。 ILookup：一个键包含多个值。 IComparer：比较器实现。Compare()对集合中的元素排序。 IEqualityComparer：比较器，数组，元祖实现。该比较器可用于字典中的键。 IProducerConsumerCollection：.NET4.0。支持新的线程安全的集合类。 IReadOnlyCollection，IReadOnlyList，IReadOnlyDictionary：初始化后不能修改的，只能检索。 IImmutableArray，IImmutableList，IImmutableQueue，IImmutableSet， IImmutableDictionary：初始化后不能修改。不可变接口定义了不可变集合的方法和属性。 队列先进先出（FIFO）容器。 Queue ，先进先出（FIFO）。Enqueue()，一端添加元素。Dequeue()，另一端读取和删除元素。Peek()，从头部读取一个元素，但不删除。 栈后进先出（LIFO）容器。 Push()，添加元素。Pop()获取最近添加的元素。Peek()，返回栈顶的元素，但不删除它。 Lookup类一键对多值 123456789101112List&lt;Book&gt; list = new List&lt;Book&gt;&#123; new Book() &#123; Title = "b1", Price = 1 &#125;, new Book() &#123; Title = "b2", Price = 2 &#125;, new Book() &#123; Title = "a2", Price = 2 &#125;&#125;;var bookLk = list.ToLookup(p =&gt; p.Price);foreach (var item in bookLk[2])&#123; Console.WriteLine(item.Title);&#125; 集HashSet 不重复无序，SortedSet 不重复有序 123456aSet.Add() //是否成功添加了元素。aSet.IsSubsetOf(bSet) //a是否是b的子集（b包含a所有元素）bSet.IsSupersetOf(aSet) //b是否是a的超集（b包含a所有元素）aSet.Overlaps(bSet) //a与b是否共享某元素。（重叠）aSet.UnionWith(bSet) //向a中加入b所有的元素。aSet.ExceptWith(bSet) //从a中删除b拥有的元素 Immutable不可变集合，需要引用System.Collections.Immutable（.NET4.5） 123ImmutableList&lt;string&gt;.Add("") //每次返回一个新的不变集合，不改变本身。var build=imList.ToBuild() //构建器。返回一个可变集合。可以进行.Add()，.Remove()等。build.ToImmutable() //返回一个变动后的不可变集合。 并发集合 IProducerConsumerCollection：TryAdd(),和TryTake()。 ConcurrentQueue：免锁定，内部链表。TryTake(),Enqueue(),TryDequeue(),TryPeek() ConcurrentStack：链表。Push(),TryPeek(),TryPop(),TryPopRange() ConcurrentBag：没有定义添加或提取项的任何顺序，线程映射到内部使用的数组，尝试减少锁定。 ConcurrentDictionary：线程安全，非阻塞键值集合。TryGetValue(),TryRemove(),TryUpdate()。没有实现IProducerConsumerCollection。 BlockingCollection：阻塞线程。Add(),Take()。 dynamic类型dynamic类型允许编写忽略编译期间的类型检查代码。 var对象类型的确定会延迟，确定后不可变。dynamic类型可以改变多次。int-&gt;string-&gt;object async只能用于返回Task或void的方法。不能作为程序的入口点。 Task启动Task的3种方式： 1.1234567Action act = () =&gt;&#123; Console.WriteLine("任务开始"); Thread.Sleep(2000);&#125;;Task t = new Task(act);t.Start(); 2.1Task t = Task.Factory.StartNew(act); 3.12345678Task t = Task.Run(act); //对Factory的封装//完成通知，回调t.ContinueWith(task =&gt;&#123; Console.WriteLine("完成状态"); Console.WriteLine("IsCanceled=&#123;0&#125;\tIsCompleted=&#123;1&#125;\tIsFaulted=&#123;2&#125;", task.IsCanceled, task.IsCompleted, task.IsFaulted);&#125;); Task组合器 Task.WhenAll(t1,t2)：等待，直到全部任务都完成。 Task.WhenAny(t1,t2)：等待，直到其中一个任务完成就会返回。 应用CancellationTokenSource，取消Task123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Program&#123; static void Main(string[] args) &#123; var cts = new CancellationTokenSource(); Task&lt;int&gt; t = new Task&lt;int&gt;(() =&gt; Add(cts.Token), cts.Token); t.Start(); t.ContinueWith(TaskEnded); Console.ReadKey(); cts.Cancel(); Console.ReadKey(); &#125; static void TaskEnded(Task&lt;int&gt; task) &#123; Console.WriteLine("完成"); Console.WriteLine("IsCanceled:&#123;0&#125;,IsCompleted:&#123;1&#125;,IsFaulted:&#123;2&#125;", task.IsCanceled, task.IsCompleted, task.IsFaulted); ①Console.WriteLine("返回值：" + task.Result); ②try &#123; Console.WriteLine("返回值:" + task.Result); &#125; catch (AggregateException e) &#123; var errs = e.InnerExceptions; //与组合器配合，获取所有任务异常。 e.Handle(err =&gt; err is OperationCanceledException); &#125; &#125; static int Add(CancellationToken token) &#123; Console.WriteLine("任务开始"); int result = 0; ①while (!token.IsCancellationRequested) &#123; result++; Thread.Sleep(1000); &#125; ②③while (true) &#123; result++; Thread.Sleep(1000); ②token.ThrowIfCancellationRequested(); ③if (result == 5) &#123; throw new Exception("error"); &#125; &#125; return result; &#125;&#125; Task t=… ，有返回参数才有①t.Result属性。任务完成则，IsCompleted:true。不论是否异常。 ①进行逻辑判断，任务正常结束后，进入TaskEnded，结果：IsCanceled:false,IsFaulted:false 。 ②通过抛AggregateException异常，立即结束任务，进入TaskEnded，结果：IsCanceled:true,IsFaulted:false。 ③通过抛自定义异常，立即结束任务，进入TaskEnded，结果：IsCanceled:false,IsFaulted:true。 虚拟寻址系统32位处理器上的每个进程都可以使用4GB的内存，无论计算机实际有多少物理内存（64位更大）。包含了：可执行代码，dll，变量等。 栈（stack）栈指针指向为栈保留的内存块末尾。栈实际上是向下填充的。即从高内存地址向低内存地址填充。数据入栈后，指针调整，始终指向下一空闲存储单元。数据释放（变量超出作用域），指针向上递增。 变量的生存期总是嵌套的，保证了栈指针是有序的。 堆（heap）堆上的内存是向上分配的。空闲空间在已用空间的上面。 垃圾回收gc运行时，会从堆中删除不再引用的所有对象。只要释放了能释放的所有对象，它就把其他对象移动回堆的端部。再次形成一个连续的内存块。因此，堆可以确定在什么地方存储新对象。对象移动后，需要新地址更新引用，gc会处理更新问题。 大对象堆不同于主堆，存储使用大于85000个字节对象。压缩大对象比较昂贵。故大对象对上的对象不执行压缩过程。 第二代和大对象堆上的回收放在后台线程执行，应用程序仅为第0代和第1代回收而阻塞，减少了暂停时间。 非托管资源文件句柄，网络连接，数据库连接等。 托管资源栈，堆上的数据。 析构函数C#不常使用，无法确定执行时机。有析构函数的对象需要两次处理才能销毁。析构函数运行时间长，非常耗性能。 IDisposable接口C#推荐IDisposable接口替代析构函数。声明Dispose()，释放非托管资源，控制更精准。 如果显式调用需要try catch，防止异常而没有执行。 代替用using()语句，更简单。 unsafe代码块unsafe可以修饰 类成员方法等。标记为不安全代码，可以使用指针语法提高性能。但带来不安全性和不方便等。 指针语法12345int x=10;int* pX,pY;pX= &amp;x;pY=px;*pY=20; x内容改为20。pY与x中间没有任何关系，pY碰巧指向存储x的存储单元。 //pX，pY也占用4个字节，因为32位处理器上，4个字节存储一个地址。 &amp;表示取地址，把一个值类型转换为指针。 *表示获取地址的内容，把一个指针转换为值类型。 强制转换： 12uint y=(uint)pX;int* pD=(int*)y; 自定义特性123456789101112131415[FieldName("xxx")] //FieldNameAttribute，Attribute可以省略，自动添加。搜索指定名称的类，实例化。[AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, //引用在哪些元素上，或的关系AllowMultiple=false, //是否可以多次应用在同一元素Inherited=false)] //自动应用到派生类或接口，重写的方法等public class FieldNameAttribute: Attribute&#123; public string Comment &#123;get;set;&#125; private string name; public FieldNameAttribute(string name) &#123; this.name=name; &#125;&#125; 使用： 12345[FieldName("xxx",Comment="xxx")]public string Func&#123; //... &#125; Exception 属性 Data，可以添加的额外信息字典。 HelpLink，连接帮助文件上。 InnerException，如异常在catch中抛出，则inner为把代码发送到catch块的异常对象。 Source，导致异常程序或对象名。 StackTrace，调用栈信息。 TargetSite，抛出异常的方法的反射对象。 .ReflectedType获得类的Type对象。 调用者特性123456789101112131415public class Book&#123; public string Title &#123; get; set; &#125; public decimal Price &#123; get; set; &#125; public void Log([CallerLineNumber] int line = 0, [CallerFilePath] string path = "", [CallerMemberName] string name = "") &#123; //Do with line,path,name... 包括调用者的信息 &#125;&#125;Book b = new Book();b.Log(); ThreadPool123456Book b = new Book() &#123; Title = "t", Price = 1 &#125;;ThreadPool.QueueUserWorkItem(i =&gt;&#123; Book b1 = i as Book; Console.WriteLine("书名" + b1.Title + "价格" + b1.Price);&#125;, b); 线程池的限制 线程池中的所有线程都是后台线程。并且不能把入池的线程改为前台线程。 不能设置池中线程的优先级或名称。 所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）线程。 入池的线程只能用于时间短的任务。如果需要一直运行（如word拼写检查），应创建Thread或Task使用LongRunning选项。 控制线程1234var t1 = new Thread(() =&gt; &#123; &#125;);t1.Priority = ThreadPriority.Highest; //优先级，优先调用。可能影响其他线程t1.Abort(); //停止线程，抛出异常t1.Join(2000); //阻塞 Interlocked类速度快，简单的同步问题。原子操作。 12Interlocked.CompareExchange();Interlocked.Increment(); Monitor类lock语句会被编译器解析成以下代码： 12345678910object obj = new object();Monitor.Enter(obj);try&#123; //线程同步区域&#125;finally&#123; Monitor.Exit(obj);&#125; Monitor的好处是可以指定等待时间： 1234567891011121314151617bool lockToken = false;Monitor.TryEnter(obj, 500, ref lockToken);if (lockToken)&#123; try &#123; //线程同步区域 &#125; finally &#123; Monitor.Exit(obj); &#125;&#125;else&#123; //做其他的事情&#125; 读写互斥锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Program&#123; private static List&lt;int&gt; items = new List&lt;int&gt;() &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; private static ReaderWriterLockSlim rwl = new ReaderWriterLockSlim(); static void ReaderMethod(object reader) &#123; try &#123; rwl.EnterReadLock(); //如果该锁是读取模式，则读取线程直接进入。累计数+1 for (int i = 0; i &lt; items.Count; i++) &#123; Console.WriteLine("reader &#123;0&#125;,loop &#123;1&#125;,item &#123;2&#125;", reader, i, items[i]); &#125; &#125; finally &#123; rwl.ExitReadLock(); //读取线程退出，累计数-1。为0时退出读取模式 &#125; &#125; static void WriterMethod(object writer) &#123; try &#123; //Thread.Sleep(100); //如果写入线程等待，则全部读取的线程会先执行完。否则就抢 while (!rwl.TryEnterWriteLock(50)) //如果取得写入锁，则进入独占写入模式。 &#123; Console.WriteLine("writer &#123;0&#125; 等待取写入锁", writer); Console.WriteLine("当前读者个数" + rwl.CurrentReadCount); &#125; Console.WriteLine("writer &#123;0&#125; 取得写锁", writer); for (int i = 0; i &lt; items.Count; i++) &#123; items[i]++; Thread.Sleep(50); &#125; Console.WriteLine("writer &#123;0&#125; 写入完毕", writer); &#125; finally &#123; rwl.ExitWriteLock(); //退出独占写入模式，读写线程开始抢锁 &#125; &#125; static void Main(string[] args) &#123; var taskFac = new TaskFactory(TaskCreationOptions.LongRunning, TaskContinuationOptions.None); for (int i = 0; i &lt; 6; i++) &#123; if (i==1 || i==4) &#123; taskFac.StartNew(WriterMethod, i); &#125; else &#123; taskFac.StartNew(ReaderMethod, i); &#125; &#125; Console.ReadKey(); &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First设计模式_注释笔记]]></title>
    <url>%2F2017%2F02%2F27%2FHead-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[设计原则 把可能变化之处独立出来，以免影响固定代码。 针对接口编程，而不是针对实现编程 多用组合，少用继承 设计交互对象之间的松耦合 扩展-关闭原则：类应该对扩展开发，对修改关闭。 依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 好莱坞原则：高层组件对待低层组件的方式：别调用我们，我们会调用你。避免高层和低层出现明显的环装依赖 一个类应该只有一个引起变化的原因。高内聚，低耦合。（单一职责） 备注123456789101112//推荐public int GetCount()&#123; return target.GetCount(); //只认识target &#125;//不推荐public int GetCount()&#123; var obj=target.GetObj(); //多认识（依赖）了一个对象 return obj.GetCount();&#125; 如果某对象是调用其他方法的返回结果，不要调用它的方法。意味着，不清楚他的方法细节。并不认识此对象，也就不依赖它。 针对接口（超类型）编程针对实现： 12Dog d=new Dog();d.bark(); 针对接口： 12Animal a=new Dog();a.makeSound(); 运行时： 12Animal a=getAnimal();a.makeSound(); 策略模式定义定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。 类图 观察者模式定义定义了对象间的一对多依赖（订阅），这样依赖，当一个对象改变时，它的所有依赖者都会受到通知并更新。Subject主题，Observer观察者。 类图 代码示例另可以用多播委托实现此过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class DeleteAction : IDisposable&#123; private readonly Action _onDispose; public DeleteAction(Action onDispose) &#123; _onDispose = onDispose; &#125; public void Dispose() &#123; _onDispose(); &#125;&#125;public class Msg&#123; public string Name &#123; get; set; &#125; &#125;public class Report : IObservable&lt;Msg&gt;&#123; private List&lt;IObserver&lt;Msg&gt;&gt; os = new List&lt;IObserver&lt;Msg&gt;&gt;(); public void Notify(string msg) &#123; os.ForEach(o =&gt; &#123; o.OnNext(new Msg &#123; Name = msg &#125;); o.OnCompleted(); &#125;); &#125; public IDisposable Subscribe(IObserver&lt;Msg&gt; observer) &#123; os.Add(observer); return new DeleteAction(() =&gt; &#123; os.Remove(observer); &#125;); &#125; public void Err() &#123; os.ForEach(o =&gt; &#123; o.OnError(new Exception("自定义错误！")); &#125;); &#125;&#125;public class Screen : IObserver&lt;Msg&gt;&#123; public int Id &#123; get; set; &#125; public Screen(int id) &#123; Id = id; &#125; public void OnNext(Msg value) &#123; Console.WriteLine("接收Id：" + Id + "，信息为：" + value.Name); &#125; public void OnError(Exception error) &#123; Console.WriteLine("接收Id：" + Id + "，错误！信息：" + error.Message); &#125; public void OnCompleted() &#123; Console.WriteLine("接收Id：" + Id + "，完成！"); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Report re = new Report(); Screen s1 = new Screen(1); Screen s2 = new Screen(2); var o1 = re.Subscribe(s1); var o2 = re.Subscribe(s2); re.Notify("哎呀"); o1.Dispose(); re.Notify("少人"); &#125;&#125; 装饰者模式定义动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 类图 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public abstract class Phone&#123; public abstract void Ring(); public abstract decimal GetPrice();&#125;public class Apple : Phone //被装饰者&#123; public override void Ring() &#123; Console.WriteLine("这是苹果手机..."); &#125; public override decimal GetPrice() &#123; return 4500; &#125;&#125;public abstract class Decorator : Phone //装饰者&#123; protected Phone p; //被装饰者引用 protected Decorator(Phone p) &#123; this.p = p; &#125;&#125;public class Sticker : Decorator &#123; public Sticker(Phone p): base(p) &#123; &#125; public override void Ring() &#123; p.Ring(); //被装饰者行为 AddSticker(); //新增行为/责任 &#125; public override decimal GetPrice() &#123; return p.GetPrice() + 1.5m; &#125; public void AddSticker() &#123; Console.WriteLine("加了贴膜！"); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Phone m = new Apple(); m = new Sticker(m); m = new Sticker(m); //贴了2层 m = new Accessories(m); m.Ring(); Console.WriteLine("当前价格为：" + m.GetPrice()); Console.ReadKey(); &#125;&#125; 角色抽象构件（Phone）角色：给出一个抽象接口，以规范准备接受附加责任的对象。 具体构件（AppPhone）角色：定义一个将要接收附加责任的类。 装饰（Dicorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰（Sticker和Accessories）角色：负责给构件对象 ”贴上“附加的责任。 理解优点： 装饰者模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合。装饰者模式有很好地可扩展性。 缺点：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。 适配器模式定义将一个类的接口，转换成客户（使用者）期望的另一个接口。适配器让原本不兼容的类可以合作无间。 类图 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface IDuck &#123; void Quack(); &#125;public interface ITurkey &#123; void SpecialQuack(); &#125;public class Duck : IDuck //鸭子类&#123; public void Quack() &#123; Console.WriteLine("鸭子叫！"); &#125;&#125;public class Turkey : ITurkey //火鸡类&#123; public void SpecialQuack() &#123; Console.WriteLine("火鸡叫！"); &#125;&#125;public class Adapter : IDuck //适配器，把火鸡转换成鸭子&#123; private ITurkey t; //持有（包装）的火鸡引用 public Adapter(ITurkey t) &#123; this.t = t; &#125; public void Quack() &#123; t.SpecialQuack(); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Adapter duckAdapter = new Adapter(new Turkey()); //使用适配器切换了接口 ShootDuck(duckAdapter); //原调用代码，不用更改。 Console.ReadKey(); &#125; static void ShootDuck(IDuck d) &#123; d.Quack(); //原调用代码，不用更改。 &#125; &#125; 理解系统A，原本某一块功能（如客户出入金）需要从一个提供商甲切换到提供商乙，不改变系统代码的情况下。可以创建适配器，封装乙的接口实现切换动作，让系统仍然像使用甲的接口那样，正常运作。过程不需修改代码，只需扩展适配器。处理遗留问题。 装饰者和适配器的异同适用条件的差别： 装饰模式一般在下列情况使用：需要扩展一个类的功能或者给你个类增加附加责任；需要动态的给一个对象增加功能，这些功能可以再动态的撤销；需要增加有一些基本功能的排列组合而产生非常大量的功能，从而使得继承关系变得不现实。 适配器模式一般使用的情况包括：系统需要使用现有的类，但此类已经不符合系统的需要； 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的的类一起工作。适配器模式在系统升级的时候使用的频率很高，对旧系统的一些功能方法在新系统中引用。 单例模式定义确保一个类只有一个实例，并提供一个全局访问点。 代码示例线程安全 12345678910111213141516171819public class Singleton&#123; private Singleton() &#123; &#125; private static Singleton singleton; public static Singleton GetInstance() &#123; if (singleton == null) &#123; lock (typeof(Singleton)) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 命令模式定义将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。 类图 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Receiver&#123; public void Action() &#123; Console.WriteLine("Called Receiver.Action()"); &#125;&#125;public abstract class Command&#123; protected Receiver receiver; public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; public abstract void Execute();&#125;public class ConcreteCommand : Command&#123; public ConcreteCommand(Receiver receiver): base(receiver) &#123; &#125; public override void Execute() &#123; receiver.Action(); &#125;&#125;public class Invoker&#123; private Command _command; public void SetCommand(Command command) &#123; this._command = command; &#125; public void ExecuteCommand() &#123; _command.Execute(); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(); invoker.SetCommand(command); invoker.ExecuteCommand(); &#125;&#125; 理解将请求者和执行者（接受者）解耦： 如果执行者种类繁多，且不属于同一个体系，也没有统一执行接口。请求者请求命令，需要知道所有执行者的外露接口，耦合很高。 命令模式，加入中间层：调用者，让请求者只认识调用者，向调用者发出指定执行者且接口固定的命令对象，调用者只执行指定命令对象的固定接口，命令对象包含执行者的引用和一组方法，知道如何完成操作。这种封装命令对象的模式，为命令模式。如待完成列表，可以在任何时间被执行。 外观模式定义提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易适用。 类图 代理模式定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。 类图 代理分类 远程代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。这样可以隐藏一个对象在不同地址空间的事实。例如：WebService，WCF 虚拟代理: 根据需要创建一个资源消耗较大的对象，通过它来存放实例化需要长时间的真实对象，使得此对象只在需要时才会被真正创建 保护代理：用来控制真实对象的访问时的权限。如果需要，可以给不同的用户提供不同级别的使用权限 智能代理：指当调用真实对象时，代理处理另外一些事。提供一些额外的操作，比如将对此对象调用的次数记录下来等 同步（Synchronization）代理：多线程情况下，为主题提供安全的访问 复杂隐藏（Complexity Hiding）代理：隐藏一个类的复杂集合的复杂度，有时候称为外观代理（Facade Proxy）。此代理控制访问，外观模式只提供另一组接口 写入时复制（Copy-on-Write）代理：虚拟代理的变种。把复制（克隆）延迟到只有在客户端需要时，才真正采取行动 缓存（Cache）代理：为开销大的运算结果提供临时的存储空间，以便多个客户端可以共享这些结果，以减少计算或网络延迟 防火墙（Firewall）代理：控制网络资源的访问，不让恶意用户接近 装饰者，外观，代理，适配器四种模式的比较 工厂方法模式定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 类图 抽象工厂模式定义提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指明具体类。 类图 模板方法模式定义在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 类图 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class Beverage&#123; public void Prepare() &#123; BoilWater(); Brew(); PourInCup(); //钩子，可由子类视情况（是否覆盖），反控制基类中的算法（顺序或步骤） if (IsCondiments()) &#123; AddCondiments(); &#125; &#125; protected abstract void AddCondiments(); //由子类实现部分算法 protected abstract void Brew(); //可有子类控制，推迟到子类中实现 protected virtual bool IsCondiments() &#123; return false; //钩子 &#125; private void PourInCup() &#123; Console.WriteLine("倒入杯子"); //基类默认实现部分 &#125; private void BoilWater() &#123; Console.WriteLine("烧水"); &#125;&#125;public class Coffee : Beverage&#123; protected override bool IsCondiments() &#123; return GetResult(); //根据结果是否覆盖使用此钩子 &#125; protected override void AddCondiments() &#123; Console.WriteLine("加糖，加奶"); &#125; protected override void Brew() &#123; Console.WriteLine("磨碎咖啡豆，泡咖啡粉..."); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Beverage co = new Coffee(); co.Prepare(); &#125;&#125; 模板方法模式的变种不使用继承，而使用组合。 java中Arrays.sort(object[] arr)中的算法，进行两个对象之间的比较。 12Comparable obj... //接口obj.compareTo(obj2)... 算法待实现部分，不再交由子类负责实现（数组不可继承）。而是传入一个实现了Comparable接口的元素组成的数组，由此数组的元素负责。 模板方法模式和工厂方法模式，区别模板方法，指的是实现算法的方法，包含基类实现部分和待子类实现部分（抽象方法）。 工厂方法，指的是可由子类继承实现的抽象方法，不同子类决定不同的功能。会由基类调用。 迭代器模式定义提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 类图 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Item&#123; public string Name &#123; get; set; &#125; public double Price &#123; get; set; &#125; public override string ToString() &#123; return "名称：" + Name + "，价格：" + rice; &#125;&#125;public class MenuManager : IEnumerable //可被foreach迭代&#123; private Item[] items; private int Index &#123; get; set; &#125; public MenuManager() &#123; items = new Item[10]; AddItem("煎饼", 2); AddItem("拉面", 7); AddItem("快餐", 10); &#125; public IEnumerator GetEnumerator() &#123; return new MenuEnumrator(items); //继承实现，返回一个迭代器供foreach使用 &#125; public void AddItem(string name, double price) &#123; Item i = new Item &#123; Name = name, Price = price &#125;; items[Index] = i; Index++; &#125; public void ChgItem(string name, double price, int destIndex) &#123; Item i = new Item &#123; Name = name, Price = price &#125;; items[destIndex] = i; &#125;&#125;public class MenuEnumrator : IEnumerator //迭代器接口&#123; private List&lt;Item&gt; list; private int index; public MenuEnumrator(IEnumerable&lt;Item&gt; arr) &#123; list = arr.ToList(); index = -1; &#125; public bool MoveNext() //继承实现，先后移动 &#123; index++; bool result = list.Count &gt; index &amp;&amp; list[index].Price &lt; 3; //自定义条件 if (result) Current = list[index]; return result; &#125; public void Reset() &#123; index = -1; //继承实现，重置索引 &#125; public object Current &#123; get; private set; &#125; //继承实现，当前项&#125;class Program&#123; static void Main(string[] args) &#123; MenuManager dm = new MenuManager(); dm.AddItem("汽水", 1); foreach (Item item in dm) &#123; Console.WriteLine(item); &#125; dm.ChgItem("干拌面", 9, 1); &#125;&#125; 组合模式定义允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 安全式和透明式组合模式： 透明式：以单一责任设计原则换取透明性。减少客户代码，失去了一些安全性。可能会抛出异常。 安全式：将责任区分开放在不同的接口中，符合单一责任原则。比较安全，但失去了透明性。客户代码必须判断类型，处理不同类型的节点。 类图 透明式的组合模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class Graphics&#123; protected string Name &#123; get; set; &#125; protected Graphics(string name) &#123; this.Name = name; &#125; public virtual void Draw() &#123; throw new NotSupportedException(); &#125; //默认抛出异常，避免叶对象或不合理的操作。 //简单图形（叶对象）Add或Remove方法没有任何意义 //如果客户端调用了将会抛出异常 public virtual void Add(Graphics g) &#123; throw new NotSupportedException(); &#125; public virtual void Remove(Graphics g) &#123; throw new NotSupportedException(); &#125;&#125;public class Line : Graphics&#123; public Line(string name) : base(name) &#123; &#125; public override void Draw() &#123; Console.WriteLine("画 " + Name); &#125;&#125;public class Circle : Graphics&#123; public Circle(string name) : base(name) &#123; &#125; public override void Draw() &#123; Console.WriteLine("画 " + Name); &#125;&#125;public class ComplexGraphics : Graphics&#123; public ComplexGraphics(string name) : base(name) &#123; &#125; private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() &#123; foreach (var item in list) item.Draw(); &#125; public override void Add(Graphics g) &#123; list.Add(g); &#125; public override void Remove(Graphics g) &#123; list.Remove(g); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Graphics complexGraphics = new ComplexGraphics("一个复杂图形和两条线段组成的复杂图形"); complexGraphics.Add(new Line("线段A")); Graphics l = new Line("线段B"); complexGraphics.Add(l); Graphics CompositeCG = new ComplexGraphics("一个圆和一条线组成的复杂图形"); CompositeCG.Add(new Circle("圆")); CompositeCG.Add(new Circle("线段C")); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine("复杂图形的绘制如下："); complexGraphics.Draw(); Console.WriteLine("复杂图形绘制完成\n"); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine("移除线段C后，复杂图形的绘制如下："); complexGraphics.Draw(); Console.WriteLine("复杂图形绘制完成"); &#125;&#125; 安全式的组合模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public abstract class Graphics&#123; protected string Name &#123; get; set; &#125; protected Graphics(string name) &#123; this.Name = name; &#125; public abstract void Draw(); // 移除了Add和Remove方法 // 把管理子对象的方法放到了ComplexGraphics类中进行管理 // 因为这些方法只在复杂图形中才有意义，且符合单一责任原则。&#125;public class Line : Graphics&#123; public Line(string name) : base(name) &#123; &#125; public override void Draw() &#123; Console.WriteLine("画 " + Name); &#125;&#125;public class Circle : Graphics&#123; public Circle(string name) : base(name) &#123; &#125; public override void Draw() &#123; Console.WriteLine("画 " + Name); &#125;&#125;public class ComplexGraphics : Graphics&#123; public ComplexGraphics(string name) : base(name) &#123; &#125; private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() &#123; foreach (var item in list) item.Draw(); &#125; public void Add(Graphics g) &#123; list.Add(g); &#125; public void Remove(Graphics g) &#123; list.Remove(g); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; ComplexGraphics complexGraphics = new ComplexGraphics("一个复杂图形和两条线段组成的复杂图形"); complexGraphics.Add(new Line("线段A")); Line l = new Line("线段B"); complexGraphics.Add(l); ComplexGraphics CompositeCG = new ComplexGraphics("一个圆和一条线组成的复杂图形"); CompositeCG.Add(new Circle("圆")); CompositeCG.Add(new Circle("线段C")); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine("复杂图形的绘制如下："); complexGraphics.Draw(); Console.WriteLine("复杂图形绘制完成"); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine("移除线段C后，复杂图形的绘制如下："); complexGraphics.Draw(); Console.WriteLine("复杂图形绘制完成"); &#125;&#125; 状态模式定义允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 类图 代码示例Machine： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Machine&#123; internal State SoldOutState &#123; get; set; &#125; //内部包装的状态 internal State NoCoinState &#123; get; set; &#125; internal State HasCoinState &#123; get; set; &#125; internal State SoldingState &#123; get; set; &#125; public int Count &#123; get; internal set; &#125; //对外暴露的显示 public int CoinCount &#123; get; internal set; &#125; internal State State &#123; get; set; &#125; public Machine(int count) &#123; SoldOutState = new SoldOutState(this); NoCoinState = new NoCoinState(this); HasCoinState = new HasCoinState(this); SoldingState = new SoldingState(this); Count = count; CoinCount = 0; State = count &gt; 0 ? NoCoinState : SoldOutState; &#125; public void Insert() &#123; State.Insert(); &#125; public void Eject() &#123; State.Eject(); &#125; public void Turn() //对外暴露的接口（按钮） &#123; State.Turn(); //内部执行的动作，由状态类负责 if (CoinCount &gt; 0) State.Give(); &#125; internal void SetState(State state) &#123; State = state; &#125; public void FillBall(int count) &#123; Console.WriteLine("上货" + count + "个"); Count += count; &#125; internal void ReleaseBall() &#123; Console.WriteLine("发放商品"); if (Count != 0) Count--; &#125; public override string ToString() &#123; return "\n============================\n自动售货机\n货物个数：" + Count + "\t当前状态：" + State + "\n============================\n"; &#125;&#125; 状态类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159internal abstract class State&#123; public abstract void Insert(); public abstract void Eject(); public abstract void Turn(); public abstract void Give(); protected virtual void Error() &#123; Console.WriteLine("错误操作"); &#125;&#125;internal class NoCoinState : State&#123; private Machine Mac &#123; get; set; &#125; public NoCoinState(Machine mac) &#123; Mac = mac; &#125; public override void Insert() &#123; Console.WriteLine("投入硬币"); Mac.CoinCount++; Mac.SetState(Mac.HasCoinState); &#125; public override void Eject() &#123; Error(); &#125; public override void Turn() &#123; Error(); &#125; public override void Give() &#123; Error(); &#125; public override string ToString() &#123; return "等待投入硬币..."; &#125;&#125;internal class HasCoinState : State&#123; private Machine Mac &#123; get; set; &#125; public HasCoinState(Machine mac) &#123; Mac = mac; &#125; public override void Insert() &#123; Error(); &#125; public override void Eject() &#123; Console.WriteLine("硬币归还"); Mac.CoinCount--; Mac.SetState(Mac.NoCoinState); &#125; public override void Turn() &#123; Console.WriteLine("转动"); Mac.SetState(Mac.SoldingState); &#125; public override void Give() &#123; Error(); &#125; public override string ToString() &#123; return "有硬币，可以转动..."; &#125;&#125;internal class SoldingState : State&#123; private Machine Mac &#123; get; set; &#125; public SoldingState(Machine mac) &#123; Mac = mac; &#125; public override void Insert() &#123; Error(); &#125; public override void Eject() &#123; Error(); &#125; public override void Turn() &#123; Error(); &#125; public override void Give() &#123; Mac.ReleaseBall(); if (Mac.Count &gt; 0) Mac.SetState(Mac.NoCoinState); else &#123; Console.WriteLine("已售罄"); Mac.SetState(Mac.SoldOutState); &#125; &#125; public override string ToString() &#123; return "正在出货..."; &#125;&#125;internal class SoldOutState : State&#123; private Machine Mac &#123; get; set; &#125; public SoldOutState(Machine mac) &#123; Mac = mac; &#125; public override void Insert() &#123; Error(); &#125; public override void Eject() &#123; Error(); &#125; public override void Turn() &#123; Error(); &#125; public override void Give() &#123; Error(); &#125; public override string ToString() &#123; return "已售罄..."; &#125;&#125; 测试代码： 1234567891011121314151617181920class Program&#123; static void Main(string[] args) &#123; Machine mac = new Machine(5); Console.WriteLine(mac); mac.Eject(); mac.Turn(); mac.FillBall(1); mac.Insert(); Console.WriteLine(mac); mac.Eject(); mac.Insert(); mac.Insert(); mac.Turn(); mac.Turn(); Console.ReadKey(); &#125;&#125; 模式配对 模式分类]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#入门经典_注释笔记]]></title>
    <url>%2F2017%2F02%2F26%2FC-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8_%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[checked关键字用来检查赋值是否数据溢出，或者在VS中配置，项目-属性-生成-高级，检查上溢下溢。 1234checked //unchecked 不检查&#123; destination = (int)source;&#125; 委托2种写法： 123Calcul cal=new Calcul(Add);Calcul cal=Add; 情况2自动初始化一个委托。 二维数组12int[,] ints = new int[10,4];ints[2, 2] = 1; ref out关键字ref out 等也可以改变函数的签名(命名+参数），从而实现重载 断点可以设置中断条件和击中次数。如，a&gt;=100，次数=100。 析构函数1234class MyClass&#123; ~MyClass()&#123; &#125;&#125; ~ 析构函数，垃圾回收器回收时自动调用，还将隐式调用基类的析构函数。 隐藏基类方法，在子类中定义时加123new public void Do()&#123; //...&#125; 类型比较1myObj.GetType()==typeof(MyObjClass) 对象类型的比较： myObj is objBase，myObj是objBase的子类，实现类，同类都为true。 重载运算符，例如：+需要在进行+运算的类内部定义。 不能重载+=，-=。但如果重载它们对应的简单运算符，如+，则+=仍能像预期那样执行 不能重载=，因为它有基本用途 不能重载&amp;&amp;和||，但同1理，重载&amp;和|就够了 &lt;和&gt;，&lt;=和&gt;=必须成对重载 123456789101112131415161718192021class Person&#123; public int Age &#123; get; set; &#125; public decimal Price &#123; get; set; &#125; public string Name &#123; get; set; &#125; public static Person operator +(Person p1, Person p2) &#123; return new Person &#123; Age = p1.Age + p2.Age &#125;; &#125; public static bool operator &gt;(Person left, Person right) &#123; return left.Age &gt; right.Age; &#125; public static bool operator &lt;(Person left, Person right) &#123; return left.Price &lt; right.Price; &#125;&#125; IComparable接口定义在要比较的对象的类中实现，类要实现IComparable接口。 123456public int CompareTo(object obj)&#123; var person = obj as Person; if (person == null) throw new ArgumentException("参数错误"); return Age - person.Age;&#125; 重写隐式(implicit)，显式(explicit)转换12345678910111213141516171819202122class Person1&#123; public int Age &#123; get; set; &#125; public static implicit operator Person2(Person1 p1) &#123; Person2 p = new Person2 &#123; Age = p1.Age &#125;; return p; &#125;&#125;class Person2&#123; public double Age &#123; get; set; &#125; public static explicit operator Person1(Person2 p2) &#123; Person1 p1 = new Person1(); checked &#123; p1.Age = (int)p2.Age; &#125; return p1; &#125;&#125; 同样可作用于泛型集合。 父子类相互转换1会报错，2不会报错。不能把父类实例转换成子类实例，只能把父类变量类型转换成子类变量类型。 1234567//1Person p = new Person();Man m = (Man)p;//2Person p1 = new Man();Man m1 = (Man) p1; 如果强转换成as 则都不会报错，1为null，2不为null。 ??运算符123int? val1 = null;int result = val1*5 ?? 10;int? result2=val1*5 ?? 10; ??等式的结果可以是int或int?，等式会自动进行转换。 default关键字如果T是引用类型，则输出null。 如果T是值类型，则输出默认值。e.g.int -&gt; 0。 123456class MyClass&lt;T&gt;&#123; public MyClass() &#123; Console.WriteLine(default(T)); &#125;&#125; 约束类型1234class MyClass&lt;T1, T2&gt; : MyClassBase where T1 : class,new () where T2 : T1&#123; &#125; 约束类型：struct值类型，class引用类型，base-class任意基类，interface接口，new()有一个公共无参构造函数 多个约束之间用，分隔 new()作约束必须是指定的最后一个 约束必须出现在继承说明符的后面 协变和抗变应用于泛型接口和委托，继承关系默认支持协变。 协变 123List&lt;string&gt; liststr = new List&lt;string&gt;();List&lt;object&gt; listobj = new List&lt;object&gt;();listobj.AddRange(liststr); //参数为IEnumerable&lt;object&gt; 定义： 123public class List&lt;T&gt; : IEnumerable&lt;T&gt;...public interface IEnumerable&lt;out T&gt; : IEnumerable 使用关键字out，则类型参数T只能作为方法的返回值 泛型类型参数可以从一个派生类隐式转化为基类，让一个带有协变参数的泛型接口（或委托）可以接收类型更加精细化，具体化的泛型接口（或委托）作为参数，可以看成OO中多态的一个延伸 抗变（逆变） 12345678910class MyComparer : IComparer&lt;object&gt;&#123; public int Compare(object x, object y) &#123; throw new NotImplementedException(); &#125;&#125;IComparer&lt;object&gt; comobj = new MyComparer();liststr.Sort(comobj); //参数为IComparer&lt;string&gt; 定义： 1public interface IComparer&lt;in T&gt; 使用关键字in，则类型参数T只能作为方法的参数 泛型类型参数可以从一个基类隐式转化为派生类，让一个带有协变参数的泛型接口（或委托）可以接收粒度更粗的泛型接口或委托作为参数，这个过程实际上是参数类型更加精细化的过程 总结： 协变让一个粗粒度接口（或委托）可以接收一个更加具体的接口（或委托）作为参数（或返回值）；逆变让一个接口（或委托）的参数类型（或返回值）类型更加具体化，也就是参数类型更强，更明确。 引发事件时，会依次调用程序列表中每个处理程序，只要它们满足指定的条件即可委托的应用12345678910111213delegate int OperationDelegate(int left,int right);void Function(OperationDelegate del)&#123; int left,right; //... del(left,right);&#125;void int OperationEx(int left,int right)&#123; return left+right; &#125; 用方法创建委托：void Function(new OperationDelegate(OperationEx)); 直接传递方法(默认创建委托)：void Function(OperationEx); 匿名方法：void Function(delegate(int left,int right){ return left+right; }); Lambda表达式： 123456void Function((left,right) =&gt; left+right); //参数类型不用指定，会通过上下文推断出类型Function((left,right) =&gt; (left-right)*right);//Lambda表达式本质还是委托//用Func&lt;string x,int y...&gt;来简化一个委托的定义。代替delegate xx.... Lambda表达式的解释可以用两种方式解释Lambda表达式。 第一，Lambda表达式是一个委托，可以把它表示为如下泛型类型： Action - lambda表达式不带参，返回void;Action&lt;&gt; - lambda表达式最多8个参数，返回void;Func&lt;&gt; - lambda表达式最多8个参数，返回不是void; e.g.Func lamb。前面的是参数，最后的bool是返回值。 第二，可以把Lambda表达式解释为表达式树: 并不能直接执行。LINQ架构的泛型类 Expression&lt;&gt;，可用于封装Lambda表达式，把它转换为相应的SQL脚本，以便在数据库中直接执行。 工作目录1234//设置当前工作目录，并不是转移文件！Directory.SetCurrentDirectory(Directory.GetCurrentDirectory()+"\\demo");//当前工作目录字符串Directory.GetCurrentDirectory(); FileStream12345678910111213FileInfo file = new FileInfo("test.txt");//创建一个只读的流FileStream stream = file.OpenRead();//创建一个只写的流FileStream stream1 = File.OpenWrite("test.txt");//将文件指针移动到文件的第8个字节，起始位置为第1个字节stream.Seek(8, SeekOrigin.Begin);//将指针从当前位置向前移动2个字节，则指向8+2=10个字节stream.Seek(2, SeekOrigin.Begin);//查找文件中倒数第5个字节stream.Seek(-5, SeekOrigin.End);//FileStream 操作字节或字节数组的流//Stream(StreamReader或StreamWriter)操作的是字符 FileStream读取数据123456789101112131415161718192021//读取本身cs文件 byte[] byData = new byte[200];char[] charData = new char[200];try&#123; FileStream stream = new FileStream("../../Program.cs", FileMode.Open); stream.Seek(110, SeekOrigin.Begin); stream.Read(byData, 2, 190);&#125;catch (Exception e)&#123; Console.WriteLine("AN IO Exception throw!"); Console.WriteLine(e.ToString()); Console.ReadKey(); throw;&#125;Decoder d = Encoding.UTF8.GetDecoder();d.GetChars(byData, 0, byData.Length, charData, 0);Console.WriteLine(charData); FileStream写入123456789101112131415161718byte[] byData;char[] charData;try&#123; FileStream file = new FileStream("test1.txt", FileMode.Create); charData = "This is a charData array!".ToCharArray(); byData = new byte[charData.Length]; Encoder encoder = Encoding.UTF8.GetEncoder(); encoder.GetBytes(charData, 0, charData.Length, byData, 0, true); file.Seek(0, SeekOrigin.Begin); file.Write(byData, 0, byData.Length);&#125;catch (Exception)&#123; //... throw;&#125; StreamReader/Writer的权限StreamReader/Writer 总是拥有对文件的读写权限，为了使用高级参数如，FileMode,FileAccess，可以在FileStream构造函数指定这些参数，然后通过FileStream创建StreamReader/Writer。 读取数据的选择1，小文件，StreamReader.ReadToEnd(); 2，大型文件，StreamReader.ReadLine(); 循环判断是否为空或者 1234567foreach (var item in File.ReadLines("test.txt",Encoding.Default))&#123; Console.WriteLine(item);&#125;File.ReadLines 一次读取一行，迭代读取。返回IEnumerable&lt;string&gt;File.ReadAllLines 打开一个文件，读取文件的所有行，然后关闭文件。返回string[] 压缩和解压缩类 输入读取类System.IO.Compression 123456789101112131415161718static void SaveCompressedFile(string fileName, string data)&#123; FileStream file = new FileStream(fileName, FileMode.Create, FileAccess.Write); GZipStream zip = new GZipStream(file, CompressionMode.Compress); StreamWriter sw = new StreamWriter(zip,Encoding.Default); sw.Write(data); sw.Close();&#125;static string LoadCompressedFile(string fileName)&#123; FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read); GZipStream zip = new GZipStream(file, CompressionMode.Decompress); StreamReader sr = new StreamReader(zip, Encoding.Default); string data = sr.ReadToEnd(); sr.Close(); return data;&#125; C#6.0 新特性 字符串插值（String Interpolation） 之前： 12var Name = "Jack";var results = "Hello" + Name; 或者 var results = string.Format("Hello &#123;0&#125;", Name); Now： 1var results = $"Hello &#123;Name&#125;"; 之前： 12Person p = new Person &#123;FirstName = "Jack", LastName = "Wang", Age = 100&#125;;var results = string.Format("First Name: &#123;0&#125; LastName: &#123;1&#125; Age: &#123; 2&#125; ", p.FirstName, p.LastName, p.Age); Now： 1var results = $"First Name:&#123;p.FirstName&#125; LastName:&#123;p.LastName&#125; Age：&#123;p.Age&#125;"; 还可以插入代码 - 相当于小脚本或Razor 的@{ }，不过只能作用于string。 1Console.WriteLine($"Jack is saying &#123; new Tools().SayHello() &#125;"); 空操作符 ( ?. ) 之前： 1234if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0)&#123; Console.WriteLine(user.Project.Tasks.First().Name);&#125; Now： 1Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 还可用于数组索引器： 123User[] users = null;Console.WriteLine(users?[1].Name); // 正常Console.WriteLine(users[1]?.Name); // 报错 以下代码并不会报错，也不会有输出。减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常。那么使用这个特性反而隐藏了Bug。 12User user = null;user?.SayHello(); C#6.0 新特性 2 NameOf 123Console.WriteLine(nameof(User.Name)); // output: NameConsole.WriteLine(nameof(System.Linq)); // output: LinqConsole.WriteLine(nameof(List&lt;User&gt;)); // output: List NameOf只会返回Member的字符串，如果前面有对象或者命名空间，NameOf只会返回 . 的最后一部分, 另外NameOf有很多情况是不支持的，比如方法，关键字，对象的实例以及字符串和表达式。 表达式方法体 一句话的方法体可以直接写成箭头函数，而不再需要大括号。 1234private static string SayHello() =&gt; "Hello World";private static string JackSayHello() =&gt; $"Jack &#123;SayHello()&#125;";Console.WriteLine(SayHello());Console.WriteLine(JackSayHello()); 序列化对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.IO;using System.Runtime.Serialization;using System.Runtime.Serialization.Formatters.Binary;[Serializable]class Product&#123; public long Id; public string Name; public double Price; [NonSerialized] string Notes; public Product(long id, string name, double price, string notes) &#123; Id = id; Name = name; Price = price; Notes = notes; &#125; public override string ToString() &#123; return $"&#123;Id&#125;：&#123;Name&#125; ($&#123;Price:F2&#125;) &#123;Notes&#125;"; &#125;&#125;//Main中List&lt;Product&gt; list = new List&lt;Product&gt;()&#123; new Product(1,"Pung",1000.0,"Good stuff."), new Product(2,"Soup",25.0,"Tasty."), new Product(4,"Hat Sauce",12.0,"One for the kids.")&#125;;Console.WriteLine("Products to save:");list.ForEach(p =&gt; Console.WriteLine(p.ToString()));IFormatter serializer = new BinaryFormatter();FileStream file = new FileStream("Products.bin", FileMode.Create, FileAccess.Write);serializer.Serialize(file, list);file.Close();FileStream fileLoad = new FileStream("Products.bin", FileMode.Open, FileAccess.Read);List&lt;Product&gt; list2 = serializer.Deserialize(fileLoad) as List&lt;Product&gt;;fileLoad.Close(); 监控文件12345678910111213141516171819202122232425private FileSystemWatcher watcher;public Form1()&#123; watcher = new FileSystemWatcher(); watcher.Deleted += new FileSystemEventHandler(OnDelete); watcher.Renamed += new RenamedEventHandler(OnRenamed); InitializeComponent();&#125;public void OnRenamed(object source, RenamedEventArgs e)&#123; StreamWriter sw = new StreamWriter(@"F:\Logs\log.txt", true); sw.WriteLine($"File renamed from &#123;e.OldName&#125; to &#123;e.FullPath&#125;"); sw.Close();&#125;public void OnDelete(object source, FileSystemEventArgs e) //...private void btnWatch_Click(object sender, EventArgs e)&#123; watcher.Path = Path.GetDirectoryName(txtLocation.Text); watcher.Filter = Path.GetFileName(txtLocation.Text); watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size; watcher.EnableRaisingEvents = true;&#125; XPath查询xml语言123456XmlDocument xml = new XmlDocument();xml.Load("../../Demo.xml");XmlElement e = xml.DocumentElement;var node = e.SelectSingleNode("Book[Title='韩寒']");Console.WriteLine(node.SelectSingleNode("Content").InnerText);xml.Save("../../Demo.xml"); LINQ查询大数集合12345678910111213141516171819202122232425private static int[] GetNumbers(int count)&#123; Random ran = new Random(0); int[] result = new int[count]; for (int i = 0; i &lt; count; i++) &#123; result[i] = ran.Next(); &#125; return result;&#125;static void Main(string[] args)&#123; var nums = GetNumbers(12345678); var query = from n in nums where n &gt; 1000 select n; Console.WriteLine(query.Count()); Console.WriteLine(query.Max()); Console.WriteLine(query.Min()); // 默认版本.Sum()返回的是int，数值太大导致溢出 Console.WriteLine(query.Sum(p=&gt;(long)p)); Console.WriteLine(query.Average()); Console.ReadKey();&#125; LINQ 2单值查询：.Distinct()（只选取没有重复的元素）任意符合：.Any()（任意元素符合条件返回true）全部符合：.All()（全部元素符合条件返回true） .First()和.FirstOrDefault()区别： .First()当条件不满足时，抛出异常;.FirstOrDefault()当条件不满足时，返回一个null; LINQ 3集运算符： .Intersect()：使用默认的相等比较器得出两个序列的交集.Except()：同上，得出差集.Union()：同上，得出并集 Join查询： 1234var orderIds = from n in list select n;var customers=from n in list join m in orderIds on n.Id equals m.Id //equals 关键词，必须 select n.Amount+m.Amount; LINQ TO XML12345678910111213141516171819202122232425262728293031323334353637//从字符串转换XDocument d1 = XDocument.Parse(@" &lt;customers ID=""A"" City=""NY"" Region=""North American""&gt; &lt; order Item = ""Widget"" Price = ""100"" /&gt; &lt; order Item = ""Tire"" Price = ""200"" /&gt; &lt;/ customers &gt; ");XDocument doc = new XDocument( //内部有其他元素，则有闭合标签 new XElement("customers", new XAttribute("ID", "A"), new XAttribute("City", "NY"), new XAttribute("Region", "North American"), //内部没有其他元素，则自闭 new XElement("order", new XAttribute("Item", "Widget"), new XAttribute("Price", 100) ), new XElement("order", new XAttribute("Item", "Tire"), new XAttribute("Price", 200) ) ));string path = "../../demo.xml";doc.Save(path);XDocument d = XDocument.Load(path);Console.WriteLine(d);var query = from n in doc.Descendants("order") select n.Name;//.Elements()返回第一级子元素//.Descendants()返回所有子元素// 重载形式可以指定元素名//.Attributes()返回当前元素所有特性]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F02%2F26%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576$ git config --global user.name "John Doe" //设置用户名邮箱--global 只针对当前用户$ git config --global user.email johndoe@example.com //去掉--global，针对特定项目使用不同的账号$ git config -l //列出所有设置$ git config --global alias.ci commit //设置别名$ git config --global alias.last 'log -1 HEAD' //看最后一次提交$ git config --global alias.visual '!gitk' //外部命令，+!$ git config --global credential.helper cache //缓存验证密码$ git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative" //改造log显示，推荐$ git init //在现有目录中初始化仓库$ git add //如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。add *$ git commit -a //跳过暂存，直接提交$ git log [-p] [-2] //提交记录。显示提交的差异。只显示2条。$ git log --oneline --decorate --graph --all //输出提交历史、各个分支的指向以及项目的分支分叉情况$ git status -s //更为紧凑的格式输出$ git clone https://github.com/libgit2/libgit2 [mylibgit] //克隆现有的仓库，当前目录下创建一个名为 `libgit2'' 的目录，并在这个目录下初始化一个 `.git 文件夹。[自定义文件夹命名]。命令会自动将其添加为远程仓库并默认以origin为简写。设置本地 master分支跟踪克隆的远程仓库的 master 分支。$ git clone -o booyah //自定义远程分支名字。创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master 。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。$ git diff //查看上次暂存之后的变动$ git diff --staged //查看已经暂存的变动$ git rm 1.txt //删除文件，跟踪清单和本地$ git rm --cached README //仓库中删除（亦即从暂存区域移除） ，但保留在当前工作目录中$ git mv 1.txt dir/2.txt //移动文件，也可重命名$ git checkout a.md //还原成上次提交时的样子，只能撤销没add进暂存区的文件$ git reset HEAD 1.txt //取消暂存区中的文件$ git commit --amend //重新提交，覆盖上次提交$ git remote //查看已经配置的远程仓库$ git remote -v //显示需要读写远程仓库使用的 Git 保存的简写与URL$ git remote add &lt;shortname&gt; &lt;url&gt; //添加一个新的远程 Git 仓库$ git remote show origin // URL 与跟踪分支的信息$ git remote rename pb paul //修改一个远程仓库的简写名$ git remote rm paul //移除一个远程仓库$ git push origin v1.5 //推送标签到远程$ git push origin --tags //推送远程没有的所有标签$ git push origin --delete serverfix //删除远程分支$ git fetch origin master[:newb] //拉取pb的仓库中有但你没有的信息[并新建成分支newb]$ git checkout -b master origin/master //新建本地分支映射远程分支 $ git pull //自动的抓取然后合并远程分支到当前分支=fetch+checkout$ git push origin master //推送到远程仓库的某一分支。需要：拥有写入权限，且本地与远程数据同步时。$ git tag //列出已有的标签$ git tag -l 'v1.8.5*' //只对 1.8.5 系列$ git tag -a v1.4 -m 'my version 1.4' //创建一个附注标签$ git show v1.4 //标签信息$ git tag v1.4-lw //创建轻量标签，没有保存任何其他信息$ git tag //查看$ git tag -a v1.2 9fceb02 //后期打标签 $ git checkout -b version2 v2.0.0 //在特定的标签上创建一个新分支$ git stash //暂存当前所有改动$ git stash list //查看暂存记录$ git stash apply //还原已暂存代码$ git stash drop [stash_id] //删除暂存记录，[删除某条]$ git stash pop //快捷：还原+删除$ git stash clear //清空暂存区记录$ git branch [--merged/--no-merged] //分支列表,[查看已/未与当前分支合并的分支],如与master合并的分支可以删除，无损失$ git branch -v //查看每个分支最后一次提交$ git branch -a //查看所有分支（远程和本地）$ git branch -r //查看所有远程分支$ git branch testing //分支创建$ git checkout testing //分支切换$ git checkout -b iss53 //新建并切换到新分支$ git checkout -b serverfix origin/serverfix //在某分支之上建立分支$ git checkout master //合并分支①$ git merge iss53 //合并分支②$ git branch -d hotfix //删除分支$ git rebase master //以master为基底进行变基，重演experiment的提交过程，并清理提交历史。只对尚未推送或分享给别人的本地修改执行变基操作清理历史$ git checkout master //往回切换到master分支$ git merge experiment //master快进到目标点 忽略列表(.gitignore)12345678910\* //匹配零个或多个任意，*.a //支持glob模式(简化正则表达式)[abc] //匹配a或b或c? //只匹配一个任意字符!lib.a //忽略lib.a以外的文件[0-9] //匹配所有 0 到 9 的数/*.txt //只忽略当前文件夹下的文件，不包括子目录 a/*.txtbuild/ //忽略所有build/目录下的文件doc/**/*.pdf //忽略所有.pdf文件在doc/ 目录下\*\* //匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或a/b/c/z 等]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法示例]]></title>
    <url>%2F2017%2F02%2F26%2FMarkdown%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[基础标题123456#一级标题##二级标题###三级标题####四级#####五级######六级 列表123456789无序列表- 1- 2- 3有序列表1. 1 2. 23. 3 1 2 1 2 文本1*斜体* **粗体** 斜体 粗体 1&gt; 这里是引用 这里是引用 链接1[Baidu](http://www.baidu.com &quot;百度&quot;) Baidu 1234I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from Google than fromYahoo or MSN. 1![Logo](http://cdn-qn0.jianshu.io/assets/web/logo-58fd04f6f0de908401aa561cda6a0688.png &quot;简书&quot;) 1See my [Markdown语法示例](/Markdown语法示例) page. See my Markdown语法示例 page. 代码12`public void Add()` //局部代码块 public void Delete() //一个tab或四个空格 public void Add() public void Delete() Html123&lt;div style=&quot;color:red;&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; &copy; 2004 Foo Corporation 反义符号 ‘\’11986\. What a great season. 1986. What a great season. 未转义：11986. What a great season. What a great season. 进阶内容目录1[TOC] *这里不支持 删除线1~~ 表示删除线。 删除的文本 增强代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 12345678910111213141516/*** @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 表格1234|列首1|列首2|列首3|列首4||-:|:-: 右对齐，居中，左对齐(默认)|单元格|单元格|单元格|单元格||单元格|单元格|单元格|单元格| 列首1 列首2 列首3 列首4 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个Todo列表，支持嵌套以及混用Markdown语法 - [ ] **待办** - [ ] *取快递* - [x] 工作安排 - [x] 本季度绩效统计 [Google 表格](https://docs.google.com/spreadsheets/) 对应显示如下待办事宜 Todo 列表： 待办 取快递 工作安排 本季度绩效统计 Google 表格]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>

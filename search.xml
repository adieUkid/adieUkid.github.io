<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python编程：从入门到实践]]></title>
    <url>%2F2018%2F07%2F30%2FPython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[字符串1234567name.title() # 首字母大写name.upper() name.lower() # 转换大小写name.rstrip() name.lstrip()name.strip() # 删除右边/左边/两边的空格"age" + 12 # 会报错，应使用str()方法将数字转换成字符串 列表元素操作123456list.append(item) # 新增list.insert(0,item) # 插入del list[1] # 删除某索引元素list.pop() # 删除列表末尾元素，并返回它list.pop(2) # 弹出列表中某索引的元素，并返回它list.remove('alan') # 根据值来删除元素，只删除第一个符合的 组织列表1234list.sort() # 永久排序，改变自身sorted(list) # 临时排序，不改变列表list.reverse() # 按索引反转列表，改变自身len(list) # 计算列表长度 操作列表遍历12for item in list: pass 创建数值列表1range(1,5) # 左闭右开，1,2,3,4 简单统计123min(list)max(list)sum(list) 列表推导式1squares = [item**2 for item in range(1,11)] # 返回从1-10的平方的列表 切片123list[0:3] # 返回索引为0-2的元素列表，左闭右开list[:3] # 冒号左边缺省则默认从0，右边缺省则默认列表的lengthlist[:] # 浅复制整个列表 元组tuple = (30,100)不可变的列表称为元组遍历元组同列表一样，元组元素不可修改，但是可以重新定义整个元组变量 字典dict = {} 12345678910111213141516171819dict['name'] = 'alan' # 新增/更新del dict['name'] # 删除dict.pop('name') # 删除并返回items() # 返回由字典每一对键值构成的元组的列表keys() # 返回字典所有键组成的列表values() # 返回值的列表for key,value in dict.items(): # 遍历 passfor key in sorted(dict.keys()): # 按字符顺序遍历 passfor value in set(dict.values()): # 获取唯一不重复的值 passif 'name' in dict.keys(): # 判断键值是否存在 pass while循环假值123456d = &#123;&#125;l = []set1 = set()t = tuple()i = 0str1 = '' 假值转换为bool时为False,如if not set1:/while l: 移动元素12345arr1 = ['str1', 'str2', 'str3']arr2 = []while arr1: arr2.append(arr1.pop()) 删除特定元素1234arr1 = ['str1', 'str2', 'str3', 'str1']while 'str1' in arr1: arr1.remove('str1') 函数定义1234567891011121314151617181920def funcname(p1, p2='dog'): # 可选参数 passfuncname('123', p2='cat') # 通过关键字传递实参funcname( arr[:] ) # 传递列表副本，避免被函数内部修改def make(name,*args): # 可传递任意数量的实参，必须放在其他形参之后 print(args) # 创建一个参数组成的元组make('a1','a2','3') make() # 空元组 def make(name, **kwargs): # 传递任意数量的关键字实参 profile = &#123;'name': name&#125; for key, value in kwargs.items(): profile[key] = value return profileprint make('alan', age=20, gender='male') 导入123import make as m # 设置别名from make import remake # 导入特定函数from make import * # 导入所有函数，调用时不再需要模块名前缀 类定义类和方法123456789class Dog(): # python 3.x def __init__(self, name): # self代表实例自身的引用 self.name = name def sit(self): print(self.name+"is sitting")class Dob(object): # python 2.7 pass 继承12345678910111213141516171819202122232425262728# car.py"""this is a car module"""class Car(): def __init__(self, model): self.model = model def fill_gas(self): print('filling')class ElectricCar(Car): def __init__(self, model): super().__init__(model) def fill_gas(self): print('not need gas')from car import ElectricCarc = ElectricCar('ss')c.fill_gas()from car import Car,ElectricCar # 导入模块中的多个类import car # 导入整个模块from car import * # 导入模块中的所有类 Python标准库123456789# OrderedDictfrom collections import OrderedDictdict = OrderedDict()dict['sarah'] = 'c'dict['jen'] = 'python'dict['phil'] = 'ruby'print(dict) 有序字典，保留数据初始时的顺序 编码风格：类名：驼峰命名法，首字母大写，不使用下划线实例名和模块名：小写，单词之间加下划线模块和类都要包含一个文档字符串空行的使用：类中使用一个空行分隔方法，模块中使用两个空行来分隔类导入模块时，先导入标准库模块，再添加一个空行，然后导入自己编写的模块 文件和异常文件读取1234567891011with open('test.txt') as txt: # 一次读取一行 for row in txt: print(row.strip()) # 读取全部内容 print(txt.read()) # 加载到list中 lines = txt.readlines() # list 写入123with open('test.txt','w') as txt: txt.write()('123123\n') txt.write()('abcabc\n') 参数说明：r - 读取模式r+ - 读取和写入w - 写入模式a - 附加模式w和a模式，当文件不存在时则创建 异常ZeroDivisionError：除以0时抛出FileNotFoundError：文件未找到时抛出 1234567try: --skip--except FileNotFoundError as e: #发生异常 pass else: #未发生异常时 --skip-- 存储数据json存储和读取12345678import jsondic = &#123;'name': 'alan', 'age': 12&#125;with open('text.txt', 'a') as txt: json.dump(dic, txt) # 存储with open('text.txt', 'r') as txt: re = json.load(txt) #读取 print(type(re)) #dict，自动转换类型 单元测试12345678910111213141516import unittestfrom car import Carclass TestCarMethod(unittest.TestCase): #测试用例，包含多个单元测试 def setUp(self): self.c = Car() #setUp方法，初始化下面要用到的数据 def test_set(self): re = self.c.set_wheels(5) self.assertFalse(re) #断言方法，表达式是否为False def test_get(self): wheels = self.c.get_wheels() self.assertIn(wheels, range(1, 5)) #值是否包含于列表中unittest.main() 运行测试用例时，每完成一个单元测试，通过时打印一个句点。引发错误时打印一个E，断言失败时打印F]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级程序设计-注释笔记]]></title>
    <url>%2F2018%2F02%2F04%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本概念解释型和编译型语言的区别 编译型 需要编译器。把高级语言编译为机器码文件，编译期代码检查，执行速度更快，一次编译处处执行，可移植性更好。如：Java，C#等。 解释性 需要解释器。解释器直接读入源代码，边解释（编译）边执行。错误只能等到解释器执行的有关代码时才能被发现，再次运行，需要重新解释，速度较慢。如：JS，Python等。 完整的JavaScript的三个部分 核心（ECMAScript） 与Web浏览器没有依赖关系，是基础。定义了： 语法，类型，语句，关键字，保留字，操作符，对象 文档对象模型（DOM） 针对XML但经过扩展用于HTML的API。 DOM1级，包括DOM核心（DOM Core）和DOM HTML。 浏览器对象模型（BOM） 处理浏览器和框架 严格模式&quot;use strict&quot; 编译指示，为了不破坏ECMAScript 3语法，一些不确定的行为将得到处理，对于某些不安全的操作也会抛出错误。 局部域定义全局变量123function test()&#123; msg = "hi"; // 全局变量&#125; 并不推荐，很难维护。相应变量不会马上就有定义导致混乱。 数据类型undefined,null,boolean,number,string typeof 操作符未定义 - undefined布尔值 - boolean字符串 - string数值 - number对象或null - object函数 - function 从技术上来讲，函数在ECMAScript中是对象，不是一种数据类型。然后函数有一些特殊的属性，typeof得到的值也不同于对象 undefined类型12345var v1; //声明之后默认取得undefined值alert(v1); //"undefined"alert(v2); //引用错误alert(typeof v1) //"undefined"alert(typeof v2) //"undefined" null类型typeof null //返回 object 适用于，准备将变量用于保存对象，那么最好将变量初始化为null，而不是其他值。使用 if(obj != null)来判断是否已经保存对象的引用。 undefined值派生自null值，所以null == undefined 返回ture。 boolean类型123456if (true) &#123; //通过，区分大小写 alert(1)&#125;if (True) &#123; //不通过，不是Boolean值，只是标识符 alert(1)&#125; Boolean()函数，传入任何参数总会返回Boolean值。规则如下： 类型 返回true 返回false Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 null Undefined N/A（不适用） undefined 不传参数，返回false。 if()语句，自动执行Boolean()函数。 Number类型 整数值： 整数值可以以十进制，八进制，十六进制来表示。 1234var num=070; //前导0，十进制的56var num=079; //无效，前导0被忽略，解析为79var num=0xA; //前导0x，十进制的10var num=0x1z //无效，报错 浮点数值： 12345var num=1.; //解析为整数，1var num=10.0; //解析为整数，10简写：var num=3.12e7; //3.12乘以10的7次方var num=3.12e-7; //3.12乘以0.1的7次方 PS：0.1+0.2 == 0.3 返回false，因为ECMAScript的浮点运算基于IEEE754，存在二进制和十进制的小数点转换问题，并非独此一家。 数值范围 12345alert(Number.MAX_VALUE + Number.MAX_VALUE) //返回Infinityalert(-1 * (Number.MAX_VALUE + Number.MAX_VALUE)) //返回-InfinityNumber.POSITIVE_INFINITY //保存着InfinityNumber.NEGATIVE_INFINITY //保存着-InfinityisFinite() //判断是否是有穷的，Infinity返回false，MAX_VALUE返回ture，MAX_VALUE+1返回ture NaN 任何涉及NaN的计算，返回都是NaN。 NaN与任何值都不相等，包括NaN本身。NaN == NaN ，返回false。 12345isNaN(NaN) //trueisNaN(10) //falseisNaN("10"/"") //false ，可被转换成数值10/0isNaN("blue") //true，不能转换isNaN(ture/false) //false，可别转换成数值1 数值转换 Number()，用于任何数据类型 规则： Boolean，ture和false分别转换为1和0 数字，直接返回 null，返回0 undefined，返回NaN 字符串：整数，浮点数，对应的十进制。有效的十六进制，等值的十进制整数。空字符串，0；包含其他字符，NaN 对象，先调用valueOf()方法，然后按照前面的规则转换返回的值，如果结果为NaN。再调用toString()方法。然后转换返回的字符串 parseInt()，parseFloat()，转换字符串。 String类型123var num=10;num.toString() //'10'num.toString(2) //'1010' 2/8/10/16，转换成相应的进制 Object类型常用属性/方法： Constructor：保存着用于创建当前对象的构造函数。 hasOwnProperty(name)：检查给定的属性在当前对象实例中是否存在。 toString() valueOf()，返回对象的字符串，数值或布尔值表示 BOM和DOM中的对象，属于宿主对象。可能不会集成Object。 操作符乘法有一个数是NaN，结果是NaN。Infinity与0相乘，结果是NaN。Infinity与非0相乘，结果是Infinity或-Infinity，取决于操作数的符号。如果是Infinity与Infinity相乘，结果是Infinity。如果一个不是数值，则调用Number()转换为数值后再相乘。 除法一个数是NaN，结果NaN。Infinity被Infinity除，结果是NaN。0被0除，结果NaN。非零有限数被0除，结果是Infinity或-Infinity，取决于符号。(-1/0)Infinity被非零数除，结果是Infinity或-Infinity，取决于符号。一个操作数不是数值，同乘法。 加法123Infinity+Infinity=Infinity-Infinity-Infinity=-InfinityInfinity-Infinity=NaN 如果一个操作数是字符串，调用他们的toString()得到字符串（undefined和null调用String()返回字面量），然后拼接。两个都是字符串，则直接拼接。没有字符串，则先调用Number()转换为数值，再进行加法。 减法1234Infinity-Infinity=NaN-Infinity+Infinity=NaNInfinity+Infinity=Infinity-Infinity-Infinity=-Infinity 如果一个操作数是字符串，布尔值，null或undefined，则先调用Number()函数转换为数值，再根据规则进行减法。如果转换为NaN，则结果是NaN。 +/- 操作符对非数值应用一元操作符时，会先执行Number()函数转换，然后在转为正/负数。 123456+"01" //1-"01" //-1+"z" //NaN-"z" //NaN+false //0-false //0 比较操作符两个字符串，比较两个字符串对应的字符编码值。一个数值，一个非数值，先进行数值转换。一个对象，则调用valueOf()方法，没有则调用toString()方法。再比较。 12345"a" &gt;/&lt; 3 //false，先进行转换"a"-&gt;NaN"a" &gt; "3" //true"23" &lt; "3" //true"23" &gt; 3 //true任何数与NaN比较，结果都是false 相等和不相等默认先进行强制转型，再比较。字符串/布尔，先转换，再比较。一个对象，一个不是，则调用对象的valueOf方法。两个都是对象，则比较是不是同一个对象。null和undefined是相等的，且比较时都不会执行转换。 特殊情况： 1234567891011null == undefined //trueundefined == 0 //falsenull == 0 //false"NaN" == NaN //falseNaN == 5 //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //false"5" == 5 //true 语句for-in语句可以用来枚举对象的属性1234for (var prop in window) &#123; var element = window[prop]; console.log(prop + ' ' + element)&#125; switch语句可以使用任何数据类型，case的值可以是常量，变量，或者表达式123456789101112var num = 12;switch (true) &#123; case num &gt; 10: alert("&gt;") break; case num &lt; 10: alert("&lt;") break; default: alert("=") break;&#125; 函数定义时不必制定是否返回值。 严格模式下，不能把函数/参数命名为eval或arguments，不能有连个同名参数。 参数ECMAScript函数不介意传递进多少个参数，不也在乎参数类型。定义和实际传递的参数没有个数与对应关系的限制。因为，参数在内部是用一个类似数组的对象（Arguments对象，并不是真的数组）来表示的。而不关心数组中包含哪些参数。12345name(1) //length 为1name(1,2) //length 为2function name() &#123; alert(arguments[0]) &#125; 命名参数只提供便利，但不是必须的。解析器不会验证命名参数。1234function add(num1,num2)&#123; arguments[1]=10; alert(arguments[0]+num2);&#125; 修改了arguments[1]的值，也就修改了num2，他们的值都会改变。不过它们的内存空间是独立的，但它们的值会同步。 arguments.callee返回的是当前执行的函数。 js的函数没有重载，重复定义的函数不论参数列表，后定义的函数会覆盖前面的函数。但可以使用arguments对象来模拟实现。 变量、作用域和内存基本类型和引用类型传递参数ECMAScript所有函数的参数都是按值传递。对于引用类型(对象)来说，不会改变原始引用，只会根据引用改变对象的成员。12345678910var p = &#123; name: 'bily' &#125;;set(p);alert(p.name)①function set(p) &#123; p = &#123;&#125;; p.name = 'alan';&#125;②function set(p) &#123; p.name = 'alan';&#125; ①，弹出bily。②，弹出alan。 检测类型12345678910111213141516171819typeof：var s = "Nicholas";var b = true;var i = 22;var u;var n = null;var o = new Object();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //Booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof o); //objectinstanceof： 检测对象的具体类型alert(&#123;&#125; instanceof Object); //所有对象，都返回turealert([] instanceof Array); alert(/^.$/ instanceof RegExp); 执行环境与作用域 每个函数都有自己的执行环境和作用域，但js没有块级作用域。例如if和for等语句。但是也有例外，例如catch和with语句。 查询标识符在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。从作用域链的前段开始，向上逐级查询。局部找到，则搜索停止。否则一直向上追溯到全局环境的变量对象，如果都没有找到，则意味着该变量未声明。 垃圾回收 引用类型Object类型Array类型创建12345var colors = ["red", "blue", "green"];colors[colors.length] = "black"; //结尾添加colors[99] = "black";alert(colors.length); //100alert(colors[50]); //undefined 检测arr instanceof Array //true/false 假定单一的全局执行环境，如果网页包含多个框架，则可能出现问题。为了解决这个问题，ECMAScrit新增了能检测iframes的方法 Array.isArray(arr) //true/false IE9+ 转换方法12345var colors = ["red", "blue", "green"]; alert(colors.toString()); //red,blue,greenalert(colors.valueOf()); //red,blue,greenalert(colors); //red,blue,green。自动执行toString()方法alert(colors.join("||")); //red||green||blue。改变分隔符。 栈方法：LIFO123456var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); var item = colors.pop(); //弹出末端最后的元素 alert(item); //"black"alert(colors.length); //2 队列方法：FIFO1234567891011121314var colors = []; var count = colors.push("red", "green"); count = colors.push("black"); alert(count); //3var item = colors.shift(); //移除头部第一个元素alert(item); //"red"alert(colors.length); //2//反向的队列：var colors = []; var count = colors.unshift("red", "green"); // 0,1 count = colors.unshift("black"); //从头部插入，成为第一个元素，索引为0var item = colors.pop(); alert(item); //"green" 排序方法1234var values = [0, 1, 5, 10, 15];values.sort(); //正向 0,1,10,15,5 //sort方法默认会调用每项的toString()转型方法，然后比较得到的字符串。values.reverse(); //反向 自定义排序1234567function compare(value1, value2) &#123; return value2-value1;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);values.reverse(compare); 操作方法：增，减，替换 concat 返回新构建的数组副本 1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]); alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice 返回当前数组截取的副本 12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice 删除，插入，替换数组元素。返回删除项组成的数组，直接影响原数组 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); alert(colors); //green,bluealert(removed); //red (数组)removed = colors.splice(1, 0, "yellow", "orange"); alert(colors); //green,yellow,orange,bluealert(removed); //空数组removed = colors.splice(1, 1, "red", "purple"); alert(colors); //green,red,purple,orange,bluealert(removed); //yellow(数组) 数组的迭代方法 every()，对每一项运行给定函数，如果该函数对每一项都返回ture，则返回ture some()，对每一项运行给定函数，如果该函数对任一项返回ture，则返回ture filter()，对每一项运行给定函数，返回该函数会返回ture的项组成的数组 map()，对每一项运行给定函数，返回每次函数调用的结果组成的数组 forEach()，对每一项运行给定函数。无返回值。 1234567891011121314151617181920var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(someResult); //truevar filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3]var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 缩小方法接受4个参数，前一个值，当前值，当前索引，数组对象。函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项。12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); reduceRight从反方向执行。 Date类型创建1234567var now = new Date() //新创的对象自动获得当前日期时间。var someDate = new Date(Date.parse("May 25, 2004"));var someDate = new Date("May 25,2004"); //默认调用Date.parse()var y2k = new Date(Date.UTC(2000, 0));var y2k = new Date(2000, 0);var allFives = new Date(2005, 4, 5, 17, 55, 55); 格式化 RegExp类型正则表达式模式 12var pattern=/[bc]at/i;var pattern=new RegExp("[bc]at","i"); 实例属性 exec()12345678910var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text); //返回包含第一个匹配项信息和额外信息的数组。alert(matches.index); //0alert(matches.input); //"mom and dad and baby"alert(matches[0]); //"mom and dad and baby"alert(matches[1]); //" and dad and baby"alert(matches[2]); //" and baby" [0]，与整个模式匹配的字符串[1][2]，与模式中的捕获组（？）匹配的字符串。没有捕获组则不存在。模式g，不设置则多次调用exec()将始终返回第一个匹配项的信息。设置则每次调用exec()都会在字符串中继续查找剩余的新匹配项。 构造函数属性123456789101112var text = "this has been a short summer";var pattern = /(.)hort/g;if (pattern.test(text))&#123; //可换成exec()，不反回ture/false。返回一个数组 alert(RegExp.input); //this has been a short summer alert(RegExp.leftContext); //this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); //short alert(RegExp.lastParen); //s alert(RegExp.multiline); //false 。IE，Chrome等不支持 alert(RegExp.$1); //$1~$9，自动存储匹配的捕获组，exec()和test()方法时自动填充。&#125; Function类型定义“函数是对象，函数名是指针”每个函数都是Function类型的实例，具有属性和方法。函数名不与某个函数绑定，只是一个指向函数对象的指针。 function sum(){…} 等于 var sum=function(){…}所以JS没有重载，声明同一个函数两次，函数名指向最后赋值的函数对象。 函数声明与函数表达式12345678910111213①alert(sum(10,10)); //20function sum(num1, num2)&#123; return num1 + num2;&#125; //不会报错。解析器会进行函数声明提升的过程，率先读取函数声明，并使其在执行任何代码之前可访问。②alert(sum(10,10)); var sum = function(num1, num2)&#123; return num1 + num2;&#125;; //报错，解析器进行到表达式时，sum才被保存对函数的引用。 作为值的函数12345678910111213141516171819202122function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var data = [&#123;name: "Zachary", age: 28&#125;, &#123;name: "Nicholas", age: 29&#125;];data.sort(createComparisonFunction("name"));alert(data[0].name); //Nicholasdata.sort(createComparisonFunction("age"));alert(data[0].name); //Zachary 函数内部属性arguments.callee，指向拥有arguments对象的函数12345678910111213function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) ; //如果return num*factorial(num-1);，则代码和函数名紧耦合 &#125;&#125;var trueFactorial = factorial;factorial = function()&#123; return 0;&#125;;alert(trueFactorial(5)); //120。代码执行不因函数名的指向而改变。 this，引用的是函数所在的执行环境。全局作用域中调用函数时，this引用的是window12345678window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redo.sayColor = sayColor;o.sayColor(); //blue caller，保存着调用当前函数的函数的引用，全局作用域中调用当前函数，它为null1234567function outer()&#123; inner();&#125; function inner()&#123; alert(arguments.callee.caller); //或inner.caller&#125;outer(); 函数属性和方法length，函数定义的命名参数的个数。function sum(num1,mum2){…} //length为2 apply()和call()，每个函数都包含两个非继承而来的方法，用途都是在特性的作用域中调用函数，可以设置函数体内this对象的值。apply(obj,[ … ])接收数组参数，call(obj,arg1,arg2…)接收连续参数 bind()创建一个函数的实例，this值绑定到传递给bind()函数的参数值。 12345678910function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); //this为window对象。arguments对象 //或者 sum.apply(this, [num1, num2]) //或者 sum.call(this,num1,num2)&#125;alert(callSum1(10,10)); //20 扩充函数赖以运行的作用域123456789101112window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //bluevar objectSayColor = sayColor.bind(o);objectSayColor(); //blue 基本包装类型12var s1 = "text"; //string 是基本类型var s2 = s1.substring(2); //基本类型并不具有此方法 每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。相当于下面的过程 12345678s1 = new String('text');var s2 = s1.substring(2);s1 = null; //即刻销毁var o = new Object('text');alert(o instanceof Object); //truealert(o instanceof String); //turealert(typeof o); //object Boolean类型123456789var falseObject = new Boolean(false);var falseValue = false;var result = falseObject &amp;&amp; true;alert(result); //truealert(typeof falseObject); //objectalert(typeof falseValue); //booleanalert(falseObject instanceof Boolean); //truealert(falseValue instanceof Boolean); //false Number类型1234567891011121314151617var numberObject = new Number(10);var numberValue = 99;alert(numberObject.toString(2)); //"1010"alert(numberObject.toString(16)); //"a"alert(numberObject.toFixed(2)); //outputs "10.00"alert(numberObject.toExponential(2)); // 1.00e+1numberObject = new Number(99);alert(numberObject.toPrecision(1)); //"1e+2"alert(numberObject.toPrecision(2)); //"99"alert(numberObject.toPrecision(3)); //"99.0" alert(typeof numberObject); //objectalert(typeof numberValue); //numberalert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false String类型1234567var stringObject = new String("hello world");var stringValue = "hello world";alert(typeof stringObject); //"object"alert(typeof stringValue); //"string"alert(stringObject instanceof String); //truealert(stringValue instanceof String); //false 字符方法x.charAt()，x.charCodeAt() //字符编码，x[n]。 字符串操作方法concat()接受任意个参数，拼接返回新字符串1234567891011121314var stringValue = "hello world";alert(stringValue.slice(3)); //"lo world" 总长度作为结束位置alert(stringValue.slice(3, 7)); //"lo w"alert(stringValue.substring(3)); //"lo world"alert(stringValue.substring(3,7)); //"lo w"alert(stringValue.substr(3)); //"lo world"alert(stringValue.substr(3, 7)); //"lo worl" 第二个参数指定长度alert(stringValue.slice(-3)); //"rld" 将负的参数与总长度相加alert(stringValue.slice(3, -4)); //"lo w" alert(stringValue.substring(-3)); //"hello world" 将所有负参数转为0alert(stringValue.substring(3, -4)); //"hel" (3,0)=&gt;(0,3 )alert(stringValue.substr(-3)); //"rld" 将第一个负的参数与总长度相加alert(stringValue.substr(3, -4)); //"" 将第二个负的参数转为0 字符串位置方法12345var stringValue = "hello world";alert(stringValue.indexOf("o")); //4alert(stringValue.lastIndexOf("o")); //7alert(stringValue.indexOf("o", 6)); //7。从第二个参数往后搜索alert(stringValue.lastIndexOf("o", 6)); //4。从第二个参数往前搜索 trim()返回去除字符串两端空格的副本。 大小写转换12alert(stringValue.toUpperCase()); //"HELLO WORLD"alert(stringValue.toLowerCase()); //"hello world" 字符串的模式匹配方法 match()，本质上与调用RegExp的exec()方法相同。唯一参数，正则表达式。 1234567var text = "cat, bat, sat, fat"; var pattern = /.at/;var matches = text.match(pattern); alert(matches.index); //0alert(matches[0]); //"cat"alert(pattern.lastIndex); //0 search()，由开头向后查找，返回字符串中第一个匹配项的索引，如果没找到，返回-1。唯一参数，正则表达式。 var pos = text.search(/at/); //1 replace()，第一个参数，正则表达式或字符串，第二个参数字符串或者一个函数。 第一个参数为字符串，只替换第一个匹配项 12var result = text.replace("at", "ond");alert(result); //"cond, bat, sat, fat" 全局替换，使用正则表达式 12result = text.replace(/at/g, "ond");alert(result); //"cond, bond, sond, fond" 第二个参数为字符串，还可以使用一些特殊的字符序列 12result = text.replace(/(.at)/g, "word ($1)");alert(result); //word (cat), word (bat), word (sat), word (fat) $n，匹配的第n个捕获组 第二个参数，为函数。 split()第一个参数，分隔符字符串或RegExp。第二个参数，结果数组的大小。1234var colorText = "red,blue,green,yellow";var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]var colors2 = colorText.split(",", 2); //["red", "blue"]var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""] localeCompare()比较两个字符串在字母表中的位置。1234var stringValue = "yellow"; alert(stringValue.localeCompare("brick")); //1alert(stringValue.localeCompare("yellow")); //0alert(stringValue.localeCompare("zoo")); //-1 fromCharCode()接受一或多个字符编码。转换成一个字符串。 alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot; 单体内置类型Global对象URI编码encodeURI()，不会对本属于URI的特殊字符进行编码，如冒号，正斜杠问号和井号。encodeURIComponet()，对任何非标准字符进行编码。1234567var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.htm#start"alert(encodeURI(uri));//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"alert(encodeURIComponent(uri)); URI解码decodeURI()，只对非URI特殊字符解码。decodeURIComponet()，解码所以非标准字符。1234567var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23startalert(decodeURI(uri)); //http://www.wrox.com/illegal value.htm#startalert(decodeURIComponent(uri)); eval()像是一个完整的ECMAScript解析器，只接受一个参数。传入的参数当做实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码，被认为是包含调用的执行环境的一部分，因此被执行代码具有该执行环境相同的作用域链。但在eval()中创建的任何变量或函数都不会被提升。 eval(&quot;var msg=&apos;hello world&apos;;&quot;); alert(msg); //严格模式中会导致错误 Global对象的属性 window对象Web浏览器都是将Global对象作为window对象的一部分加以实现的。因此全局作用域中声明的所有变量和函数都成为了window对象的属性。 Math对象 min()和max()1234567var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3//想要直接传递数组，可以使用下面的技巧var arr=[3, 54, 32, 16];var max = Math.max.apply(Math,arr); 舍入方法12345alert(Math.ceil(25.1)); //26alert(Math.floor(25.9)); //25alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25 random()123456789function selectFrom(lowerValue, upperValue) &#123; var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue);&#125;var num = selectFrom(2, 10); //2-10的整数var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];var color = colors[selectFrom(0, colors.length-1)]; 对象理解对象属性类型ECMAScript中属性分两种：数据属性和访问器属性。“特性”描述了属性的各种特征，只为了实现JS引擎，不能直接访问。 数据属性 123456789var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, //只读属性 value: "Nicholas"&#125;);alert(person.name);person.name = "Michael"; //严格模式下，抛出错误alert(person.name); //Nicholas 一旦把属性定义为不可配置的，就不能再把它便回可配置了。再调用Object.defineProperty()修改除writable之外的特性，都将导致错误。 访问器属性不包含数据值，包含一对getter和setter函数。都不必需，可创建只读，只写属性。 123456789101112131415161718192021var book = &#123; _year: 2004, edition: 1&#125;; Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 定义/修改多个属性12345678910111213141516var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, //其他特性默认为false，undefined edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125; &#125;); 读取属性的特性123456789var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //"undefined"var descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //"function" 创建对象构造函数模式1234567891011121314function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; //弊端，每个对象的此属性指向不同方法对象 alert(this.name); &#125;; &#125;var person1 = new Person("Nicholas", 29, "Software Engineer");person1.sayName(); //"Nicholas"alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person1.constructor == Person); //true new 操作符，执行步骤：1，创建1个新对象。2，将构造函数的作用域赋给新对象，this就指向了这个新对象3，执行构造函数中的代码。4，返回新对象 如果直接调用构造函数，则和普通函数一样。 Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); //adds to window window.sayName(); //&quot;Greg&quot;。通过this，赋值给了window对象。 原型模式理解原型对象 每一个函数都有一个prototype属性，是一个指针，指向通过构造函数而创建的那个对象实例的原型对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。通过原型，可以把需要定义在构造函数中的实例信息，转移到原型对象中。 1234567function Person()&#123; &#125; Person.prototype.name = "Nicholas";Person.prototype.sayName = function()&#123; //每个实例的此属性指向同一方法 alert(this.name);&#125;; var person1 = new Person();person1.sayName(); //"Nicholas"。通过查找对象属性得过程来实现查找调用 确定对象间是否存在原型关系 alert(Person.prototype.isPrototypeOf(person1)); //true 取得[[Prototype]]的值 alert(Object.getPrototypeOf(person1) == Person.prototype); //true alert(person1.constructor.prototype == Person.prototype); //true 屏蔽原型属性 person1.name = &quot;Greg&quot;; alert(person1.name); //&quot;Greg&quot; 读取实例的属性时，先搜索实例本身，然后搜索原型对象。 删除实例属性，解除屏蔽。 delete person1.name; 检测属性是否存在于实例中 alert(person1.hasOwnProperty(&quot;name&quot;)); 原型与in操作符in操作符会在通过对象能够访问给定属性时返回ture，无论属性存在于实例或原型中 1234567var person1 = new Person(); alert(person1.hasOwnProperty("name")); //falsealert("name" in person1); //truefunction hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; //判断属性是否存在于原型中 使用for-in循环时，返回的是所有能通过对象访问的，可枚举（[[Enumerable]]）的属性。其中既包括实例中的属性和原型中的属性。屏蔽原型中不可枚举属性得实例属性也会在for-in循环中返回。 Object.keys()。接收一个对象，返回一个只包含在此实例中的所有可枚举属性的字符串数组。 12345var keys = Object.keys(Person.prototype);alert(keys); //"name,age,job,sayName"var p=new Person();var keys = Object.keys(p);alert(keys); //"" Object.getOwnPropertyNames()。接收一个对象，返回一个只包含在此实例中的无论是否可枚举的属性的字符串数组。 1234var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor,name,age,job,sayName"var keys = Object.getOwnPropertyNames(p);alert(keys); //"" 更简单的原型语法1234567function Person()&#123; &#125; Person.prototype = &#123; name : "Nicholas", sayName : function () &#123; alert(this.name); &#125;&#125;; 重写了prototype对象。因此constructor属性变成了Object构造函数，不在指向Person函数12345var friend = new Person(); alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //false。实际访问的是原型对象的constructor属性alert(friend.constructor == Object); //true 重设constructor属性 Person.prototype = { constructor: Person, ... }; 缺点：导致constructor属性的枚举特性为ture。改良如下： Object.defineProperty(Person.prototype，&quot;constructor&quot;，{ enumerable：false, value：Person })； 原型的动态性因为实例和原型之间的连接是一个指针，而非一个副本。创建实例后，对原型对象做的任何修改都能立即从实例上反应出来。如果先创建实例，又重写了其原型对象，则切断了新原型对象与实例的关系。实例指向的仍是原来的原型对象。 原生对象的原型123456alert(typeof Array.prototype.sort); //"function"alert(typeof String.prototype.substring); //"function"String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;; //给原生引用类型增加扩展方法（不推荐，容易引起冲突） 组合构造函数模式和原型模式组合两种模式，创建自定义类型。构造函数用于定义实例不同的属性，原型模式用于定义方法和共享的属性。 继承原型链 确定原型和实例之间的关系123456instance instanceof Object; //trueinstance instanceof SuperType; //trueinstance instanceof SubType; //trueObject.prototype.isPrototypeOf(instance); //trueSuperType.prototype.isPrototypeOf(instance); //trueSubType.prototype.isPrototypeOf(instance); //true 原型链的问题12345678910function SuperType()&#123; this.colors = ["red", "blue", "green"];&#125;function SubType()&#123; &#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors); //"red,blue,green,black"。所有子类型实例共享一个原型对象var instance2 = new SubType();alert(instance2.colors); //"red,blue,green,black"。所有子类型实例都受影响 组合继承1234567891011121314151617function SuperType(name)&#123; //父类型 私有属性 this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; //父类型 私有方法 alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //子类型 借用父类型构造函数，生成自己的私有属性（与父类型一致） this.age = age; //子类型 私有属性&#125;SubType.prototype = new SuperType(); //父类型实例作为子类型的原型，继承父实例原型的方法和实例属性。父实例的私有属性将被子实例相同的私有属性覆盖，而不再被子实例共享，避免篡改。SubType.prototype.sayAge = function()&#123; //子类型 私有方法 alert(this.age);&#125;;var instance1 = new SubType("Nicholas", 29); //拥有：父类型原型方法，子类型原型方法，子实例私有属性 优点：重用了父类型的方法，避免二次定义与父类型相同的属性缺点：实例了两次相同的属性，子实例覆盖了父实例创建的私有属性 原型式继承123456789101112function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; var person = &#123; //原型（基础）对象 name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = object(person); //传递父类型（非实例）进行浅复制，创建了2个副本，拥有相同的原型对象var yetAnotherPerson = object(person);anotherPerson.prototype.sayHello=function()&#123; ... &#125; //对子类型的扩展，并不影响父类型 ECMAScript 5 规范了原型式继承12345var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;; var anotherPerson = Object.create(person); 寄生组合式继承1234567891011121314151617181920function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); //创建一个中间层，继承了父类型的原型方法。 prototype.constructor = subType; //增强 subType.prototype = prototype; //子类型的原型引用此中间层，对子类型的扩展应用在此层上，并不影响父类型。&#125; function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125; SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //借用，避免二次定义相同的属性 this.age = age;&#125;inheritPrototype(SubType, SuperType); //应用中间层，继承父类型原型方法，且并不实例化父类型，避免实例后覆盖带来的浪费 SubType.prototype.sayAge = function()&#123; //扩展子类型 alert(this.age);&#125;; 函数表达式闭包一个函数，有权访问其他函数作用域变量对象的函数。 创建时，创建一个预先包含全局变量对象及外层变量对象的作用域链（根据函数是否引用外层函数的变量来决定是否加入外部函数的变量对象，未引用则外部函数的变量对象销毁），保存在内部的[[ Scope ]]属性中。 调用时，为此函数创建一个执行环境。 复制函数的[[ Scope ]]属性中的对象（指针）构建执行环境的作用域链。 创建次函数的活动对象（在此作为变量对象）并被推入执行环境作用域链的前端。 作用域链本质上是一个指向变量对象的指针列表。 闭包与变量12345678910111213141516function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; //创建，作用域链引用createFunctions的变量对象 return i; &#125;; &#125; //不存在块级作用域，变量i仍然存在，最终的值为10 return result;&#125; //被引用createFunctions的变量对象未销毁var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; document.write(funcs[i]() + "&lt;br /&gt;"); //调用函数，全部都返回createFunctions变量对象中的i变量，10&#125; 关于this对象this对象在运行时基于函数的执行环境绑定的。当函数作为某个对象的方法被调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。1234567891011121314var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function() &#123; ① return this.name; ③ var that=this; ② return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 作为对象的方法调用，this等于此对象。”My Obeject” 匿名函数，此时this表示window。”The Window” 。（内部函数搜索this和arguments变量时，只会搜索到其活动对象位置，不可能直接访问到外部函数中的这连个变量。） 把外部作用域中的this对象保存在一个闭包能够访问 到的变量，就可以让闭包访问此对象了。 特殊情况，123alert(object.getName()); //"My Object"alert((object.getName)()); //"My Object"alert((object.getName = object.getName)()); //"The Window" 非严格模式 第三行的赋值表达式等于函数本身，this没有得到保持，等于window对象。 闭包导致的内存泄漏IE9之前的版本对JS对象和COM对象使用不同的垃圾收集例程。BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。 123456function assign() &#123; var ele=document.getElementById('id'); ele.onclick=function()&#123; alert(ele.id); &#125;&#125; 循环引用，导致内存泄漏解决方案12345678function assign()&#123; var ele=document.getElementById('Id'); var id=ele.id; ele.onclick=function()&#123; alert(id); &#125; ele=null;&#125; 模仿块级作用域JS没有块级作用域的概念，在for或if中定义的变量，实际上是在包含函数中而非语句中创建的。 12345678function outputNumbers(count)&#123; (function () &#123; //内部为块级作用域 for (var i=0; i &lt; count; i++)&#123; alert(i); &#125; &#125;)(); alert(i); //出错&#125; 私有变量1234567891011function Person()&#123; //私有变量 var name; //特权方法 this.getName = function()&#123; return name; &#125;; this.setName = function (value) &#123; name = value; &#125;;&#125; 静态私有变量1234567891011121314151617(function()&#123; var name = ""; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)();var person1 = new Person("Nicholas"); var person2 = new Person("Michael");alert(person1.getName()); //"Michael"alert(person2.getName()); //"Michael" 模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); //初始化 return &#123; //匿名对象 getComponentCount : function()&#123; return components.length; &#125;, registerComponent : function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125; &#125;;&#125;(); 增强模块模式1234567891011121314var application = function()&#123; var components = new Array(); components.push(new BaseComponent()); var app = new BaseComponent(); //属于某种类型 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == "object")&#123; components.push(component); &#125; &#125;; return app;&#125;(); BOMwindow对象全局作用域window对象扮演着Global对象的角色。定义在全局作用域中的变量都会成为window对象的属性区别： 123456var age = 29; //[[Configurable]]特性为falsewindow.color = "red";delete window.age; //false &lt;IE 9报错delete window.color; //true alert(window.age); //29alert(window.color); //undefined 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中（通过从0开始的数值索引或者框架名称来访问对应的window对象）。 top.frames[0] //top始终指向最高层的框架，也就是浏览器窗口 parent对象 //当前对象直接上层框架，如果没有框架的话。parent=top=window 窗口位置浏览器在屏幕左边和上边的位置。12var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY; 窗口大小页面大小，不包括工具栏等浏览器本身。123456789101112var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS1Compat")&#123; //是否是标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 间歇调用和超时调用JS是单线程语言，一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JS任务队列，这些任务会按照它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行。否则它就要等前面的代码执行完了之后再执行。 系统对话框window.print() //调用打印窗口 window.find(&apos;xx&apos;) //查找页面是否包含&apos;字符串&apos;，返回ture/false location对象位置操作1234567location.hash = "sec1"; // http://..../#sec1 不刷新页面，跳转到页内锚记location.search = "q=22"; // http://..../?q=22#sec1 location.hostname = "www.yahoo.com"; // http://www.yahoo.com/?q=22#sec1 location.pathname = "mydir"; // http://..../mydir/t1/dd/?q=22#sec1location.port = 8080; // http://...:8080/mydir/t1/dd/?q=22#sec1location.replace("http://www.wrox.com/"); //不会产生历史记录，不能回到前一个页面location.reload([true]); //true，忽略浏览器缓存，强制从服务器重新加载 navigator对象浏览器及客户端系统相关信息 screen对象表示客户端的能力，包括浏览器窗口外部的显示器信息，如像素宽度和高度等。 history对象因history也是window对象的属性，因此每个浏览器窗口，每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 12345history.go(-1)history.go(1)history.go("www.baidu.com") //跳转到最近的baidu页面，可能前进，也可能倒退history.back()history.forward() DOM节点层次Node类型每个节点都有一个childNodes属性，保存着NodeList对象。NodeList是一种类数组对象，动态实时更新，使用时最好先缓存起来，可以通过索引[i]或者item(i)访问，也有length属性，但并不是Array的实例。可以通过 var arr=Array.protptype.slice.call(some.childNodes，0); 来进行转换成数组。 Node之间的关系 操作节点1234567var retNode=someNode.appendChild(someNode.firstChild)； //成为第二个节点var retNode=someNode.insertBefore(newNode,null); //插入为最后一个节点var retNode=someNode.insertBefore(newNode,someNode.firstChild); //插入成为第一个节点var retNode=someNode.replaceChild(newNode,someNode,firstChild); //替换第一个节点。该节点的所有关系指针都会被替换。var retNode=someNode.removeChild(someNode.firstChild); //移除第一个子节点var deepList=myList.cloneNode(true); //复制节点及整个子节点数var shallowList=myList.cloneNode(false); //只复制节点本身 Document类型包括HTML元素，HTML声明等。12345var html=document.documentElement; //HTML元素html==document.childNodes[0]; //truehtml==document.firstChild; //truevar body=document.body; //body的引用var doctype=document.doctype; //&lt;!DOCTYPE&gt;的引用 在jQuery的$(function(){ … });页面加载事件里，this对象引用的即为Document对象。且直接通过var 声明的变量不会成为Document对象的属性(与全局作用域不同，如全局声明var变量，此变量即成为window对象的属性)。 文档信息1234567document.title='new title';var url=document.url;var domain=document.domain;var referrer=document.referrer;images.nemedItem('name'); 或iamges["name"] //取得HTMLCollection对象中name为'name'的元素 特殊集合1234document.anchores，带name的a元素document.links，带href的a元素document.forms，所有form元素document.images，所有img元素 一致性检测document.implementation对象，DOM1级只为此对象规定了一个方法，hasFeature()。传入两个参数，要检测的DOM功能名称和版本号。 var hasXmlDom=document.implementation.hasFeature(&apos;XML&apos;,&apos;1.0&apos;); Element类型特征1234nodeType //1nodeName/tagName //标签名nodeValue //nullparentNode HTML元素HTMLElement，所有HTML元素都是HTMLELment活它的子类型表示。继承了Element的属性，新增了部分属性：id，title，lang，dir(语言方向,类似text-align)，className(所有class)。 操作特性1234var div=document.getElementById('my');div.getAttribute('id');div.setAttribute('class','123');div.removeAttribute('name'); 直接通过属性名访问和getAttribute()方法得到的结果不一样的两种特性：style，get得到的CSS文本，属性访问得到对象，用于访问元素样式。事件，onclick等，get访问代码文本，属性访问得到function对象。 attributes属性包含一个NamedNodeMap“动态”集合，拥有下列方法：1234getNamedItem(name) //返回指定nodeName(tagName)的节点removedNamedItem(name) //从列表移除指定nodeNamesetNamedItem(node) //向列表添加节点item(id) //返回位于数字id处的节点 取值 ele.attributes[&apos;age&apos;].nodeValue 创建元素1234var div = document.createElement("div");div.id = "myNewDiv";div.className = "box";document.body.appendChild(div); 动态创建的元素特点：不能通过表单reset，与已有同name单选框无关系。 元素的子节点ele.childNodes 除了IE，其他浏览器会把各子元素之间的回车等空白也计算为一个节点。所以需要遍历子元素时，需要判断元素类型。123if(chiEle.nodeType==1)&#123; //do some&#125; Text类型特征123456nodeType //3nodeName //#textnodeValue //节点文本parentNode //Element没有子节点length属性 方法123appendData(txt)，deleteData(offset,count)，insertData(offset,count,text)，replaceData(offset,count,text)，splitText(offset)，substringData(offset,count) 创建document.createTextNode(&apos;&lt;strong&gt;Hello&lt;/strong&gt;&apos;); Comment类型特征12345nodeType //8nodeName //'#comment'nodeValue //注释的内容parentNode //Document或Element无子节点 CDATASection类型特征123456只针对XML文档，CDATA区域。与Comment类似，继承自Text类型nodeType //4nodeName //#cdata-sectionnodeValue //CDATA区域的内容parentNode //Document或Element无子节点 DocumentType类型很少有浏览器支持。表示文档类型，对应&lt;!DOCTYPE&gt;等。 Attr类型元素的特性 DOM操作技术动态脚本页面加载时不存在，将来通过修改DOM动态添加的脚本。 外部引用 1234567function addScript()&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.text = "function sayHi()&#123;alert('hi');&#125;"; document.body.appendChild(script); sayHi();&#125; 行内方式 12345678910function loadScriptString(code)&#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch (ex)&#123; script.text = code; //IE特定，不支持对Script添加子节点 &#125; document.body.appendChild(script);&#125; 动态样式 外部引用 1234567function addStyle()&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; style.appendChild(document.createTextNode(&quot;body&#123;background-color:red&#125;&quot;)); //error in IE var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 嵌入方式 1234567891011function loadStyleString(css)&#123; var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; try&#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex)&#123; style.styleSheet.cssText = css; //IE &#125; var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);&#125; 选择符API使用CSS选择符查询匹配的DOM元素。 querySelector()接受一个CSS选择符，返回与该模式匹配的第一个元素，没找到则返回null。 1234var body = document.querySelector("body");var myDiv = document.querySelector("#myDiv");var selected = document.querySelector(".selected");var img = document.body.querySelector("img.button"); querySelectorAll()返回所有匹配的元素，一个NodeList实例（此方法返回的实际上是一组元素的快照，避免不断动态查询带来的性能影响）。没有匹配则返回一个空的NodeList。1234var ems = document.getElementById("myDiv").querySelectorAll("em");var selecteds = document.querySelectorAll(".selected");var strongs = document.querySelectorAll("p strong");var s1=strongs[0]; matchesSelector()如果调用元素与该选择符匹配，返回ture，否则返回false。123if (matchesSelector(document.body, "body.page1"))&#123; alert("It's page 1!");&#125; 支持不完善，需要做跨浏览器兼容。12345678910111213function matchesSelector(element, selector)&#123; if (element.matchesSelector)&#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector)&#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector)&#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector)&#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error("Not supported."); &#125;&#125; 元素遍历对于元素见得空格，IE9及之前版本不会返回文本节点，其他浏览器都会返回文本节点。子节点查询的元素版：childElementCount属性，子元素（不含文本和注释节点啊）个数。firstElementChild，lastElementChild，previousElementSibling，nextElementSiblingchildren属性，HTMLCollection实例，只包含元素子节点。childNodes的元素版。 跨浏览器兼容123456789101112if (document.body.firstElementChild)&#123; var i, len, child = document.body.firstElementChild; while(child != document.body.lastElementChild)&#123; document.write("&lt;p&gt;" + child.tagName + "&lt;/p&gt;"); child = child.nextElementSibling; &#125;&#125; else &#123; document.write("&lt;p&gt;Element Traversal API not supported.&lt;/p&gt;");&#125; HTML5document.head，head部分引用document.charset，字符集 类的扩充getElementsByClassName() 所有元素都可调用12345classList //DOMTokenListadd(value) //添加或忽略contains(value) //是否包含remove(value) //删除toggle(value) 滚动scrollIntoView() 任何元素可调用，出现在视口中。传入true或不传，顶部与视口对齐。传入false，底部对齐。 DOM2和DOM3变化Node类型localName，不带命名空间前缀的节点名称namespaceURI，不带命名空间前缀的节点名称prefix，命名空间或者null Document类型新增了带NS后缀的方法，表示特定命名空间下的操作，比如：createElementNS(ns,tagName)：创建属于ns命名空间的元素createAttributeNS(ns,attr)：使用给定attr创建一个ns命名空间的新特性getElementsByTagNameNS(ns,tagName)：返回特定命名空间的元素NodeList 元素大小偏移量 某个元素在页面上的偏移量计算：12345678910function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 客户区大小 元素内部空间大小，因此滚动条占用的空间不计算。确定浏览器视口大小： document.documentElement.clientWidth //document.body代表body，document.documentElement //代表html标签 滚动大小scrollHeight，没有滚动条的情况下，元素总高度scrollWidth，同上，元素内容总宽度scrollLeft，被隐藏在内容区域左侧的像素数。设置可以改变元素滚动位置scrollTop，上方的元素，设置可以改变元素滚动位置(需要设置overflow属性才能滚动) 确定文档的总高度时，必须获得scrollHeight/clientHeight中的最大值，才能跨浏览器得到准确的结果。 Math.max(ducment.documentElement.scrollHeight,document,documentElement.clientHeight) 遍历TreeWalker12345678910111213141516function makeList() &#123; var div = document.getElementById("div1"); var filter = function(node)&#123; return (node.tagName.toLowerCase() == "li") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;; var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false); var output = document.getElementById("text1"); var node = walker.nextNode(); while (node !== null) &#123; output.value += node.tagName + "\n"; node = walker.nextNode(); &#125;&#125; NodeFilter.FILTER_SKIP，跳过节点前进道子树种的下一个节点NodeFilter.FILTER_REJECT，跳过节点及该节点整个子树。walker可以眼任何方向移动 walker.firstChild(); walker.nextSibling(); walker.currentNode，当前节点。 范围 事件事件流 事件处理程序需DOM0级事件处理程序1234bar btn=document.getElementById('my');btn.onclick=fuction()&#123; alert(this.id);&#125;; DOM0级方法指定的事件处理程序被认为是元素的方法，在元素的作用域中运行，this引用当前元素。 DOM2级事件处理程序1234var btn = document.getElementById("myBtn");btn.addEventListener("click", function()&#123; alert(this.id);&#125;, false); false，冒泡阶段调用，true，捕获阶段调用。作用域同DOM0级方法一样。好处是，可以添加多个事件处理程序，且按添加顺序执行。 通过此方法添加的事件只能使用removeEventListener()移除，传入的参数与添加时使用的参数相同(同一个函数对象)，所以通过addEventListener()添加的匿名函数将无法移除。 事件对象所有事件都会有的成员 12345document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById("myBtn")); //true&#125;; 事件类型 UI事件 在window上发生的任何事件都可以在body元素上通过相应的特性来指定，因为HTML无法访问window元素，为了向后兼容例：window的load事件， unload事件兼容性很不好，chrome不会显示文本，IE显示乱码12345EventUtil.addHandler(window, "beforeunload", function(event) &#123; var msg = "will you leave？"; event.returnValue = msg; return msg;&#125;); scroll事件document.body.scrollTop获取滚动高度。火狐使用document.documentElement.scrollTop。 焦点事件 鼠标与滚轮事件 客户区(可视)坐标 event.clientX和event.clientY 页面坐标 event.pageX，event.pageY 屏幕坐标 event.screenX，event.screenY 修改键 e.shiftKey，e.ctrlKey，e.altKey，e.metaKey。布尔值，代表是否按下了相应按键，支持同时按。 关联元素 e.relatedTarget，只对mouseover和mouseout事件才包含值，代表与target发生关系的元素。 鼠标按钮 e.button，按下或释放的按钮。0，主按钮，1，滚轮，2，次按钮。 滚轮事件 mousewheel，任何元素上出发，最终会冒泡到document或window对象。event对象包含一个特殊的wheelDelta属性，向前滚动wheelDelta是120的倍数，向后滚动wheelDelta是-120的倍数。 触摸设备 键盘与文本事件keydown，按下键盘上任意键时触发，按住不放会重复触发。keypress，按下奸商上字符键时触发，按住不放会重复触发。keyup，释放键盘上的键时触发keydown-&gt;keypress-&gt;keyup。支持4个修改键。键码，event.keyCode，表示触发keydown或keyup事件特定的键，如回车-13，空格-32。字符编码，event.key，事件产生的相应文本字符或键名。 文本事件textInput。按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发。event.data，实际输入的字符文本。event.inputMethod，代表文本是如何输入到控件中的，从而验证有效性（只有IE支持）。 HTML5事件contextmenu事件windows中，右键单击。Mac，Ctrl+单击。冒泡，可以为document指定一个事件处理程序自定义右键菜单。 12345678910document.oncontextmenu=function(event)&#123; event.preventDefault() var menu = document.getElementById("myMenu"); menu.style.left = event.clientX + "px"; menu.style.top = event.clientY + "px"; menu.style.visibility = "visible";&#125;;document.addEventListener('click',function()&#123; document.getElementById("myMenu").style.visibility = "hidden"; //隐藏右键菜单&#125;); beforeUnload事件必须添加给window对象。firefox和opera不支持。chrome不显示message。123456EventUtil.addHandler(window, "beforeunload", function(event)&#123; event = EventUtil.getEvent(event); var message = "I'm really going to miss you if you go."; event.returnValue = message; return message;&#125;); DOMContentLoaded事件DOM树加载完毕之后触发，不理会图片，js，css等。 pageShow，pageHide事件必须添加给window对象。pageShow在load后触发，pageHide在unload之前触发。兼容性不好。 hashchange事件必须添加给window对象。url发生变化时触发，包含oldURL和newURL两个属性。 设备事件只在移动设备上实现。 orientationchange事件横向纵向查看模式。只有Safari支持 deviceorientation事件123456EventUtil.addHandler(window, "deviceorientation", function(event)&#123; var output = document.getElementById("output"); var arrow = document.getElementById("arrow"); arrow.style.webkitTransform = "rotate(" + Math.round(event.alpha) + "deg)"; output.innerHTML = "Alpha=" + event.alpha + ", Beta=" + event.beta + ", Gamma=" + event.gamma + "&lt;br&gt;";&#125;); devicemotion事件12345678EventUtil.addHandler(window, "devicemotion", function(event)&#123; var output = document.getElementById("output"); if (event.rotationRate !== null)&#123; output.innerHTML += "Alpha=" + event.rotationRate.alpha + ", Beta=" + event.rotationRate.beta + ", Gamma=" + event.rotationRate.gamma; &#125;&#125;); 触摸和手势事件触摸事件都会冒泡。 Touch对象包含：identifier，唯一ID，clientX/Y，pageX/Y，screenX/Y，target，触摸的DOM节点。 12345678910111213141516171819202122function handleTouchEvent(event)&#123; //只触发一次 if (event.touches.length == 1)&#123; var output = document.getElementById("output"); switch(event.type)&#123; case "touchstart": output.innerHTML = "Touch started (" + event.touches[0].clientX + "," + event.touches[0].clientY + ")"; break; case "touchend": output.innerHTML += "&lt;br&gt;Touch ended (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; case "touchmove": event.preventDefault(); //阻止滚动 output.innerHTML += "&lt;br&gt;Touch moved (" + event.changedTouches[0].clientX + "," + event.changedTouches[0].clientY + ")"; break; &#125; &#125;&#125;document.addEventListener("touchstart", handleTouchEvent, false);document.addEventListener("touchend", handleTouchEvent, false);document.addEventListener("touchmove", handleTouchEvent, false); 模拟事件模拟鼠标事件1234var event = document.createEvent("MouseEvents");event.initMouseEvent("click", true, true, document.defaultView, 0, 100, 0, 0, 0, false, false, false, false, 0, btn2);btn.dispatchEvent(event); 模拟键盘事件1234567891011121314151617181920212223242526EventUtil.addHandler(btn, "click", function(event)&#123; var event; //DOM Level 3 if (document.implementation.hasFeature("KeyboardEvent", "3.0"))&#123; event = document.createEvent("KeyboardEvent"); event.initKeyboardEvent("keydown", true, true, "a", 0, "Shift"); &#125; else &#123; try &#123; //Firefox event = document.createEvent("KeyEvents"); event.initKeyEvent("keydown", true, true, document.defaultView, false, false, true, false, 65, 65); &#125; catch (ex)&#123; //others event = document.createEvent("Events"); event.initEvent("keydown", true, true); event.view = document.defaultView; event.altKey = false; event.ctrlKey = false; event.shiftKey = false; event.metaKey = false; event.keyCode = 65; event.charCode = 65; &#125; &#125; textbox.dispatchEvent(event);&#125;); 表单脚本选择框脚本：HTMLOptionElement对象，属性有：index，label，selected，text，value。 取得选择的option，select.options[select.selectedIndex];选择，select.option[0].selected = true; 对其他option无影响。select.selectedIndex = 0，影响多选框其他option。 JSONJSON序列化：1234567891011121314151617181920var bookCopy = JSON.parse(jsonText, function(key, value)&#123; if (key == "releaseDate")&#123; return undefined; &#125; else &#123; return value; &#125;&#125;);var jsonText = JSON.stringify(book, ["title", "edition"], 4); //只序列化字段，格式化缩进个数var jsonText = JSON.stringify(book, null, "--"); //缩进占位符var book = &#123; "title": "Professional JavaScript", "authors": [ "Nicholas C. Zakas" ], edition: 3, year: 2011, toJSON: function()&#123; return this.title; &#125; &#125;; AjaxXHR默认头部信息 发送请求通过setRequestHeader()设置自定义头部，jQuery方式：12345678910$.ajax(&#123; type: "GET", url: "...", beforeSend: function(request) &#123; request.setRequestHeader("Test", "content"); &#125;, success: function(result) &#123; alert(result); &#125;&#125;); XHR2级FormData1234567891011121314151617181920212223242526272829var data = new FormData();data.append("file" , files[i]);var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(event)&#123; if (xhr.readyState == 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert("Request was unsuccessful: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "FileAPIExample06Upload.php", true);xhr.send(data);var formData = new FormData();var upload = document.getElementById('file');if (upload.files.length &gt; 0) &#123; formData.append('upload', upload.files[0]); $.ajax(&#123; url: '/Customers/Import', method: 'POST', data: formData, contentType: false, processData: false, cache: false, success: function (data) &#123;&#125; &#125;);&#125; 进度事件123456789var xhr = createXHR();xhr.onprogress = function(event)&#123; var divStatus = document.getElementById("status"); if (event.lengthComputable)&#123; divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize + " bytes"; &#125;&#125;;xhr.open("get", "altevents.php", true); xhr.send(null); 跨域XHR对象，默认只能访问与它同一个域中的资源。CORS：发送请求时，需要添加一个额外的Origin头部，Origin：http://www.xxx.com。服务器如果任何请求，就在Access-Control-Allow-Origin头部中挥发相同的源（如果不需要跨域保护，可会回发 *），例如Access-Control-Allow-Origin：http://www.xxx.com大部分浏览器默认实现CORS的原声支持，访问时，使用绝对URL即可。但跨域XHR对象也有一些限制：不能自定义头部，不能发送和接受cookie，获取自定义头部总会返回空 其他跨域技术图像Ping，JSONP，Comet，Web sockets。 WebSockets在一个单独的持久链接上提供全双工、双向通信。第一次取得服务器响应后，建立的链接会从HTTP协议升级成Web Socket协议（需要服务器支持）。 Web Sockets协议：’ws://‘和’wss://‘（加密）。1234567891011121314151617var socket = new WebSocket('ws://www.xxx.com/handler'); // 不受同源策略影响，可以跨域// readState 属性：WebSocket.CONNECTING(0) / OPEN(1) / CLOSING(3) / CLOSED(2)socket.send('xxx'); //只能发送纯文本，发送复杂数据结构，需要先序列化socket.onmessage = function(event)&#123; // 获取服务器消息 var data=event.data; &#125;socket.close() //关闭链接 ，状态由2到3WebSocket事件：不支持DOM2级事件侦听器，必须使用DOM0级语法定义事件。socket.onopen = function()&#123;&#125;;socket.onerror = function()&#123;&#125;;socket.onclose = function(e)&#123; // e.wasClean 是否明确关闭 // e.code 服务器返回码 // e.reason 服务器发回的消息&#125;; 高级技巧高级函数安全的类型检测检测是否为数组/函数/正则表达式： Object.prototype.toString.call(obj) == &apos;[object Array]&apos;/&apos;[object Function]&apos;/&apos;[object RegExp]&apos;; 作用域安全的构造函数假设一个构造函数没有搭配new 关键词而调用，那么this默认绑定到window对象，则可能导致意外的错误。123456789function Person(name, age, job)&#123; if (this instanceof Person)&#123; //判断是否为指定类型的对象，再进行操作 this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125; 函数绑定绑定后返回一个函数，无论再对此函数调用什么apply或call改变this的引用，都不会改变执行结果handleClick.bind(obj)。123456function bind(context)&#123; var fn=this; return function()&#123; return fn.apply(context, arguments); &#125;;&#125; 柯里化使用闭包创建一个已经设置了部分参数的函数。123456789101112131415function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments), finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;;&#125;function add(num1, num2)&#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); //8 bind的柯里化实现123456789var handler = &#123; message: "Event handled", handleClick: function(name, event)&#123; alert(this.message + ":" + name + ":" + event.type); &#125;&#125;;var btn = document.getElementById("my-btn");EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler, "my-btn")); //第一个参数是绑定的this，第二个参数开始是预设置的参数。 防篡改对象不可扩展1234var person = &#123; name: "Nicholas" &#125;;Object.preventExtensions(person);alert(Object.isExtensible(person)); //falseperson.age = 29; 静默失败undefined，严格模式抛出异常 密封不可扩展，[[Configurable]]特性被设置为false，不能删除属性和方法。但是属性值是可以修改的。1234567var person = &#123; name: "Nicholas" &#125;;Object.seal(person);alert(Object.isSealed(person)); //trueperson.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas" 冻结最严格。及不可扩展，又是密封的，对象的[[Writable]]特性被设置为false，如果定义了[[Set]]，则访问器属性仍是可写的。1234567891011var person = &#123; name: "Nicholas" &#125;;Object.freeze(person);person.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //"Nicholas"person.name = "Greg";alert(person.name); //"Nicholas"alert(Object.isExtensible(person)); //falsealert(Object.isSealed(person)); //truealert(Object.isFrozen(person)); //true 分隔执行过程当执行数据量过大，为避免造成JS线程一直在进行中，导致UI线程被卡住。推荐对数据分割处理123456789101112131415161718var data = [12,123,1234,453,436,23,23,5,4123,45,346,5634,2234,345,342];function chunk(array, process, context)&#123; // context可选的 setTimeout(function()&#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0)&#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100); // 100毫秒 给线程一个协调的时间&#125;function printValue(item)&#123; var div = document.getElementById("myDiv"); div.innerHTML += item + "&lt;br&gt;"; &#125;chunk(data.concat(), printValue); // 不想改变原数组的数据，可以使用concat或slice创建一个副本 函数节流一些会被反复执行的事件，如果频率太高容易导致浏览器挂起或崩溃。需要对该函数进行节流适用于resize事件或over事件等。123456789101112131415function throttle(method, scope) &#123; // 可选的scope return function() &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(scope); &#125;, 100); &#125;&#125;function resizeDiv() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;window.onresize = throttle(resizeDiv); 自定义拖动功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function DrapDrop() &#123; var drag var dragging = null; var diffLeft, diffTop, diffRight, diffBottom; var count = 0; function handlerEvent(event) &#123; var target = event.target; switch (event.type) &#123; case 'mousedown': if ($(target).hasClass('draggable')) &#123; dragging = target; diffLeft = event.clientX - target.offsetLeft; diffTop = event.clientY - target.offsetTop; diffRight = target.clientWidth - diffLeft; diffBottom = target.clientHeight - diffTop; console.log(event.clientX, target.offsetLeft) &#125; break; case 'mousemove': if (dragging != null) &#123; var parentWidth = target.offsetParent.clientWidth; var parentHeight = target.offsetParent.clientHeight; var left, top; if (event.clientX - diffLeft &lt;= 0 || event.clientX + diffRight &gt;= parentWidth) &#123; if (event.clientX - diffLeft &lt;= 0) left = 0; if (event.clientX + diffRight &gt;= parentWidth) left = parentWidth - target.clientWidth; &#125; else &#123; left = event.clientX - diffLeft; &#125; if (event.clientY - diffTop &lt;= 0 || event.clientY + diffBottom &gt;= parentHeight) &#123; if (event.clientY - diffTop &lt;= 0) top = 0; if (event.clientY + diffBottom &gt;= parentHeight) top = parentHeight - target.clientHeight; &#125; else &#123; top = event.clientY - diffTop; &#125; dragging.style.left = left + 'px'; dragging.style.top = top + 'px'; &#125; break; case 'mouseup': dragging = null; break; &#125; &#125; return &#123; enable: function() &#123; document.addEventListener('mousedown', handlerEvent) document.addEventListener('mousemove', handlerEvent) document.addEventListener('mouseup', handlerEvent) &#125;, disable: function() &#123; document.removeEventListener('mousedown', handlerEvent) document.removeEventListener('mousemove', handlerEvent) document.removeEventListener('mouseup', handlerEvent) &#125; &#125;&#125; 离线应用和客户端存储离线应用离线检测navigator.onLine 离线事件123456EventUtil.addHandler(window, "online", function()&#123; document.getElementById("status").innerHTML = "Online";&#125;);EventUtil.addHandler(window, "offline", function()&#123; document.getElementById("status").innerHTML = "Offline";&#125;); 数据存储cookie限制：存在客户端计算机上，每个域最多几十个。只能保存单一文本，总共最大尺寸4k。 属性：key，名称，必须经过URL编码value：值，必须经过URL编码域：在某些域下才有效并携带发送到服务器。（.baidu.com对baidu.com的所有子域都有效）路径：指定路径有效并携带。（http://www.baidu.com/news/，跟路径则不会发送cookie）失效时间：时间戳，什么时候删除cookie。安全标志：secure（非名值对儿），只有在SSL链接下才发送。 Set-Cookie: name=value; domain= .wrox.com; path=/; secure Http专有cookie可以从浏览器和服务器设置，但是只能从服务器端读取，JS无法获取。 Web StorageStorage类型clear()：清空所有值getItem(name)：获取name的值key(index)：获取index处值的名称removeItem(name)：删除setItem(name,value)：设置PS：只能存储字符串 sessionStorage对象会话存储，存储某个特定会话的数据，保持到浏览器关闭。sessionStorage中的数据只能由最初设置的页面访问，不能跨页面 localStorage对象限制：同一来源有效，即同一个域（子域名无效），同一种协议，同一个端口。每个来源2~5MB大小限制。有效期：一直存在，直到JS删除或用户清楚缓存 IndexedDB替代了Web SQL Database API。保存结构化数据的一种数据库。操作完全是异步进行，因此，大多数操作会以请求的方式进行，异步返回成功结果或失败错误。限制：不能跨域，必须同源（域，协议，端口），大小5MB左右。 获取：（因为浏览器厂商提供的API都有前缀） var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778(function() &#123; var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB, // 消除厂商差异 IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction, // 定义事务的访问模式 IDBCursor = window.IDBCursor || window.webkitIDBCursor, IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange, request, store, database, users = [&#123; username: "007", firstName: "James", lastName: "Bond", password: "foo" &#125;, &#123; username: "ace", firstName: "John", lastName: "Smith", password: "bar" &#125;, &#123; username: "foobar", firstName: "Michael", lastName: "Johnson", password: "secret" &#125;]; request = indexedDB.open("example"); request.onerror = function(event) &#123; alert("Something bad happened while trying to open: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; database = event.target.result; initializeDatabase(); &#125;; function initializeDatabase() &#123; if (database.version != "1.0") &#123; // 默认无版本，最好先定义版本，避免产生不同的版本 request = database.setVersion("1.0"); request.onerror = function(event) &#123; alert("Something bad happened while trying to set version: " + event.target.errorCode); &#125;; request.onsuccess = function(event) &#123; store = database.createObjectStore("users", &#123;keyPath: "username"&#125;); // 定义对象存储空间和主键 users.forEach(function(user) &#123; store.add(user); // 如果主键重复了，add返回错误，put直接覆盖。 // get取得值，delete删除对象，clear删除所有对象 &#125;); outputValues(); &#125;; &#125; else &#123; outputValues(); &#125; &#125; function outputValues() &#123; // 事务组织所有的操作 var store = database.transaction("users", IDBTransaction.READ_WRITE).objectStore("users"), index = store.createIndex("username","username",&#123;unique:false&#125;); // 取得索引 sotre.index("username") range = IDBKeyRange.bound("007", "ace", false, false), // 指定游标范围。下界，上界，是否跳过下，上 request = store.openCursor(range, IDBCursor.PREV); // 指定游标的方向。NEXT/NEXT_NO_DUPLICATE request.onsuccess = function(event) &#123; var cursor = event.target.result; if (cursor) &#123; // 必须要检查 console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value)); cursor.value.password = 'xxx'; var updateRequest = cursor.update(cursor.value); // 请求更新 // cursor.delete() 删除当前项 cursor.continue(); // 移动到下一项，可以指定key // cursor.advance(count) 移动指定位数 &#125; else &#123; console.log("Done!"); &#125; &#125;; request.onfailure = function(event) &#123; console.error("Iteration did not succeed."); &#125;; &#125;&#125;)(); 最佳实践性能优化避免不必要的属性查找访问数组元素是一个O(1)的操作，访问对象的属性则是O(n)的操作。避免多次查找统一属性，可以先存储起来。 优化循环 减值迭代，从最大值到0，更高效。 简化终止条件，避免属性查找或O(n)的操作。比如：i&lt;arr.length。 简化循环体。 使用do-while，避免最初的终止条件计算。 Duff装置仅在处理大数据集时使用，更加高效。12345678910111213141516171819var arr = []var iterations = Math.floor(arr.length / 8);var leftover = arr.length % 8;var i = 0;if (leftover &gt; 0) &#123; do &#123; process(arr[i++]); &#125; while (--leftover &gt; 0);&#125;do &#123; process(arr[i++]); //循环再开，比单纯的循环调用更加高效 process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]); process(arr[i++]);&#125; while (--iterations &gt; 0); 最小化语句数多个声明合一，更高效： var count=5, color=&apos;red&apos;, arr=[1,2,3]; 初始化数组和对象时使用字面量var arr=[1,2,3]; var obj={age:20}; 优化DOM交互 最小化更新DOM次数。 使用innerHTML，一次性更新。 使用事件代理，利用事件冒泡，在祖先节点上处理事件。减少事件绑定数量。 减少使用HTMLCollection对象 getElementByxxx()，childNodes，attributes，document.forms，document.images等都会返回HTMLCollection，每次访问它的属性时都会在文档上进行实时的查询，开销昂贵。 其他 原生方法更快 switch语句更快 位运算符更快 新兴的API这些API都不在H5的规范中，只是与H5相关。 Page Visibility API探测页面是否最小化或者隐藏在其他标签后面。方便资源的暂停。 var isHide = document.hidden || document.msHidden || document.webkitHidden; document.visibilityState：4种表示不同状态的值 visibilitychange事件EventUtil.addHandler(document, &quot;msvisibilitychange&quot;, handleVisibilityChange); EventUtil.addHandler(document, &quot;webkitvisibilitychange&quot;, handleVisibilityChange); Geolocation API获得用户当前地理位置，需要用户授权。12345678910111213navigator.geolocation.getCurrentPosition(function(position)&#123; // position.coords对象有以下属性：latitude 维度，longitude 经度，accuracy 单位 &#125;, function(error)&#123; // error.message &#125;);var id = navigator.geolocation.watchPosition(function(position) &#123; // 方法第一次会取得当前位置，然后在系统发生位置改变时被调用&#125;, function(error) &#123; //&#125;);clearWatch(id); //取消追踪 File APIFileReaderFile类型，包含name,size,type属性。event.files12345678910111213141516171819202122232425262728293031323334353637var filesList = document.getElementById("files-list");EventUtil.addHandler(filesList, "change", function(event)&#123; var info = "", output = document.getElementById("output"), progress = document.getElementById("progress"), files = EventUtil.getTarget(event).files, type = "default", reader = new FileReader(); if (/image/.test(files[0].type))&#123; reader.readAsDataURL(files[0]); type = "image"; &#125; else &#123; reader.readAsText(files[0]); type = "text"; &#125; reader.onerror = function()&#123; output.innerHTML = "Error code :" + reader.error.code; //1,未找到。2,安全错误。3,读取中断。4,文件不可读。5,编码错误 &#125;; reader.onprogress = function(event)&#123; if (event.lengthComputable)&#123; progress.innerHTML = event.loaded + "/" + event.total; &#125; &#125;; reader.onload = function()&#123; var html = ""; switch(type)&#123; case "image": html = "&lt;img src=\"" + reader.result + "\"&gt;"; break; case "text": html = reader.result; break; &#125; output.innerHTML = html; &#125;;&#125;); 部分读取返回blob类型（file的父类型）12345678910111213function blobSlice(blob, startByte, length)&#123; if (blob.slice)&#123; return blob.slice(startByte, length); &#125; else if (blob.webkitSlice)&#123; return blob.webkitSlice(startByte, length); &#125; else if (blob.mozSlice)&#123; return blob.mozSlice(startByte, length); &#125; else &#123; return null; &#125;&#125;var blob = blobSlice(files[0], 0, 32); 对象URLbloblURL，指向一块内存地址1234567891011function createObjectURL(blob)&#123; if (window.URL)&#123; return window.URL.createObjectURL(blob); &#125; else if (window.webkitURL)&#123; return window.webkitURL.createObjectURL(blob); &#125; else &#123; return null; &#125;&#125;var url = createObjectURL(files[0]);output.innerHTML = "&lt;img src=\"" + url + "\"&gt;"; 文件拖放并上传1234567891011121314151617181920212223242526272829303132333435var droptarget = document.getElementById("droptarget");function handleEvent(event)&#123; var info = "", output = document.getElementById("output"), data, xhr, files, i, len; EventUtil.preventDefault(event); if (event.type == "drop")&#123; data = new FormData(); files = event.dataTransfer.files; i = 0; len = files.length; while (i &lt; len)&#123; data.append("file" + i, files[i]); i++; &#125; xhr = new XMLHttpRequest(); xhr.open("post", "xxx", true); xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; alert(xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;EventUtil.addHandler(droptarget, "dragenter", handleEvent);EventUtil.addHandler(droptarget, "dragover", handleEvent);EventUtil.addHandler(droptarget, "drop", handleEvent); //取消dragenter、dragover和drop的默认行为 Web workers使用worker使用后台线程/进程执行复杂的运行实现异步。如加/解密，图片处理等 123456789var data = [23,4,7,9,2,14,6,651,87,41,7798,24],worker = new Worker("WebWorkerExample01.js");// 下载js文件，但并不立即执行worker.onmessage = function(event)&#123; console.log(event);&#125;;worker.postMessage(data); // 可以传递文本，也可以传递对象（副本）worker.terminate(); // 终止worker worker中12345678910111213self.onmessage = function(event)&#123; var data = event.data; data.sort(function(a, b)&#123; return a - b; &#125;); self.postMessage(data);&#125;;self.onerror = function(event)&#123; // event.filename // event.lineno // event.message&#125;self.close(); // 停止工作 全局方法importScripts(&quot;com1.js&quot;,&quot;com2.js&quot;); // 异步加载。按顺序执行。 worker全局作用域worker单独一个作用域，不能访问DOM元素和标签。this引用的是worker对象。限制版本的navigator对象。制度的location对象。setTimeout()、setInterval()、clearTimeout()、clearInterval()方法XMLHttpRequest函数。 工具 链接 描述 client.js 浏览器及版本检测工具 EventUtil.js 跨浏览器事件处理工具 CookieUtil.js cookie操作工具 EventTarget.js 自定义事件操作工具 richtext.html 自制富文本编辑器]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通C#-注释笔记]]></title>
    <url>%2F2017%2F05%2F09%2F%E7%B2%BE%E9%80%9AC-%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言，然而，IL却包含一些抽象概念(比如：类、异常)，这也是这种语言被称为中间语言的原因。IL被打包在DLL或EXE文件中，而DLL和EXE在.NET中的主要区别就是：只有EXE可以直接被运行，而二者都可被某个正在执行的进程动态装载。由于机器的CPU只能执行本地汇编语言，而不是IL，进一步将IL编译成汇编语言的工作(也就是第二阶段)需要在运行时进行，这个过程由即时编译器(JIT)完成。 高级语言在初次被编译时，编译器做两件事：首先把编译得到的IL存储在DLL或EXE中，然后为类的每个方法创建一个stub函数，此函数会调用即时编译器，并将自身的地址作为参数传给编译器。即时编译器则从DLL或EXE中获取相应的IL，编译成机器语言，并将内存中的原零时调用函数替换成机器语言。这个过程的思想，是用已编译的方法调用未编译的方法，实质上被调用的是stub函数；stub函数再调用编译器，将自身编译为本地机器语言；最后，.NET会重新调用该方法，方法此时才被真正地执行。函数被反复调用时，机器指令会被直接执行，而只由编译器对方法进行初次编译需要花费时间。至于那些没有被调用的方法，则不会被编译。 当编译器生成一个EXE文件后， 该程序的入口函数为Main() 方法。装载器将这个EXE 文件载入，探测到该这是一个托管EXE，于是又载入 .NET运行时库文件(包括即时编译器)， 接着调用了EXE 的Main() 方法。这将触发对Main()方法的即时编译， Main()方法在内存中被替换为本地机器语言，于是 .NET应用程序开始运行。在被编译为本地语言后，应用程序便可以自由调用本地代码了。当程序中止时，本地代码从内存中释放，所以在下次运行时，IL需要被即时编译器重新编译。 CTS类型规范，规定了类型必须如何定义才能被CLR承载。內建的CTS数据类型： CLS不同的语言有不同的表示，理想情况是所有支持.NET的语言都有一个可遵循的基准。描述了支持.NET的编译器必须支持的最小的和完全的特征集。以生成可由CLR承载的代码。 mscoree.dll工作流 .NET命名空间举例 Microsoft根命名空间包含的类型用于和那些只属于Windows操作系统的服务进行交互 .NET SKD配置Path或者 开始-所有程序-Vs-VS Tools-开发人员命令提示 csc /t:exe[/target:exe] 1.cs csc 1.cs（默认） csc /t:library 1.cs（输出dll） 响应文件外部引用 /r:System.Windows.Forms.dll 输出 /target:exe /out:TestApp.exe *cs 默认响应文件csc.rsp（与csc.exe同目录），包含大部分常用程序集引用。默认被csc.exe引用。可以简写为： csc /out:TestApp.exe *.cs ## 第二/三部分：C#核心编程结构/C#面向对象编程char的静态方法char.IsDigit 是否为数字char.IsLetter 是否为字母char.IsWhiteSpace 是否为空白char.IsPunctuation 是否为标点char.IsLower 是否为小写char.IsUpper 是否为大写 改变枚举底层存储类型enum EmpType { Manager, Grunt, Contractor, VicePresident } 可以节省内存。但小心溢出可以定义未核心系统类型（byte,short,int或long） PS：获取底层存储类型 Enum.GetUnderlyingType(typeof(EmpType)) -&gt; System.Int32 获取名值对 var ret = Enum.GetValues(typeof(EmpType)); foreach (var item in ret) { Console.WriteLine(&quot;{0}，{0:D}&quot;, item); } System.ValueType枚举，结构都隐式派生自此类型。分配在栈上运行 浅/深复制当一个值类型中包含一个引用类型。如结构中包含对象引用，直接等号赋值时会有两个独立的结构，内部生成一个引用的副本，指向内存中同一个对象的引用。（浅复制） 默认访问修饰符类型成员（变量，方法），是隐式【私有】的。类型（对象）是隐式【内部】的。 class Radio //内部 { Radie(){} //私有 } Const,readonly,staticconst(常量)=readonly(只读)+static(静态)编译期确定 运行期确定都不可再更改 ## 第四部分：高级C#编程结构delegate关键字使用此关键字创建委托时，就间接声明了一个派生自MulticastDelegate的类。不会直接派生自这些基类，但这个类“是”MulticastDelegate 委托一个委托对象维护一个可调用方法的列表，而不是一个单独的方法。添加方法，使用+=即可。编译器会将+=转换为Delegate.Combine()方法调用。+=更简洁-=则转换为Delegate.Remove() event事件事件会扩展为两个隐藏的公共方法，一个add_xx，一个remove_xx。调用者仅需使用+=和-=操作符（操作符将在后台触发正确的add_xx和remove_xx方法，来对原委托进行操作）。 EventHanlder自定义EventArgs的泛型委托 class My { public event EventHandler&lt;MyEventArgs&gt; Display; public void Do(MyEventArgs msg) { if (Display != null) { Display(this, msg); } } } 不再需要定义一个自定义委托类型 操作符重载的思考通常仅在构建原子数据类型时才有用。文本，点，举行，分数等都是操作符重载的很好候选。人，经理，汽车，数据库连接等却不是。如果一个重载操作符会使用户更难于理解该类型的功能，那就别用它。 Try catch的CIL实现对一个实现了IDispose对象的using{}语句块会被CIL解析为一个try{}finally{}块。确保Dispose的执行。 new关键字的CIL实现使用new时，等同于CIL指令newobj：执行：1，计算分配对象需要总内存数2，检查托管堆，如果空间足够，则调用类型构造函数，最终将内存中新对象的应用返回给调用者。它的地址恰好是下一个对象的上一个位置。如果空间不足，则执行一次垃圾回收来尝试是否内存。3，返回引用之前，移动下一个对象的指针，指向托管堆上的下一个可用的位置。 自动属性的CIL实现自动属性的get;set;标记会在元数据中被编译器映射成一个私有字段Name和两个方法get_Name(),set_Name()。 应用程序根根(root)就是一个存储位置，保存着对托管堆上对象的引用。垃圾回收时，CLR判读托管堆上的对象，判断应用程序是否仍然可访问它们(是否还有根)。为此，CLR建立一个对象图。不可访问的对象被标记为终结(finalize，垃圾)，它们就会从内测中清除。此时，堆上剩余的空间被压缩调整，引起CLR修改活动应用程序根的集合，指向正确的内存位置。下一个对象的指针被重新调整指向下一个可用位置。 对象的代设计思路：对象在堆上存在的时间越长，他就更可能应该保留。(WinForm主窗口)最近才放在堆上的对象可能很快就不可访问了。(一个方法中创建的对象)。第0代：从没有被标记为回收的新分配对象。第1代：在上一次垃圾回收中没有被回收的对象(曾被标记为回收，但因为已经从其他对象获取了足够的堆空间而没有被删除)第2代：在一次以上的垃圾回收后仍然没被回收的对象。 通过给对象赋一个表示代的值，尽快的删除一些较新的对象(本地变量)，而不会经常打扰一些旧对象(主窗体) 强制垃圾回收GC.Collect(); //强制回收所有代 //GC.Collect(1, GCCollectionMode.Forced); //回收0-1代 GC.WaitForPendingFinalizers(); //挂起线程，等待回收结束 适用：1，程序将进入一段代码，后者不希望被可能得垃圾回收中断。2，刚刚分配分厂多的对象，想尽可能多地删除已获得的内存。 GC测试 //输出堆上估计得字节数 Console.WriteLine(GC.GetTotalMemory(false)); //目前最高代 Console.WriteLine(GC.MaxGeneration); //某对象处于多少代 object obj = new object(); Console.WriteLine(GC.GetGeneration(obj)); //测试数组 object[] objs = new object[500000]; for (int i = 0; i &lt; 500000; i++) objs[i] = new object(); //输出堆上估计得字节数 Console.WriteLine(GC.GetTotalMemory(false)); //回收第1代 GC.Collect(0, GCCollectionMode.Forced); GC.WaitForPendingFinalizers(); Console.WriteLine(GC.GetGeneration(obj)); //看一下9000是否还活着 if (objs[9000] != null) Console.WriteLine(&quot;活着：处于&quot; + GC.GetGeneration(objs[9000]) + &quot;代&quot;); else Console.WriteLine(&quot;死了&quot;); //某代被回收次数 Console.WriteLine(&quot;0代：{0}，1代：{1}，2代：{2}&quot;, GC.CollectionCount(0), GC.CollectionCount(1), GC.CollectionCount(2)); //跳过对象的终结阶段，通知CLR不在调用对象的析构函数 GC.SuppressFinalize(this); 资源包装器引用托管或非托管宝贵的资源(数据库，文件句柄等)时，希望尽可能快的释放资源。而不能依靠GC的回收。 class MyResourceWrapper : IDisposable { //判断Dispose()是否被调用过 private bool disposed = false; //用户忘了Dispose()，垃圾回收器会调用这个方法 ~MyResourceWrapper() { //调用辅助方法，指定false表示GC触发了清理 CleanUp(false); } //用户可以主动调用，来尽快清除资源 public void Dispose() { //调用辅助方法，指定true表示用户触发了清理 CleanUp(true); GC.SuppressFinalize(this); } private void CleanUp(bool disposing) { if (!disposed) { //如果disposing为true，释放所有托管资源。如果disposing为false，不确定托管资源是否还在内存中，不执行释放。 if (disposing) { //释放托管的资源 } //在这里释放非托管的资源 } disposed = true; } } 测试： ~MyResourceWrapper() { Console.Beep(); //命令行一声响声 CleanUp(false); } static void Main(string[] args) { MyResourceWrapper m = new MyResourceWrapper(); m.Dispose(); MyResourceWrapper m1 = new MyResourceWrapper(); //此时会响一声 } Lazy 延迟加载class Program { static void Main(string[] args) { MP3 m = new MP3(); //不使用Lazy，此句加载SDCard，然后初始化Song[] var r = m.Card; var v = r.Value; //使用Lazy，此句加载SDCard，然后初始化Song[] //或 var c = m.GetCard(); Console.ReadKey(); } } class Song { public string FileName { get; set; } public string FileLength { get; set; } } class SDCard { public decimal Price { get; set; } private Song[] allSongs = new Song[100000]; public SDCard() { Console.WriteLine(&quot;装满歌曲&quot;); } } class MP3 { //public void Play() //播放 //public void Pause() //暂停 //public void Stop() //停止 public Lazy&lt;SDCard&gt; Card = new Lazy&lt;SDCard&gt;(() =&gt; //不传参或传一个Lambda表达式 { var newCard = new SDCard { Price = 50 }; return newCard; }); public SDCard GetCard() { return Card.Value; } } 第五部分：用.NET程序集编程.NET程序集的作用1，促进代码重用。一个代码库(.dll或.exe)被打包后，可以被外部应用程序调用。.NET平台允许我们以语言无关的方式来重用其中的类型，如C#创建，其他.NET语言调用。2，确定类型便捷。类型的完全限定名需要加上类型所在程序集。如两个不同程序集中命名空间相同的类，被认为是不同的。3，可版本化的单元。每个程序集被分配一个...的四部分数字版本号(默认1.0.0.0，默认VS项目设置)。版本号加上可选的公钥值(即程序集强名)使一个程序集的不同版本可在同一台机器共存而不冲突 。通过强名，CLR保证客户端调用程序能加载正确版本的程序集。4，自描述。程序集记录了清单数据(自身运行需要的外部程序集)，还包含了一些元数据(程序集包含的每一个类型的组成，成员名称，接口，基类，构造等)。由于信息被详细的记录了，CLR不需要访问注册表来解析程序集的位置(区别于与微软原来的COM编程模型)5，可配置的。程序集可“私有”或“共享”。私有：与调用它的客户端应用程序处于同一个目录或子目录下，共享：被部署在全局程序集缓存（GAC）的特定目录中。通过编写XML的配置文件，CLR可以指定位置朝赵，加载指定版本的程序集。查阅本地，网络或URL上的任意目录。 程序集和托管模块一个团队（程序集），是一个逻辑单位。里面有很多成员（托管模块）成员分2类：普通成员（托管模块，后缀.netModule。持有元数据和CIL代码）领导成员（主模块，后缀.exe或.dll。持有程序集清单），了解每个成员一般与这个团队（程序集）沟通或合作是面向它的领导（主模块），同样以领导名称来称呼这个团队。 C#生成的程序集一般为单模块程序集（只有主模块）。 .NET程序集的格式(.dll或.exe)包含：1，Windows文件首部：可被Windows操作系统加载，标识了应用程序以什么类型（控制台，图形用户界面还是*.dll代码库）驻留于Windows操作系统中。2，CLR文件首部使CLR了解托管文件的布局，位置和强名等3，CIL代码独立于平台和CPU的中间语言，运行时才被JIT变异成特定平台和CPU的指令。4，类型元数据内含类型和外部应用类型的格式。5，程序集清单记录了每一个模块，版本和引用的外部程序集。6，可选的嵌入资源图标，图像，声音，字符串表。卫星程序集(附属程序集)可构建国际化软件系统。 代码中的每个字符串字面量都记录在元数据的User Strings 标记下所以不能储存敏感信息。 私有程序集应用程序添加外部程序集引用的时候，把副本文件放在本地bin文件夹下。调用时，CLR只是加载本地的副本。并不查询系统注册表。 配置私有程序集：Test.exe //一个Console控制台程序Carlib.dll //控制台会调用的程序集 以下三种情况会正常运行：1，把Test.exe和Carlib.dll放在同一个文件夹下2，找不到Carlib.dll的文件，会查找同一个文件夹下具有相同友好名称的可执行程序集.exe文件3，找与程序集同名的文件夹下是否有此程序集。如Carlib/Carlib.dll4，如果有Test.exe.config配置文件，CLR会根据配置的“规则”探测指定文件夹下是否有此程序集。例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;probing privatePath=&quot;CarLibChg/&quot; /&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; &lt;/configuration&gt; 如果还是找不到，会引发FileNotFoundException异常 PS：VS的App.config会在编译的时候，把App.config的数据复制到bin/debug/文件下，并改一个合适的名称。如Test.exe.config，FrontWeb.dll.config 共享程序集例如mscorlib.dll，旨在多个项目中服用的类型的集合，共享程序集的一个副本可供一台机器上的多个应用程序使用，是机器级别的类库（machine wide）。 全局程序集缓存：.NET 3.5以前的位置在，C:\Windows\assembly下4.0以上的在C:\Windows\Microsoft.NET\assembly\GAC_MSIL下的v4.0_major.minor.build.revision_publicKeyTokenValue子文件夹下。例如：v4.0_4.0.0.0__b77a5c561934e089。 强名称1，需要.NET的sn.exe工具生成公钥/私钥对。生成一个.snk（Strong Name Key）文件。C#编译器确定.snk文件的位置后，会在编译时把公钥值记录在程序集清单的.publickey标记中。2，产生一个基于整个程序集内容（CIL代码，元数据等）的散列值（某一固定输入的独一无二的数值输出，如果更改了程序集的内容，就算只一个字符，陈胜的讲师完全不同的散列码）。散列码结合私钥组成数字签名，并把它嵌入到程序集的CLR首部数据中。 用命令行生成强名：developer Command Prompt下 sn -k 文件名.snk 再在AssemblyInfo.cs文件中指定位置 [assembly: AssemblyKeyFile(@&quot;C:\MyTestKeyPair.snk&quot;)] 编译时，公钥被压缩成散列值加入到清单中 .publicKeyToken标记 用VS生成强名：Properties -&gt; 签名 -&gt;新建便会在根目录下生成一个*.snk文件 在GAC中安装强名称的程序集使用Developer Command Prompt定位到*.dll所在目录（bin\debug）使用 gacutil -i test.dll/test.exe //安装 gacutil -l test //核实 gacutil -u test //卸载 VS引用程序集时，如果清单中含有.publickey值时，VS会嘉定这个具有强名称的程序集以备部署到GAC中，那么引用的属性窗口中的，复制本地就为false。不会对该程序集进行复制到本地debug文件夹中的工作。 配置共享程序集发布了1.0.0.0版本后，添加了一些新的功能，产生了2.0.0.0版本。如果客户端应用程序想要使用2.0.0.0版本的新功能，可以把2.0.0.0版本发布到目标机器，让2和1版本和平共处。需要的时候修改*.config文件，动态的定向到2.0.0.0版本。这一切并不需要重新编译和部署。 动态重定向到共享程序集： &lt;dependentAssembly&gt; &lt;assemblyIdentity name=&quot;System.Web.Mvc&quot; publicKeyToken=&quot;31bf3856ad364e35&quot; /&gt; &lt;bindingRedirect oldVersion=&quot;0.0.0.0-5.2.3.0&quot; newVersion=&quot;5.2.3.0&quot; /&gt; &lt;/dependentAssembly&gt; 定义了程序清单当前指向的版本(oldVersion)和GAC中的替代版本(newVersion) 元素用于指示CLR探测位于任意位置（网络重点，其他本地目录）的依赖程序集。当指向远程计算机时，相关程序集会下载到GAC的下载缓存中。通过此元素加载的程序集必须具有强名称。 例： &lt;codeBase version=&quot;2.0.0.0&quot; href=&quot;http://www.MySite.con/Assemblies/CarLibrary.dll&quot; /&gt; Type类型Car c = new Car(); Type t1 = c.GetType(); //编译器获得Type实例，需要类型实例 Type t2 = typeof(Car); //同上，不需类型实例 Type t3 = Type.GetType(&quot;ConsoleApplication2.Person&quot;, false, true); //完全限定名（不抛出异常，忽略大小写） Type t4 = Type.GetType(&quot;ConsoleApplication2.Person+Sex&quot;, false, true); //获得类型中的嵌套类型，加“+” Type t5 = Type.GetType(&quot;CarLib.Car,CarLib&quot;, false, true); //引用外部程序集类型，加“,” Type t6 = Type.GetType(&quot;System.Collections.Generic.List`1&quot;, false, true); //对于泛型，加“`”+数字（类型参数的个数） Console.ReadKey(); 动态加载程序集Assembly asm = Assembly.Load(&quot;Carlib&quot;); //需要保证程序集二进制文件在Debug文件夹下 asm = Assembly.LoadFrom(@&quot;C:\Code\Carlib.dll&quot;); //绝对路径，以编程的形式提供&lt;codeBase&gt;值 asm.GetTypes().ToList().ForEach(Console.WriteLine); 反射共享程序集string displayName = @&quot;System.Windows.Form.dll,Version=4.0.0.0,PublicKeyToken=b77a5c561934e089,Culture=&quot;&quot;&quot;; //显示名称：标识一个程序集的一组术语 //加载共享程序集必须指定公钥标记值 AssemblyName asmName = new AssemblyName(); asmName.Version = new Version(4, 0, 0, 0); //或者使用面向对象的类来传递Version,PublicKeyToken等参数 Assembly asm = Assembly.Load(displayName); asm = Assembly.Load(asmName); 晚期绑定Assembly asm = Assembly.Load(&quot;CarLib&quot;); //无需引用，只需把程序集文件放在Debug文件夹下 Type car = asm.GetType(&quot;CarLib.Car&quot;); object obj = Activator.CreateInstance(car); //建立一个晚期绑定类型的实例，类型为object。 object obj1 = Activator.CreateInstance(&quot;CarLib&quot;, &quot;CarLib.Car&quot;).Unwrap(); MethodInfo mi = car.GetMethod(&quot;Run&quot;); //无法转换类型，使用反射调用实例方法。默认搜索公共方法成员 mi.Invoke(obj, null); //调用无参方法 MethodInfo mi2 = car.GetMethod(&quot;Stop&quot;, BindingFlags.Instance | BindingFlags.NonPublic); //指定私有成员包含在搜索内 mi2.Invoke(obj, new object[] { &quot;停车&quot; }); //指定参数列表 关键在于，在没有某个程序集清单数据的情况下，创建程序集的类型实例。 特性用于类型，成员，程序集或模块的代码注解。把更多的元数据嵌入到程序集中。 程序集级别特性使用[assembly:]标签，给特定程序集所有类型应用特性。例：[assembly: CLSCompliant(true)]强制所有程序集中的公共类型符合CLS 构建可扩展的应用程序比如VS，开发的时候允许其他软件提供商向IDE开发环境中插入各种“钩子”（自定义模块），一个可能得思路如下： 1，可扩展的应用程序必须提供一些输入手段，允许用户指定被插入的模块。这需要动态加载2，必须要确定模块是否支持正确的功能（一组需要的接口）。这需要反射3，必须获取一个需要的基础架构的引用（例如接口类型）并调用成员触发底层功能。这经常需要晚期绑定。 1，构建每个插件对象需要实现的类型定义应用于插件对象和承载应用程序。保证功能统一 namespace CommonSnappableTypes { public interface IAppFunctionality { void DoIt(); } [AttributeUsage(AttributeTargets.Class)] public sealed class CompanyInfoAttribute : Attribute { public string CompanyName { get; set; } public string CompanyUrl { get; set; } } } 2，构建C#插件 namespace CSharpSnapIn { [CompanyInfo(CompanyName = &quot;JetBrains&quot;, CompanyUrl = &quot;www.xxx.com&quot;)] public class CSharpModule : IAppFunctionality { void IAppFunctionality.DoIt() //显示的接口实现，DoIt方法没有在CSharpModule中公开 { Console.WriteLine(&quot;使用了自定义插件&quot;); } 或 public void DoIt() { Console.WriteLine(&quot;使用了自定义插件&quot;); } } } 3，构建承载的应用程序 namespace ConsoleApplication2 { class Program { static void Main(string[] args) { string path = &quot;...&quot;; //可以从WinForm等应用程序中选择程序集文件 Assembly asm = Assembly.LoadFrom(path); //注意非空判断 //得到程序集中所有兼容IAppFunctionality的类 var types = asm.GetTypes().Where(m =&gt; m.IsClass &amp;&amp; m.GetInterface(&quot;IAppFunctionality&quot;) != null); foreach (var item in types) { IAppFunctionality app = (IAppFunctionality)asm.CreateInstance(item.FullName, true); //用晚期绑定获得实例 或 IAppFunctionality app1 = (IAppFunctionality)Activator.CreateInstance(item); app.DoIt(); } Console.ReadKey(); } } } dynamic允许我们在类型安全的强类型世界里使用校本化的行为。可以认为dynamic关键字是一个特殊形式的System.Object。但提供了更多特性，并且动态数据不是强类型的，或者说动态数据不是静态类型。 作用范围：字段，属性，返回值，参数 调用动态声明的数据成员动态数据不属于静态类型，和js一样，直到运行时你才会直到所调用的动态数据是否支持指定的成员，参数以及成员的拼写是否无误等。编译时不能触发智能感知提示。 dynamic实际用途构建一个需要大量使用后期绑定（通过反射）的.NET应用程序时。或者构建一个需要与遗留的COM库（如Office）进行交互的.NET应用程序。使用dynamic可以大大减少打字时间，简化代码。但代价是失去了类型的安全性。 DLR(dynamic language runtime，动态语言运行时)的特性1，机器灵活的代码库，重构时不需要频繁修改数据类型2，不同平台和语言所构建的对象类型之间进行互操作非常简便。3，可以在运行时为内存中的类型添加或移除成员。 使用dynamic简化晚期绑定Type type=...; 1，通过反射 object obj=Activator.CreateInstance(type); MethodInfo mi=tpe.GetMethod(&quot;Run&quot;); object[] param=10,20; mi.Invoke(obj,param); 2，通过dynamic dynamic obj=Activator.CreateInstance(type); obj.Run(10,20); 简化了查询程序集元数据和打包参数等操作。 互操作程序集IDE以COM库为基础生成的全新程序集，包含了COM元数据的.NET描述和一小部分将COM事件转换为.NET事件的代码。封装，避免了内部COM的复杂性。 CLR（如果使用dynamic就是DLR）自动对.NET数据类型和COM类型进行映射，因此可以直接在C#代码中使用互操作程序集。在后台，使用RCW（Runtime Callable Wrapper，一个动态生成的代理）对数据进行封送，使其在.NET和COM应用程序之间交互。 主互操作程序集许多COM库供应商提供了一个“官方”的互操作程序集，成为主互操作程序集，简称PIA。PIA是优化的互操作程序集，比通过IDE添加COM库引用生成的代码更整洁，也更具扩展性。PIA存在的情况下，添加应用一个COM库，VS会使用提供的PIA，而不是生成一个新的互操作程序集。 嵌入互操作元数据添加COM库（PIA或其他）时，IDE会自动将该库的“嵌入互操作类型”置为true。这样，必要的互操作元数据（你真正使用的那部分，而不是全部）已经硬编码到.NET程序中，我们就不必在.NET应用程序中携带互操作程序集的副本了。减少了安装包的尺寸，客户端计算机也不必包含改互操作程序集的副本。 表达式树当使用DLR进行处理动态数据时，自动创建的“表达式树”将被传递给正确的动态语言帮顶起。帮顶起解析表达式树并传递给正确的对象成员。 进程一个正在运行的应用程序的固定的安全的边界。用来描述一组资源（外部代码库和主线程）和程序运行所必须的内存分配。 应用程序域：对该进程的逻辑细分。一个应用程序域进一步被细分成多个上下文边界，用来分组目的相似的.NET对象。 进程，应用程序域，上下文的关系： 线程：进程中的独立的基本的执行单元。每一个进程都有一个（在可执行入口处创建的）主线程和其他包含以编程方式创建的额外线程。 进程和线程的关系：当一个线程的时间片用完的时候，会被挂起，以便执行其他线程。线程把挂起前的情况写到线程本地存储中（Thread Local Storage，TLS），并且它们还要获得一个独立的调用栈（call stack） Process类using System.Diagnostics; var procs = Process.GetProcesses(&quot;.&quot;); procs.OrderBy(m =&gt; m.Id).ToList().ForEach(m =&gt; Console.WriteLine(&quot;{0}：{1}&quot;, m.Id, m.ProcessName)); var proc = Process.GetProcessById(4); //进程不存在则引发异常 //PID为0的System Idle Prcess，表示系统核心虚拟出来的表示CPU空闲的状态。输入会出错。 Console.WriteLine(proc.Id + &quot;：&quot; + proc.ProcessName); //ProcessThread并不用于操作线程，只是用户获取运行进程中线程的诊断信息 foreach (ProcessThread item in proc.Threads) { Console.WriteLine(&quot;{0}：{1}：{2}：{3}&quot;, item.Id, item.PriorityLevel, item.StartTime, item.ThreadState); } 查看进程中的模块var proc = Process.GetProcessById(10284); var modls = proc.Modules; foreach (ProcessModule item in modls) { Console.WriteLine(&quot;{0}：{1}&quot;, item.ModuleName, item.ModuleMemorySize); } 编程方式启动或结束进程var proc = Process.Start(&quot;Chrome&quot;, &quot;www.baidu.com&quot;); Console.WriteLine(&quot;启动：&quot; + proc.ProcessName + &quot;，PID：&quot; + proc.Id); Console.ReadKey(); proc.Kill(); //如果进程已关闭，或附加到别的进程上。则此处会抛出异常 ProcessStartInfo启动进程ProcessStartInfo info = new ProcessStartInfo { FileName = &quot;Chrome&quot;, Arguments = &quot;www.baidu.com&quot;, WindowStyle = ProcessWindowStyle.Hidden }; var proc = Process.Start(info); 应用程序域传统的非托管程序直接承载在进程上，而.NET可执行程序承载在进程的一个逻辑分区中，即应用程序域（AppDomain）。运行在某个应用程序域中的应用程序将无法访问其他应用程序域中的数据（无论是全局变量还是静态字段），除非使用分布式编程协议（如WCF）好处在于：1，应用程序域是.NET平台操作系统独立性的关键特性。将不同操作系统表现加载可执行程序的差异抽象化了。2，和一个完整的进程相比，应用程序域的CPU和内存占用都有小的多。因此CLR加载和卸载应用程序域比起来完整的进程来说也快得多，并且可以快速提升服务器应用程序的可扩展性。3，应用程序域为承载的应用程序提供了深度的隔离。如果进程中一个应用程序域失败了，剩余的应用程序域也能保持正常。 .NET平台不允许从内存中卸载指定的程序集。已编程方式卸载库的唯一方式是使用Unload()方法销毁承载的应用程序域。 默认程序域一个.NET可执行文件启动时，CLR会自动将其放置到宿主进程的默认应用程序域中。访问当前线程的应用程序域 AppDomain app = AppDomain.CurrentDomain; Console.WriteLine(&quot;{0}：{1}：{2}：{3}&quot;,app.FriendlyName,app.Id,app.IsDefaultAppDomain(),app.BaseDirectory); //BaseDirectory，程序集解约程序用它来探测程序集 应用程序域中加载的.NET程序集AppDomain app = AppDomain.CurrentDomain; var asms = app.GetAssemblies(); foreach (Assembly item in asms) { Console.WriteLine(item.GetName().Name + &quot;：&quot; + item.GetName().Version); } 接收程序集加载通知AppDomain app = AppDomain.CurrentDomain; app.AssemblyLoad += (o, s) =&gt; { Console.WriteLine(s.LoadedAssembly.GetName().Name); }; 创建新的应用程序域AppDomain app = AppDomain.CreateDomain(&quot;Second&quot;); foreach (Assembly item in app.GetAssemblies()) { //只加载了mscorlib。如果调试的话还会加载用于调试的额外程序集 Console.WriteLine(item.GetName().Name); } app.Load(&quot;CarLib&quot;); //向自定义应用程序域中加载程序集，此时加载的程序集多了一个 AppDomain.Unload(app); //卸载自定义应用程序域 上下文边界给定对象“特定的家”一个进程定义了默认的应用程序域，每个应用程序域都有一个默认的上下文（总是第一个创建），也成为上下文0（context 0）。用于组合那些对上下文没有具体的或唯一性需求的.NET对象（大多数对象）。 不需要指定特定上下文的.NET类型称为上下文灵活（context-agile）对象，可以从应用程序域的任何位置访问，与对象的运行时需求没有关系。需要指定特定上下文的对象称为上下文绑定（context-bound）对象，只能在其被创建的那个上下文中正常运行。必须派生自System.ContextBoundObject基类 定义上下文绑定对象自动线程安全的类 using System.Runtime.Remoting.Contexts; using System.Threading; [Synchronization] public class ContextObject : ContextBoundObject { public void Do() { for (int i = 0; i &lt; 10; i++) { Console.WriteLine(i + &quot;：当前线程-&quot; + Thread.CurrentThread.ManagedThreadId); } } } static void Main(string[] args) { ContextObject obj = new ContextObject(); Task.Run(() =&gt; obj.Do()); Task.Run(() =&gt; obj.Do()); } 研究上下文using System.Runtime.Remoting.Contexts; using System.Threading; [Synchronization] public class ContextObjectBound : ContextBoundObject { public ContextObjectBound() { Context ctx = Thread.CurrentContext; Console.WriteLine(this + &quot; 在上下文中： &quot; + ctx.ContextID); foreach (var item in ctx.ContextProperties) { Console.WriteLine(item.Name); } } } public class ContextObject { public ContextObject() { Context ctx = Thread.CurrentContext; Console.WriteLine(this + &quot; 在上下文中： &quot; + ctx.ContextID); foreach (var item in ctx.ContextProperties) { Console.WriteLine(item.Name); } } } static void Main(string[] args) { ContextObject obj = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObject obj1 = new ContextObject(); //0，LeaseLifeTimeServiceProperty ContextObjectBound objTs = new ContextObjectBound(); //1，LeaseLifeTimeServiceProperty，Synchronization Console.ReadKey(); } CIL.NET平台语言（C#，VB，F#等）的母语，某个语言相关联的编译器会把源代码翻译成CIL CIL标记分为3类1，CIL指令以.前缀，例如：.namespace、.class、.pulickeytoken、.method、.assembly2，CIL特性例如：public，extends（指定这个类型的基类），implements（支持的一系列接口）3，CIL操作码例如：ldstr（LoadString，定义一个字符串变量），实际上是操作码的助记符。真正的操作码是二进制码。add - 0x58，sub - 0x59，newobj - 0x73 CIL基于栈的本质CIL不允许直接访问一个数据（本地变量、参数变量或属性）。而是通过虚拟执行栈来访问。string myMessage=”Hello”; //分为1-3Console.WriteLine(myMessage); //分为4-5 1，.locals init ([0] string myMessage)定义一个本地字符串变量（在Call Stack本地变量索引0处）2，ldstr “Hello”将字符串的引用放在了Envaluation Stack中，而真正的字符串放在了Managed Heap中3，stloc.0将Envaluation Stack中的值保存到 Call Stack中索引为0的本地变量中（V0，栈低已存在args[最底]和return address），因为Envaluation Stack中存放的是“hello”字符串的地址，所以变量中存放的也是字符串的地址。4，ldloc.0把Call Stack中索引0处变量的的值（引用地址），加载到Envaluation Stack中5，call void [mscorlib]System.Console::WriteLine(string)从 Evaluation Stack 中取出一个值，此值为 Reference Type，调用方法 PS：1，Managed Heap（托管堆）：这是动态配置（Dynamic Allocation）的记忆体，由GC在执行时自动管理，整个 Process 共用一个 Managed Heap，可以理解为引用类型的东西都放在这个Managed Heap中。2，Call Stack（调用栈）：CLR在执行时自动管理的记忆体，每个Thread都有自己的Call Stack堆栈。每调用一次method，就会使得Call Stack上多了一个Record Frame；调用完毕之后，此Record Frame会被丢弃。一般来说，Record Frame内记录着method参数（Parameter）、返回位址（Return Address）、以及局部变量（Local Variable）。CLR使用零基索引的方式来识别局部变量。3，Evaluation Stack（虚拟执行栈）：这是由 CLR在执行时自动管理的记忆体，每个Thread都有自己的Evaluation Stack。压入的到Evaluation Stack的值，当方法调用结束时必须保持这个堆栈的平衡（清空），这里面存放例如局部变量值，以及引用类型的地址。如果忘记清空，ilasm仍然会编译成功。可以用peverify.exe工具诊断。peverify test.dll4，ld，加载，用于压栈到虚拟执行栈5，st，存储，用于弹栈虚拟执行栈顶的值到内存调用栈中 CIL的代码标签例如：IL_0001：，IL_000c大多数标签是可选的，完全可以移除。只有编写有多个分支和循环结构的CIL代码时，通过这些标签指定逻辑流转到哪里的时候，才是必需的。 使用ilasm.exe编译CIL代码ilasm /exe Hello.il /output=NewAssembly.exe -?查看选项参数 CIL指令和特性1，指定外部应用程序集 .assembly extern mscorlib { .publickeytoken=(B7 7A 5C 56 19 34 E0 89) .ver 4:0:0:0 } 2，定义当前程序集 .assembly CILTypes { .ver 1:0:0:0 } .module CILTypes.dll //单模块程序集 3，定义命名空间 .namespace MyNamespance{} .namespace Myconpany.MyNamespace{} 4，定义类类型 .namespace MyNamespace { .class public MyBaseClass extends [BaseEntity]BaseEntity.AuditEntityBase{} //CIL要求使用完整的名字 } 5，定义和实现接口 .class public interface IMyInterface{} .class public MyBaseClass{} .class public MyDerivedClass extends MyNamespace.MyBaseClass implements MyNamespace.IMyInterface{} //同一程序集下可以省略“[]”前缀。 //extends在前，implements在后，多个接口用“，”分隔 //接口派生接口使用implements 6，定义结构 .class public sealed MyStruct extends [mscorlib]System.ValueType{} 简化： .class public sealed value MyStruct{} 7，定义枚举 .class public sealed MyEnum extends [mscorlib]Sytem.Enum{} 简化： .class public sealed enum MyEnum{} 8，定义泛型C#： List&lt;int&gt; myIntes=new List&lt;int&gt;(); CIL： newobj instance void class [mscorlib]Sytem.Collections.Generic.List`1&lt;int32&gt;::.ctor() 9，定义数据字段 .class public sealed enum MyEnum { .field public static literal valuetype MyNamespace.MyEnum A=int32(0) .field public static literal valuetype MyNamespace.MyEnum B=int32(1) } 私有成员 .class public MyBaseClass { .filed private string stringField=&quot;hello!&quot; .filed private int32 intField=int32(42) } 10，定义属性 .class public MyBaseClass { .method public hidebysig specialname instance string get_TheString() cil managed { //实现 } .method public hidebysig specialname instance void set_TheString(string &apos;value&apos;) cil managed { //实现 } .property instance string TheString() { .get instance string MyNamespace.MyBaseClass::get_TheString() .set instance void MyNamespace.MyBaseClass::set_TheString(string) } } 11，定义构造函数 .class public MyBaseClass { .fileld private int32 intField .method public hidebysig specialname rtsspecialname instance void .ctor(string s,int32 i) cil managed { //实现 } //.ctor指令和instance特性结合使用 //cil managed标识出这个方法包含的是CIL代码而不是非托管代码 } 12，定义参数C#： public static void MyMethod(int inputInt,ref int refInt,ArrayList ar,out outputInt) { outputInt=0; } CIL： .method public hidebysig static void MyMethod(int32 inputInt, int32&amp; refInt, class [mscorlib]System.Collections.ArrayList ar, [out] int32&amp; outputInt) cil managed { //... } .NET 基础类库、C#和CIL数据类型的映射 .maxstack指令确定一个在方法执行阶段可以被压入栈中的最大变量数目。默认值是8 在CIL中映射参数到本地变量C#： public static int Add(int a,int b) { return a+b; } CIL：//已简化 .method public hidebysig static int32 Add(int32 a,int32 b) cilmanaged { .maxstack 2 ldarg.0 //加载&apos;a&apos;到栈中 ldarg.1 //加载&apos;b&apos;到栈中 add //从栈中弹出这2个值，并求和，并将计算结果存回栈中 ret //将和弹出栈，并通过ret操作码返回到调用者 } this隐式引用虚拟执行栈索引是从0开始。在使用CIL代码时，任何非静态函数在接收传入参数时都自动隐式地接受了一个附加参数，即当前对象的引用（this）。C#： public int Add(int a,int b) { return a+b; } CIL：//伪代码，this是隐式的接受的 .method public hidebysig static int32 AddTwoInt(MyClass_HiddenThisPointer this,int32 a,int32 b) cil managed { ldarg.0 //加载MyClass_HiddenThisPointer到虚拟执行栈上 ldarg.1 //加载&apos;a&apos; ldarg.2 //加载&apos;b&apos; } 循环结构C#： public static void CountToTen() { for(int i=0;i&lt;10;i++); } CIL： .method public hidebysig static void COuntToTen() cil managed { .maxstack 2 .locals init ([0] int32 i) //初始化本地变量&apos;i&apos; IL_0000: loc.i4.0 //压栈&apos;0&apos;到栈中 IL_0001: stloc.0 //弹栈&apos;0&apos;，并存储这个值到调用栈变量索引&apos;0&apos; IL_0002: br.s IL_0008//跳转到IL_0008 IL_0004: ldloc.0 //压栈索引0的值 IL_0005: ldc.i4.1 //压栈&apos;1&apos; IL_0006: add //两值弹栈，相加，结果压栈 IL_0007: stloc.0 IL_0008: ldloc.0 //压栈索引0的值 IL_0009: ldc.i4.s 10 //压栈&apos;10‘ IL_000b: blt.s IL_0004 //两值弹栈，比较。小于10？如果是，跳转IL_0004 IL_oood: ret // } 动态程序集静态程序集：存在于磁盘的.NET二进制文件 动态程序集：运行中通过使用System.Reflection.Emit命名空间提供的类型在内存中创建程序集及其模块，类型定义以及CIL实现逻辑。并可以保存到磁盘上生成一个新的静态程序集。 用处： 构建需要根据用户输入来生成程序集文件的.NET开发工具 构建需要在运行时通过元数据来生成远程类型的代理的程序 加载静态程序集并能动态插入新类型到二进制图像中。 System.Reflection.Emit命名空间的成员 ILGenerator注入CIL操作码到一个给定的类型成员 产生动态程序集，保存并实现延迟绑定class Program { static void Main(string[] args) { CreateMyAm(AppDomain.CurrentDomain); Assembly asm = Assembly.Load(&quot;MyAssembly&quot;); Type type = asm.GetType(&quot;MyAssembly.HelloWorld&quot;); var mi = type.GetMethod(&quot;SayHello&quot;); object obj = Activator.CreateInstance(type, &quot;123&quot;); mi.Invoke(obj, null); mi = type.GetMethod(&quot;GetMsg&quot;); Console.WriteLine(mi.Invoke(obj, null)); Console.ReadKey(); } static void CreateMyAm(AppDomain app) { //建立通用程序集特征 AssemblyName asmName = new AssemblyName { Name = &quot;MyAssembly&quot;, Version = new Version(1, 0, 0, 0), KeyPair = new StrongNameKeyPair(File.ReadAllBytes(@&quot;C:\test.snk&quot;)) //产生强名，才可以直接引用，并使用using }; //在当前应用程序域中创建一个新的程序集 AssemblyBuilder asm = app.DefineDynamicAssembly(asmName, AssemblyBuilderAccess.Save); //因为是单文件程序集，模块的名字就是程序集的名字 ModuleBuilder module = asm.DefineDynamicModule(&quot;MyAssembly&quot;, &quot;MyAssembly.dll&quot;); //定义一个公共类 TypeBuilder myClass = module.DefineType(&quot;MyAssembly.HelloWorld&quot;, TypeAttributes.Public); //定义一个私有字符串成员变量 FieldBuilder strField = myClass.DefineField(&quot;theMessage&quot;, typeof(string), FieldAttributes.Private); //创建自定义的构造函数 ConstructorBuilder ctor = myClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] { typeof(string) }); ILGenerator ilCtor = ctor.GetILGenerator(); ilCtor.Emit(OpCodes.Ldarg_0); ConstructorInfo superCtor = typeof(object).GetConstructor(new Type[0]); ilCtor.Emit(OpCodes.Call, superCtor); //调用基类构造函数 ilCtor.Emit(OpCodes.Ldarg_0); //压栈对象的this指针 ilCtor.Emit(OpCodes.Ldarg_1); //压栈参数 ilCtor.Emit(OpCodes.Stfld, strField); //存储在this的strField ilCtor.Emit(OpCodes.Ret); //创建默认构造函数 myClass.DefineDefaultConstructor(MethodAttributes.Public); //创建GetMsg()方法 MethodBuilder getMsg = myClass.DefineMethod(&quot;GetMsg&quot;, MethodAttributes.Public, typeof(string), null); ILGenerator ilMethod = getMsg.GetILGenerator(); ilMethod.Emit(OpCodes.Ldarg_0); ilMethod.Emit(OpCodes.Ldfld, strField); ilMethod.Emit(OpCodes.Ret); //创建SayHello()方法 MethodBuilder sayHello = myClass.DefineMethod(&quot;SayHello&quot;, MethodAttributes.Public); ilMethod = sayHello.GetILGenerator(); ilMethod.EmitWriteLine(&quot;Hello World!&quot;); ilMethod.Emit(OpCodes.Ret); //创建类Hello World myClass.CreateType(); //保存程序集 asm.Save(&quot;MyAssembly.dll&quot;); } } 第六部分：.NET基础类库应用程序域和线程一个应用程序域可以承载多个线程，线程可以跨越不同的应用程序域 AppDomain ad=Thread.GetDomain(); 获取正在承载当前线程的应用程序域 Context ctx=Thread.CurrentContext; 获取当前操作线程所处的上下文 委托的异步性class Program { public delegate int MyMethod(int x, int y); private static bool isDone = false; static void Main(string[] args) { Console.WriteLine(&quot;Main，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId); MyMethod m = Add; IAsyncResult ar = m.BeginInvoke(10, 10, AddComplete, &quot;R U Ok?&quot;); //开启异步，使用的是线程池的工作者线程（后台线程） //轮询方式 //while (!ar.AsyncWaitHandle.WaitOne(1000,true)) //{ // Console.WriteLine(&quot;Working...&quot;); //} //回调方式 while (!isDone) { Thread.Sleep(1000); Console.WriteLine(&quot;Working...&quot;); } Console.ReadKey(); } static int Add(int x, int y) { Console.WriteLine(&quot;Add，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId); Thread.Sleep(3000); return x + y; } static void AddComplete(IAsyncResult result) { Console.WriteLine(&quot;Complete，线程ID：&quot; + Thread.CurrentThread.ManagedThreadId + &quot;，Msg&quot; + result.AsyncState); AsyncResult ar = (AsyncResult)result; MyMethod m = (MyMethod)ar.AsyncDelegate; Console.WriteLine(&quot;Result：&quot; + m.EndInvoke(result)); isDone = true; } } Threading命名空间 AutoResetEvent类线程同步的通知类 public static AutoResetEvent waitHandle = new AutoResetEvent(false); //阻塞一个线程，直到收到通知 waitHandle.WaitOne(); //通知一个或多个线程事件终止，允许继续 waitHandle.Set(); TimerCallBack定时任务 static void Main(string[] args) { Timer t = new Timer(Print, &quot;时间：&quot;, 0, 1000); Console.ReadKey(); } static void Print(object state) { Console.Clear(); Console.WriteLine(state + DateTime.Now.ToLongTimeString()); } ThreadPool的好处1，减少了线程创建、开始和停止的次数，这提高了效率2，能够使我们将注意力放到业务逻辑上而不是多线程架构上 某些情况仍应优先使用手工线程管理：1，需要前台线程或设置优先级别，线程池中的线程总是后台线程，优先级是默认的。无法修改2，需要一个带有固定标识的线程便于退出、挂起或通过名字发现它。 Parallel类class Program { private static CancellationTokenSource cts = new CancellationTokenSource(); static void Main(string[] args) { string filePath = @&quot;C:\Pictures&quot;; string[] files = Directory.GetFiles(filePath, &quot;*.jpg&quot;, SearchOption.TopDirectoryOnly); string newPath = @&quot;C:\Pictures\new&quot;; if (!Directory.Exists(newPath)) { Directory.CreateDirectory(newPath); } //并行方式 ParallelOptions option = new ParallelOptions { CancellationToken = cts.Token, MaxDegreeOfParallelism = System.Environment.ProcessorCount }; try { //主线程仍然被阻塞，等待其他线程完成工作 Parallel.ForEach(files, option, m =&gt; { option.CancellationToken.ThrowIfCancellationRequested(); string fileName = Path.GetFileName(m); using (Bitmap map = new Bitmap(m)) { map.RotateFlip(RotateFlipType.RotateNoneFlipX); //左右翻转 map.Save(Path.Combine(newPath, fileName)); Console.WriteLine(&quot;Id：&quot; + Thread.CurrentThread.ManagedThreadId); } }); } catch (Exception e) { //处理 } Console.WriteLine(&quot;等待中...（最后才显示）&quot;); Console.ReadKey(); } } Parallel.Invoke(() =&gt; { var ret = DoSomething(); }, () =&gt; { var ret = DoAnthor(); }); 次线程访问UI线程的控件this.Invoke((Action)delegate { this.Text=....; }); WinForm中，线程创建的控件具有“线程相关性”。次线程不能直接访问主线程（UI线程）创建的控件，可以通过此方法传递异步委托执行。 async await关键字class Program { static void Main(string[] args) { Console.WriteLine(&quot;Main Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 new Program().Entry(); Console.WriteLine(&quot;等待中...&quot;); //先出现 Console.WriteLine(&quot;Main Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 Console.ReadKey(); } public async Task&lt;string&gt; DoItAsync() //约定以Asynv后缀 { Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 var r = await Task.Run(() =&gt; //开启新线程，主线程在执行完await标记的代码（Task.Run创建新线程部分，不包含内部的委托部分）后跳出 { Thread.Sleep(3000); Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 return &quot;haha&quot;; }); Console.WriteLine(&quot;DoIt Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 return r; } public async void Entry() { Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //主线程 string ret = await DoItAsync(); //await 负责提取包含在Task对象中的内在返回值。 //主线程把具有await标记的DoIt() 执行完毕之后，跳出此方法到调用处继续执行。 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程 Console.WriteLine(ret); } } 返回void的异步方法返回非泛型的Task类，并忽略return private asynv Task MethodVoidAsync() { await Task.Run(() =&gt; { //... } } 多个await的异步方法public async void Entry() { //调用者线程 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //调用者跳出返回，开启新线程1 await Task.Run(() =&gt; Thread.Sleep(3000)); //新线程1 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); //新线程1销毁，开启新线程2 await Task.Run(() =&gt; Thread.Sleep(3000)); //下同 Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); await Task.Run(() =&gt; Thread.Sleep(3000)); Console.WriteLine(&quot;Entry Id:&quot; + Thread.CurrentThread.ManagedThreadId); } System.IO 获取计算机上驱动器的细节DriveInfo[] drives = DriveInfo.GetDrives(); StreamWriter和StreamReaderusing (StreamWriter writer = File.CreateText(&quot;1.txt&quot;)) { writer.WriteLine(&quot;hahaha&quot;); writer.WriteLine(&quot;hahaha&quot;); writer.Write(writer.NewLine); } 等于 using (StreamWriter writer=new StreamWriter(&quot;1.txt&quot;)) { } using (StreamReader reader = File.OpenText(&quot;1.txt&quot;)) { string buffer; while ((buffer = reader.ReadLine()) != null) { Console.WriteLine(buffer); } } 等于 using (StreamReader reader=new StreamReader(&quot;1.txt&quot;)) { } BinaryWriter类允许我们从基层流中以简洁的二进制格式读取或写入离散数据类型 using (BinaryWriter bw=new BinaryWriter(File.OpenWrite(&quot;1.txt&quot;))) { Console.WriteLine(&quot;Type：&quot;+bw.BaseStream); bw.Write(&apos;1&apos;); bw.Write(&quot;123&quot;); bw.Write(123); bw.Write(12.3); } using (BinaryReader br=new BinaryReader(File.OpenRead(&quot;1.txt&quot;))) { Console.WriteLine(br.ReadString()); //只有&quot;123&quot; } 文件监视FileSystemWatcher watcher = new FileSystemWatcher { Path = Directory.GetCurrentDirectory(), Filter = &quot;*.txt&quot;, NotifyFilter = NotifyFilters.LastAccess | NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName }; watcher.Changed += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Created += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Deleted += (o, e) =&gt; Console.WriteLine(e.FullPath + &quot;\t&quot; + e.ChangeType); watcher.Renamed += (o, e) =&gt; Console.WriteLine(e.OldFullPath + &quot;\t&quot; + e.FullPath); watcher.EnableRaisingEvents = true; 对象序列化[Serializable] class Program { public string Name { get; set; } static void Main(string[] args) { Program p = new Program { Name = &quot;Main&quot; }; BinaryFormatter format = new BinaryFormatter(); using (var stream = File.OpenWrite(&quot;1.txt&quot;)) { format.Serialize(stream, p); } using (var stream = File.OpenRead(&quot;1.txt&quot;)) { Program p1 = (Program)format.Deserialize(stream); Console.WriteLine(p1.Name); } Console.ReadKey(); } } 对象图 持久化对象的格式using System.Runtime.Serialization.Formatters.Binary; using System.Xml.Serialization; using System.Runtime.Serialization.Formatters.Soap; XmlSerializer和SoapFormatterXmlSerializer:持久化为XML文档，只会保存公有已赋值字段或公共属性。可以保存偏好设置（颜色，文字大小等）SoapFormatter:持久化为一个SOAP消息（传递消息到Web服务或从Web服务传递消息的标准XML格式） static void Main(string[] args) { List&lt;Picture&gt; list = new List&lt;Picture&gt; { new Picture{ Id=0,Url=&quot;1.jpg&quot;}, new Picture{ Id=1,Url=&quot;2.jpg&quot;} }; XmlSerializer format = new XmlSerializer(typeof(List&lt;Picture&gt;), &quot;Carousels&quot;); 或 SoapFormatter format = new SoapFormatter(); using (var stream = File.OpenWrite(&quot;config.xml&quot;)) //从头覆盖内容，不会重建文件 或 using (var stream = new FileStream(&quot;config.xml&quot;, FileMode.Create, FileAccess.Write, FileShare.None)) //重建文件 { format.Serialize(stream, list); } using (var stream = File.OpenRead(&quot;config.xml&quot;)) { List&lt;Picture&gt; p1 = (List&lt;Picture&gt;)format.Deserialize(stream); p1.ForEach(m =&gt; Console.WriteLine(&quot;/images/&quot; + m.Url)); } Console.ReadKey(); } [Serializable] public class Picture { private int size; //XmlSerializer不会包含 public string Name = &quot;轮播图&quot;; public int Id { get; set; } public string Url { get; set; } } 格式化程序中的类型保真BinaryFormatter，持久化对象图中对象的字段数据，和每个类型的完全限定名城和定义程序集的完整名称（强名）。这些数据使跨越.NET应用程序机器边界传递对象成为理想的选择。SoapFormatter，XmsSerializer，没有序列化完整的.NET类型元数据（完全限定名称或程序集），可用于标准的.NETWeb服务，可被任何平台中的客户端调用（Windows、MAC OS X和Linux）。 控制生成的XML数据static void Main(string[] args) { Picture pic = new Picture { Id = 1, Url = &quot;2.jpg&quot;, Date = DateTime.Now.ToShortDateString(), Details = new List&lt;string&gt; {&quot;遍&quot;, &quot;历&quot; } }; XmlSerializer format = new XmlSerializer(typeof(Picture)); using (var stream = new FileStream(&quot;config.xml&quot;, FileMode.Create, FileAccess.Write, FileShare.None)) { format.Serialize(stream, pic); } using (var stream = File.OpenRead(&quot;config.xml&quot;)) { Picture p1 = (Picture)format.Deserialize(stream); } Console.ReadKey(); } [Serializable, XmlType(TypeName = &quot;SinglePicture&quot;)] public class Picture { public int Id { get; set; } public string Url { get; set; } [XmlEnum] public List&lt;string&gt; Details; [XmlAttribute] public string Date { get; set; } } 生成的XML部分如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;SinglePicture xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; Date=&quot;2017/4/15&quot;&gt; &lt;Details&gt; &lt;string&gt;遍&lt;/string&gt; &lt;string&gt;历&lt;/string&gt; &lt;/Details&gt; &lt;Id&gt;1&lt;/Id&gt; &lt;Url&gt;2.jpg&lt;/Url&gt; &lt;/SinglePicture&gt; 使用特性定制序列化[Serializable] public class Picture { public int Id { get; set; } public string Url { get; set; } public string Name { get; set; } [OnSerializing] private void OnSerializing(StreamingContext context) { Name += &quot; Date:&quot; + DateTime.Now.ToShortDateString(); } [OnDeserialized] private void OnDeserialized(StreamingContext context) { Url = Url.ToLower(); Name = Name.ToUpper(); } }]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#高级编程_注释笔记]]></title>
    <url>%2F2017%2F04%2F04%2FC-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Type类型var i = 2.0; var t1 = i.GetType(); var t2 = i.GetTypeCode(); Console.WriteLine(&quot;类型：&quot; + t1 + &quot;，类型码：&quot; + t2 + &quot;，类型码的值：&quot; + (int)t2); 输出：类型：System.Double，类型码(enum)：Double，类型码的值：14 var t = typeof(Person); Console.WriteLine(t.Assembly); Console.WriteLine(t.Attributes); Console.WriteLine(t.BaseType); Console.WriteLine(t.FullName); Console.WriteLine(t.GetProperties()[0].Name); Console.WriteLine(t.GUID); Console.WriteLine(t.Name); Console.WriteLine(t.Namespace); Person p1 = new Person(); if (p1.GetType()==t) Console.WriteLine(&quot;Ok&quot;); Type的成员方法GetConstructor[s]() //返回ConstructorInfo GetEvent[s]() //返回EventInfo GetField[s]() //返回FieldInfo Get[Default]Member[s]() //返回MemberInfo GetMethod[s]() //返回MethodInfo GetProperty[s]() //返回PropertyInfo Assembly和TypeAssembly ass = Assembly.Load(&quot;ConsoleApplication1&quot;); Type t = typeof(Book); var b = ass.CreateInstance(t.FullName); var b1 = ass.CreateInstance(&quot;ConsoleApplication1.Book&quot;); 程序集dll，逻辑单元。包含模块，资源等。程序集强名：共享程序集使用强名唯一地标识该程序集，保证全局唯一，包括： 程序集本身的名称 版本号。不同版本可以共存于一个进程。 公钥。保证独一无二。 文化 应用程序域图解 不同域加载程序集namespace AssemblyA { // [Serializable]//只序列化，则仍由调用应用域访问 public class Demo : MarshalByRefObject //继承这个基类（已序列化），才能通过另一个应用程序域来访问。 { public Demo() { } public Demo(int val1, int val2) { Console.WriteLine(&quot;domain：{0}中带有参数{1}和{2}的构造函数被调用&quot;, AppDomain.CurrentDomain.FriendlyName, val1, val2); } public void DoSome() { Console.WriteLine(&quot;domain：{0}调用方法DoSome&quot;, AppDomain.CurrentDomain.FriendlyName); } } class Program { static void Main(string[] args) { Console.WriteLine(&quot;domain：{0}的主函数被调用&quot;, AppDomain.CurrentDomain.FriendlyName); } } } namespace AssemblyB { class Program { static void Main(string[] args) { Console.WriteLine(&quot;当前域：&quot; + AppDomain.CurrentDomain.FriendlyName); AppDomain firstDomain = AppDomain.CreateDomain(&quot;First AppDomain&quot;); firstDomain.ExecuteAssemblyByName(&quot;AssemblyA&quot;); //需要添加引用或复制程序集，执行exe形式的程序集 firstDomain.ExecuteAssembly(&quot;AssemblyA.exe&quot;); //上方主函数被调用 AppDomain secondDomain = AppDomain.CreateDomain(&quot;Second AppDomain&quot;); var ret = secondDomain.CreateInstance(&quot;AssemblyA&quot;, &quot;AssemblyA.Demo&quot;, true, BindingFlags.CreateInstance, null, new object[] { 7, 3 }, null, null); //上方Demo类构造函数被调用 var obj = (Demo)ret.Unwrap(); //解除包装 obj.DoSome(); //实例化程序集中的类的示例 Demo demo = (Demo)secondDomain.CreateInstanceAndUnwrap(&quot;AssemblyA&quot;, &quot;AssemblyA.Demo&quot;); demo.DoSome(); //显示：Second AppDomain调用方法DoSome //适用：如果程序集是动态加载的，用完后卸载。 //主应用程序域中，无法删除已加载程序集。但可以终止应用程序域，该域中加载的程序集会从内存中清楚。 AppDomain.Unload(secondDomain); //string fullName = namespaceName + &quot;.&quot; + Controller + &quot;Controller&quot;; //object obj = Assembly.Load(assemblyName).CreateInstance(fullName); //result = (ServerController)obj; Console.ReadKey(); } } } 当前域加载程序集//动态加载程序集，创建实例 //配合接口降低耦合，也可以逆向引用调用对象方法 string fullName = &quot;AssemblyA.Demo&quot;; object obj = Assembly.Load(&quot;AssemblyA&quot;).CreateInstance(fullName); var result = (Demo)obj; result.DoSome(); 方法和函数函数&gt;方法。函数包括：方法，非数据成员：索引器，构造函数，析构函数，属性。 构造函数初始化器public Car(string des) : this(des , 4) { //... } public Car(string des,int wheel) { //... } 实现构造函数之间的重用: this 或: base 之后的构造函数先执行，然后再执行此构造函数。 partial关键词编译时，两个不分类的属性，XML注释，接口，泛型类型的参数属性，特性和成员会合并。 泛型中的default关键字初始化泛型参数T时，可以使用detault(T)。在不知道T是引用类型还是值类型的情况下，分别赋予引用类型null或者值类型0 委托类似于C++中的函数指针（但类型不安全，参数和返回值未知）面向对象编程，没有方法是孤立的。如果要传递方法， 就要把方法细节（签名和返回类型）封装在一种新类型对象中，即委托。委托是一种特殊对象，普通对象都包含数据，而委托包含的只是一个或多个方法的地址（指针）。 委托的定义和使用：（面向对象的角度） 定义一个委托（类似定义一个类）private delegate string GetAString(); 实例化一个GetAString的委托实例（实例化一个对象）。委托语法上总是接收一个参数的构造函数。GetAString me=new GetAString(x.ToString);或者委托推断：GetAString me=x.ToString; me();或者me.Invoke();编译器会用me.Invoke()；代替me()； 浅表复制，深度复制浅表复制，成员对象，直接复制引用。成员值，创建值副本。深度复制，成员对象，创建副本。成员值，创建值副本。[Serializable] //可被序列化，实现深度复制 public class CloneDemo // : ICloneable，可继承接口，实现方法复制 { public int State { get; set; } public StateObject innerObj { get; set; } [Serializable] public class StateObject { public int InnerState { get; set; } } public CloneDemo() { State = 1; innerObj = new StateObject { InnerState = 1, }; } //浅表复制 public CloneDemo ShadowClone() { return this.MemberwiseClone() as CloneDemo; } //深度复制 public CloneDemo DeepClone() { using (var stream = new MemoryStream()) { var formatter = new BinaryFormatter(); formatter.Serialize(stream, this); stream.Seek(0, SeekOrigin.Begin); return formatter.Deserialize(stream) as CloneDemo; } } } class Program { static void Main(string[] args) { var demo = new CloneDemo(); var shadow = demo.ShadowClone(); var deep = demo.DeepClone(); Console.WriteLine(&quot;demo：属性State = {0}，引用innerObj.State = {1}&quot;, demo.State, demo.innerObj.InnerState); Console.WriteLine(&quot;shadow：属性State = {0}，引用innerObj.State = {1}&quot;, shadow.State, shadow.innerObj.InnerState); Console.WriteLine(&quot;deep：属性State = {0}，引用innerObj.State = {1}&quot;, deep.State, deep.innerObj.InnerState); demo.State = -1; demo.innerObj.InnerState = -1; Console.WriteLine(&quot;====================\n分别对属性和引用赋值...\n====================&quot;); Console.WriteLine(&quot;demo：属性State = {0}，引用innerObj.State = {1}&quot;, demo.State, demo.innerObj.InnerState); Console.WriteLine(&quot;shadow：属性State = {0}，引用innerObj.State = {1}&quot;, shadow.State, shadow.innerObj.InnerState); Console.WriteLine(&quot;deep：属性State = {0}，引用innerObj.State = {1}&quot;, deep.State, deep.innerObj.InnerState); Console.ReadKey(); } } Array抽象类Type t=...; Array intArr=Array.CreateInstance(typeof(t),5); intArr.SetValue(33,2); intArr.GetValue(2); 事先不知类型，可由此创建数组。 Array.Sort(数组,IComparer 比较器); EnumeratorGetEnumerator()方法用IEnumerable接口定义。foreach语句并不真的需要集合实现这个接口。有一个名为GetEnumerator()的方法，返回实现了IEnumerator接口的对象就行了。 IEnumerator接口定义了Reset()方法，以与COM交互操作。 foreach解析为下面的代码段： var enumerator = list.GetEnumerator(); while (enumerator.MoveNext()) { var item = enumerator.Current; if (item != null) { Console.WriteLine(item.Name); } } yield语句包含yield语句的方法或属性也成为迭代块。必须声明为返回IEnumerator或IEnumerable接口。可包含yield return或yeild break，不能有return语句。使用迭代块，编译器会生成一个yield类型，包含一个状态机。记录了迭代的当前位置。foreach访问迭代器，一次访问一个。无需一次加载完所有数据。 可以把yeild类型看作内部类Enumerator。 class My { public class Enumerator : IEnumerator&lt;string&gt;, IEnumerator, IDisposable { private int state; public string Current { get; private set; } public void Dispose() {...} public bool MoveNext() {...} public void Reset() {...} object IEnumerator.Current {get{return Current;}} } } 默认迭代是：定义为返回Enumerator的GetEnumerator()方法，是foreach默认采用的方法。自定义命名迭代返回IEnumerable。 集合特性 IEnumerabel：GetEnumerator()，返回一个实现了IEnumerator接口的枚举。可以被foreach。 ICollection：由泛型集合实现。Count属性。CopyTo()方法（把集合复制到数组中）。Add()，Remove()，Clear()方法。 IList：派生自ICollection。定义了索引器，可通过指定位置，Insert()或RemoveAt()。 ISet：派生自ICollection。由集实现。合并，交集，并集。 IDictionary：键值集合。索引器。 ILookup：一个键包含多个值。 IComparer：比较器实现。Compare()对集合中的元素排序。 IEqualityComparer：比较器，数组，元祖实现。该比较器可用于字典中的键。 IProducerConsumerCollection：.NET4.0。支持新的线程安全的集合类。 IReadOnlyCollection，IReadOnlyList，IReadOnlyDictionary：初始化后不能修改的，只能检索。 IImmutableArray，IImmutableList，IImmutableQueue，IImmutableSet，IImmutableDictionary：初始化后不能修改。不可变接口定义了不可变集合的方法和属性。 队列先进先出（FIFO）容器。 Queue ，先进先出（FIFO）。Enqueue()，一端添加元素。Dequeue()，另一端读取和删除元素。Peek()，从头部读取一个元素，但不删除。 栈后进先出（LIFO）容器。 Push()，添加元素。Pop()获取最近添加的元素。Peek()，返回栈顶的元素，但不删除它。 Lookup类一键对多值 List&lt;Book&gt; list = new List&lt;Book&gt; { new Book() { Title = &quot;b1&quot;, Price = 1 }, new Book() { Title = &quot;b2&quot;, Price = 2 }, new Book() { Title = &quot;a2&quot;, Price = 2 } }; var bookLk = list.ToLookup(p =&gt; p.Price); foreach (var item in bookLk[2]) { Console.WriteLine(item.Title); } 集HashSet 不重复无序，SortedSet 不重复有序 aSet.Add() //是否成功添加了元素。 aSet.IsSubsetOf(bSet) //a是否是b的子集（b包含a所有元素） bSet.IsSupersetOf(aSet) //b是否是a的超集（b包含a所有元素） aSet.Overlaps(bSet) //a与b是否共享某元素。（重叠） aSet.UnionWith(bSet) //向a中加入b所有的元素。 aSet.ExceptWith(bSet) //从a中删除b拥有的元素 Immutable不可变集合，需要引用System.Collections.Immutable（.NET4.5） ImmutableList&lt;string&gt;.Add(&quot;&quot;) //每次返回一个新的不变集合，不改变本身。 var build=imList.ToBuild() //构建器。返回一个可变集合。可以进行.Add()，.Remove()等。 build.ToImmutable() //返回一个变动后的不可变集合。 并发集合 IProducerConsumerCollectionTryAdd(),和TryTake()。 ConcurrentQueue免锁定，内部链表。TryTake(),Enqueue(),TryDequeue(),TryPeek() ConcurrentStack链表。Push(),TryPeek(),TryPop(),TryPopRange() ConcurrentBag没有定义添加或提取项的任何顺序，线程映射到内部使用的数组，尝试减少锁定。 ConcurrentDictionary线程安全，非阻塞键值集合。TryGetValue(),TryRemove(),TryUpdate()。没有实现IProducerConsumerCollection。 BlockingCollection阻塞线程。Add(),Take()。 dynamic类型dynamic类型允许编写忽略编译期间的类型检查代码。var对象类型的确定会延迟，确定后不可变。dynamic类型可以改变多次。int-&gt;string-&gt;object async只能用于返回Task或void的方法。不能作为程序的入口点。 Task启动Task的3种方式： 1. Action act = () =&gt; { Console.WriteLine(&quot;任务开始&quot;); Thread.Sleep(2000); }; Task t = new Task(act); t.Start(); 2. Task t = Task.Factory.StartNew(act); 3. Task t = Task.Run(act); //对Factory的封装 //完成通知，回调 t.ContinueWith(task =&gt; { Console.WriteLine(&quot;完成状态&quot;); Console.WriteLine(&quot;IsCanceled={0}\tIsCompleted={1}\tIsFaulted={2}&quot;, task.IsCanceled, task.IsCompleted, task.IsFaulted); }); Task组合器 Task.WhenAll(t1,t2)等待，直到全部任务都完成。 Task.WhenAny(t1,t2)等待，直到其中一个任务完成就会返回。 应用CancellationTokenSource，取消Taskstatic void Main(string[] args) { var cts = new CancellationTokenSource(); Task&lt;int&gt; t = new Task&lt;int&gt;(() =&gt; Add(cts.Token), cts.Token); t.Start(); t.ContinueWith(TaskEnded); Console.ReadKey(); cts.Cancel(); Console.ReadKey(); } static void TaskEnded(Task&lt;int&gt; task) { Console.WriteLine(&quot;完成&quot;); Console.WriteLine(&quot;IsCanceled:{0},IsCompleted:{1},IsFaulted:{2}&quot;, task.IsCanceled, task.IsCompleted, task.IsFaulted); ①Console.WriteLine(&quot;返回值：&quot; + task.Result); ②try { Console.WriteLine(&quot;返回值:&quot; + task.Result); } catch (AggregateException e) { var errs = e.InnerExceptions; //与组合器配合，获取所有任务异常。 e.Handle(err =&gt; err is OperationCanceledException); } } static int Add(CancellationToken token) { Console.WriteLine(&quot;任务开始&quot;); int result = 0; ①while (!token.IsCancellationRequested) { result++; Thread.Sleep(1000); } ②③while (true) { result++; Thread.Sleep(1000); ②token.ThrowIfCancellationRequested(); ③if (result == 5) { throw new Exception(&quot;error&quot;); } } return result; } PS：Task t=… ，有返回参数才有①t.Result属性。任务完成则,IsCompleted:true。不论是否异常。①进行逻辑判断，任务正常结束后，进入TaskEnded，结果：IsCanceled:false,IsFaulted:false②通过抛AggregateException异常，立即结束任务，进入TaskEnded，结果：IsCanceled:true,IsFaulted:false③通过抛自定义异常，立即结束任务，进入TaskEnded，结果：IsCanceled:false,IsFaulted:true 虚拟寻址系统32位处理器上的每个进程都可以使用4GB的内存，无论计算机实际有多少物理内存。（64位更大）。包含了：可执行代码，dll，变量等 栈（stack）栈指针指向为栈保留的内存块末尾。栈实际上是向下填充的。即从高内存地址向低内存地址填充。数据入栈后，指针调整，始终指向下一空闲存储单元。数据释放（变量超出作用域），指针向上递增。变量的生存期总是嵌套的，保证了栈指针是有序的。 堆（heap）堆上的内存是向上分配的。空闲空间在已用空间的上面。 垃圾回收gc运行时，会从堆中删除不再引用的所有对象。只要释放了能释放的所有对象，它就把其他对象移动回堆的端部。再次形成一个连续的内存块。因此，堆可以确定在什么地方存储新对象。对象移动后，需要新地址更新引用，gc会处理更新问题。 大对象堆不同于主堆，存储使用大于85000个字节对象。压缩大对象比较昂贵。故大对象对上的对象不执行压缩过程。 第二代和大对象堆上的回收放在后台线程执行，应用程序仅为第0代和第1代回收而阻塞，减少了暂停时间。 非托管资源文件句柄，网络连接，数据库连接等。 托管资源栈，堆上的数据。 析构函数C#不常使用，无法确定执行时机。有析构函数的对象需要两次处理才能销毁。析构函数运行时间长，非常耗性能。 IDisposable接口C#推荐IDisposable接口替代析构函数。声明Dispose()，释放非托管资源。控制更精准。如果显式调用需要try,catch,防止异常而没有执行。代替用using()语句，更简单。 unsafe代码块unsafe可以修饰 类成员方法等。标记为不安全代码，可以使用指针语法提高性能。但带来不安全性和不方便等。 指针语法int x=10; int* pX,pY; pX= &amp;x; pY=px; *pY=20; 结果：x内容改为20。pY与x中间没有任何关系，pY碰巧指向存储x的存储单元。//pX，pY也占用4个字节，因为32位处理器上，4个字节存储一个地址。&amp;表示取地址，把一个值类型转换为指针。*表示获取地址的内容，把一个指针转换为值类型。 强制转换： uint y=(uint)pX; int pD=(int)y; 自定义特性[FieldName(&quot;xxx&quot;)] //FieldNameAttribute，Attribute可以省略，自动添加。搜索指定名称的类，实例化。 [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, //引用在哪些元素上，或的关系 AllowMultiple=false, //是否可以多次应用在同一元素 Inherited=false)] //自动应用到派生类或接口，重写的方法等 public class FieldNameAttribute: Attribute { public string Comment {get;set;} private string name; public FieldNameAttribute(string name) { this.name=name; } } 使用： [FieldName(&quot;xxx&quot;,Comment=&quot;xxx&quot;)] public string Func { ... } Exception 属性Data，可以添加的额外信息字典。HelpLink，连接帮助文件上。InnerException，如异常在catch中抛出，则inner为把代码发送到catch块的异常对象。Source，导致异常程序或对象名。StackTrace，调用栈信息。TargetSite，抛出异常的方法的反射对象。 .ReflectedType获得类的Type对象。 调用者特性public class Book { public string Title { get; set; } public decimal Price { get; set; } public void Log([CallerLineNumber] int line = 0, [CallerFilePath] string path = &quot;&quot;, [CallerMemberName] string name = &quot;&quot;) { //Do with line,path,name... 包括调用者的信息 } } Book b = new Book(); b.Log(); ThreadPoolBook b = new Book() { Title = &quot;t&quot;, Price = 1 }; ThreadPool.QueueUserWorkItem(i =&gt; { Book b1 = i as Book; Console.WriteLine(&quot;书名&quot; + b1.Title + &quot;价格&quot; + b1.Price); }, b); 线程池的限制 线程池中的所有线程都是后台线程。并且不能把入池的线程改为前台线程。 不能设置池中线程的优先级或名称。 所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）线程。 入池的线程只能用于时间短的任务。如果需要一直运行（如word拼写检查），应创建Thread或Task使用LongRunning选项。 控制线程var t1 = new Thread(() =&gt; { }); t1.Priority = ThreadPriority.Highest; //优先级，优先调用。可能影响其他线程 t1.Abort(); //停止线程，抛出异常 t1.Join(2000); //阻塞 Interlocked类速度快，简单的同步问题。原子操作。 Interlocked.CompareExchange(); Interlocked.Increment(); Monitor类lock语句会被编译器解析成以下代码： object obj = new object(); Monitor.Enter(obj); try { //线程同步区域 } finally { Monitor.Exit(obj); } Monitor的好处是可以指定等待时间： bool lockToken = false; Monitor.TryEnter(obj, 500, ref lockToken); if (lockToken) { try { //线程同步区域 } finally { Monitor.Exit(obj); } } else { //做其他的事情 } 读写互斥锁class Program { private static List&lt;int&gt; items = new List&lt;int&gt;() { 0, 1, 2, 3, 4, 5, 6 }; private static ReaderWriterLockSlim rwl = new ReaderWriterLockSlim(); static void ReaderMethod(object reader) { try { rwl.EnterReadLock(); //如果该锁是读取模式，则读取线程直接进入。累计数+1 for (int i = 0; i &lt; items.Count; i++) { Console.WriteLine(&quot;reader {0},loop {1},item {2}&quot;, reader, i, items[i]); } } finally { rwl.ExitReadLock(); //读取线程退出，累计数-1。为0时退出读取模式 } } static void WriterMethod(object writer) { try { //Thread.Sleep(100); //如果写入线程等待，则全部读取的线程会先执行完。否则就抢 while (!rwl.TryEnterWriteLock(50)) //如果取得写入锁，则进入独占写入模式。 { Console.WriteLine(&quot;writer {0} 等待取写入锁&quot;, writer); Console.WriteLine(&quot;当前读者个数&quot; + rwl.CurrentReadCount); } Console.WriteLine(&quot;writer {0} 取得写锁&quot;, writer); for (int i = 0; i &lt; items.Count; i++) { items[i]++; Thread.Sleep(50); } Console.WriteLine(&quot;writer {0} 写入完毕&quot;, writer); } finally { rwl.ExitWriteLock(); //退出独占写入模式，读写线程开始抢锁 } } static void Main(string[] args) { var taskFac = new TaskFactory(TaskCreationOptions.LongRunning, TaskContinuationOptions.None); for (int i = 0; i &lt; 6; i++) { if (i==1 || i==4) { taskFac.StartNew(WriterMethod, i); } else { taskFac.StartNew(ReaderMethod, i); } } Console.ReadKey(); } }]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First设计模式_注释笔记]]></title>
    <url>%2F2017%2F02%2F27%2FHead-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[设计原则 把可能变化之处独立出来，以免影响固定代码。 针对接口编程，而不是针对实现编程 多用组合，少用继承 设计交互对象之间的松耦合 扩展-关闭原则：类应该对扩展开发，对修改关闭。 依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 好莱坞原则：高层组件对待低层组件的方式：别调用我们，我们会调用你。避免高层和低层出现明显的环装依赖 一个类应该只有一个引起变化的原因。高内聚，低耦合。（单一职责） 备注7： //采用 public int GetCount() { return target.GetCount(); //只认识target } //不采用 public int GetCount() { var obj=target.GetObj(); //多认识（依赖）了一个对象 return obj.GetCount(); } PS：如果某对象是调用其他方法的返回结果，不要调用它的方法。意味着，不清楚他的方法细节。并不认识此对象，也就不依赖它。 针对接口（超类型）编程针对实现： Dog d=new Dog(); d.bark(); 针对接口： Animal a=new Dog(); a.makeSound(); 运行时 Animal a=getAnimal(); a.makeSound(); 策略模式定义定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。 类图 观察者模式定义定义了对象间的一对多依赖（订阅），这样依赖，当一个对象改变时，它的所有依赖者都会受到通知并更新。Subject主题，Observer观察者。 类图 代码示例PS：另可以用多播委托实现此过程。 public class DeleteAction : IDisposable { private readonly Action _onDispose; public DeleteAction(Action onDispose) { _onDispose = onDispose; } public void Dispose() { _onDispose(); } } public class Msg { public string Name { get; set; } } public class Report : IObservable&lt;Msg&gt; { private List&lt;IObserver&lt;Msg&gt;&gt; os = new List&lt;IObserver&lt;Msg&gt;&gt;(); public void Notify(string msg) {os.ForEach(o =&gt; { o.OnNext(new Msg { Name = msg }); o.OnCompleted(); });} public IDisposable Subscribe(IObserver&lt;Msg&gt; observer) { os.Add(observer); return new DeleteAction(() =&gt; { os.Remove(observer); }); } public void Err() {os.ForEach(o =&gt; { o.OnError(new Exception(&quot;自定义错误！&quot;)); });} } public class Screen : IObserver&lt;Msg&gt; { public int Id { get; set; } public Screen(int id) { Id = id; } public void OnNext(Msg value) {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，信息为：&quot; + value.Name);} public void OnError(Exception error) {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，错误！信息：&quot; + error.Message);} public void OnCompleted() {Console.WriteLine(&quot;接收Id：&quot; + Id + &quot;，完成！&quot;);} } class Program { static void Main(string[] args) { Report re = new Report(); Screen s1 = new Screen(1); Screen s2 = new Screen(2); var o1 = re.Subscribe(s1); var o2 = re.Subscribe(s2); re.Notify(&quot;哎呀&quot;); o1.Dispose(); re.Notify(&quot;少人&quot;); } } 装饰者模式定义动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 类图 代码示例public abstract class Phone { public abstract void Ring(); public abstract decimal GetPrice(); } public class Apple : Phone //被装饰者 { public override void Ring() { Console.WriteLine(&quot;这是苹果手机...&quot;); } public override decimal GetPrice() { return 4500; } } public abstract class Decorator : Phone //装饰者 { protected Phone p; //被装饰者引用 protected Decorator(Phone p) { this.p = p; } } public class Sticker : Decorator { public Sticker(Phone p) : base(p) { } public override void Ring() { p.Ring(); //被装饰者行为 AddSticker(); //新增行为/责任 } public override decimal GetPrice() {return p.GetPrice() + 1.5m;} public void AddSticker() {Console.WriteLine(&quot;加了贴膜！&quot;);} } static void Main(string[] args) { Phone m = new Apple(); m = new Sticker(m); m = new Sticker(m); //贴了2层 m = new Accessories(m); m.Ring(); Console.WriteLine(&quot;当前价格为：&quot; + m.GetPrice()); Console.ReadKey(); } 角色抽象构件（Phone）角色：给出一个抽象接口，以规范准备接受附加责任的对象。具体构件（AppPhone）角色：定义一个将要接收附加责任的类。装饰（Dicorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。具体装饰（Sticker和Accessories）角色：负责给构件对象 ”贴上“附加的责任。 理解优点：装饰者模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合装饰者模式有很好地可扩展性缺点：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。 适配器模式定义将一个类的接口，转换成客户（使用者）期望的另一个接口。适配器让原本不兼容的类可以合作无间。 类图 代码示例public interface IDuck { void Quack(); } public interface ITurkey { void SpecialQuack(); } public class Duck : IDuck //鸭子类 { public void Quack() { Console.WriteLine(&quot;鸭子叫！&quot;); } } public class Turkey : ITurkey //火鸡类 { public void SpecialQuack() { Console.WriteLine(&quot;火鸡叫！&quot;); } } public class Adapter : IDuck //适配器，把火鸡转换成鸭子 { private ITurkey t; //持有（包装）的火鸡引用 public Adapter(ITurkey t) { this.t = t; } public void Quack() { t.SpecialQuack(); } } class Program { static void Main(string[] args) { Adapter duckAdapter = new Adapter(new Turkey()); //使用适配器切换了接口 ShootDuck(duckAdapter); //原调用代码，不用更改。 Console.ReadKey(); } static void ShootDuck(IDuck d) { d.Quack(); } //原调用代码，不用更改。 } 理解系统A，原本某一块功能（如客户出入金）需要从一个提供商甲切换到提供商乙，不改变系统代码的情况下。可以创建适配器，封装乙的接口实现切换动作，让系统仍然像使用甲的接口那样，正常运作。过程不需修改代码，只需扩展适配器。处理遗留问题。 装饰者和适配器的异同适用条件的差别：装饰模式一般在下列情况使用：需要扩展一个类的功能或者给你个类增加附加责任；需要动态的给一个对象增加功能，这些功能可以再动态的撤销；需要增加有一些基本功能的排列组合而产生非常大量的功能，从而使得继承关系变得不现实。适配器模式一般使用的情况包括：系统需要使用现有的类，但此类已经不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的的类一起工作。适配器模式在系统升级的时候使用的频率很高，对旧系统的一些功能方法在新系统中引用。 单例模式定义确保一个类只有一个实例，并提供一个全局访问点。 代码示例线程安全 public class Singleton { private Singleton() { } private static Singleton singleton; public static Singleton GetInstance() { if (singleton == null) { lock (typeof(Singleton)) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 命令模式定义将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。 类图 代码示例public class Receiver { public void Action() { Console.WriteLine(&quot;Called Receiver.Action()&quot;); } } public abstract class Command { protected Receiver receiver; public Command(Receiver receiver) { this.receiver = receiver; } public abstract void Execute(); } public class ConcreteCommand : Command { public ConcreteCommand(Receiver receiver): base(receiver){} public override void Execute() { receiver.Action(); } } public class Invoker { private Command _command; public void SetCommand(Command command) { this._command = command; } public void ExecuteCommand() { _command.Execute(); } } static void Main(string[] args) { Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(); invoker.SetCommand(command); invoker.ExecuteCommand(); } 理解将请求者和执行者（接受者）解耦。如果执行者种类繁多，且不属于同一个体系，也没有统一执行接口。请求者请求命令，需要知道所有执行者的外露接口，耦合很高。命令模式，加入中间层：调用者，让请求者只认识调用者，向调用者发出指定执行者且接口固定的命令对象，调用者只执行指定命令对象的固定接口，命令对象包含执行者的引用和一组方法，知道如何完成操作。这种封装命令对象的模式，为命令模式。如待完成列表，可以在任何时间被执行。 外观模式定义提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易适用。 类图 代理模式定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。 类图 代理分类 远程代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。这样可以隐藏一个对象在不同地址空间的事实。例如：WebService，WCF 虚拟代理: 根据需要创建一个资源消耗较大的对象，通过它来存放实例化需要长时间的真实对象，使得此对象只在需要时才会被真正创建。 保护代理：用来控制真实对象的访问时的权限。如果需要，可以给不同的用户提供不同级别的使用权限。 智能代理：指当调用真实对象时，代理处理另外一些事。提供一些额外的操作，比如将对此对象调用的次数记录下来等。 同步（Synchronization）代理：多线程情况下，为主题提供安全的访问。 复杂隐藏（Complexity Hiding）代理：隐藏一个类的复杂集合的复杂度，有时候称为外观代理（Facade Proxy）。此代理控制访问，外观模式只提供另一组接口。 写入时复制（Copy-on-Write）代理：虚拟代理的变种。把复制（克隆）延迟到只有在客户端需要时，才真正采取行动。 缓存（Cache）代理：为开销大的运算结果提供临时的存储空间，以便多个客户端可以共享这些结果，以减少计算或网络延迟。 防火墙（Firewall）代理：控制网络资源的访问，不让恶意用户接近。 装饰者，外观，代理，适配器四种模式的比较 工厂方法模式定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 类图 抽象工厂模式定义提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指明具体类。 类图 模板方法模式定义在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 类图 代码示例public abstract class Beverage { public void Prepare() { BoilWater(); Brew(); PourInCup(); //钩子，可由子类视情况（是否覆盖），反控制基类中的算法（顺序或步骤） if (IsCondiments()) { AddCondiments(); } } protected abstract void AddCondiments(); //由子类实现部分算法 protected abstract void Brew(); //可有子类控制，推迟到子类中实现 protected virtual bool IsCondiments() { return false; } //钩子 private void PourInCup() { Console.WriteLine(&quot;倒入杯子&quot;); } //基类默认实现部分 private void BoilWater() { Console.WriteLine(&quot;烧水&quot;); } //同上 } public class Coffee : Beverage { protected override bool IsCondiments() { return GetResult(); } //根据结果是否覆盖使用此钩子 protected override void AddCondiments() { Console.WriteLine(&quot;加糖，加奶&quot;); } protected override void Brew() { Console.WriteLine(&quot;磨碎咖啡豆，泡咖啡粉...&quot;); } } static void Main(string[] args) { Beverage co = new Coffee(); co.Prepare(); } 模板方法模式的变种不使用继承，而使用组合。java中Arrays.sort(object[] arr)中的算法，进行两个对象之间的比较。 ... Comparable obj... //接口 obj.compareTo(obj2)... ... 算法待实现部分，不再交由子类负责实现（数组不可继承）。而是传入一个实现了Comparable接口的元素组成的数组，由此数组的元素负责。 模板方法模式和工厂方法模式，区别模板方法，指的是实现算法的方法，包含基类实现部分和待子类实现部分（抽象方法）。工厂方法，指的是可由子类继承实现的抽象方法，不同子类决定不同的功能。会由基类调用。 迭代器模式定义提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 类图 代码示例public class Item { public string Name { get; set; } public double Price { get; set; } public override string ToString() { return &quot;名称：&quot; + Name + &quot;，价格：&quot; + rice; } } public class MenuManager : IEnumerable //可被foreach迭代 { private Item[] items; private int Index { get; set; } public MenuManager() { items = new Item[10]; AddItem(&quot;煎饼&quot;, 2); AddItem(&quot;拉面&quot;, 7); AddItem(&quot;快餐&quot;, 10); } public IEnumerator GetEnumerator() { return new MenuEnumrator(items); } //继承实现，返回一个迭代器供foreach使用 public void AddItem(string name, double price) { Item i = new Item { Name = name, Price = price }; items[Index] = i; Index++; } public void ChgItem(string name, double price, int destIndex) { Item i = new Item { Name = name, Price = price }; items[destIndex] = i; } } public class MenuEnumrator : IEnumerator //迭代器接口 { private List&lt;Item&gt; list; private int index; public MenuEnumrator(IEnumerable&lt;Item&gt; arr) { list = arr.ToList(); index = -1; } public bool MoveNext() //继承实现，先后移动 { index++; bool result = list.Count &gt; index &amp;&amp; list[index].Price &lt; 3; //自定义条件 if (result) Current = list[index]; return result; } public void Reset() { index = -1; } //继承实现，重置索引 public object Current { get; private set; } //继承实现，当前项 } class Program { static void Main(string[] args) { MenuManager dm = new MenuManager(); dm.AddItem(&quot;汽水&quot;, 1); foreach (Item item in dm) { Console.WriteLine(item); } dm.ChgItem(&quot;干拌面&quot;, 9, 1); } } 组合模式定义允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 安全式和透明式组合模式：透明式：以单一责任设计原则换取透明性。减少客户代码，失去了一些安全性。可能会抛出异常。安全式：将责任区分开放在不同的接口中，符合单一责任原则。比较安全，但失去了透明性。客户代码必须判断类型，处理不同类型的节点。 类图 透明式的组合模式public class Graphics { protected string Name { get; set; } protected Graphics(string name) { this.Name = name; } public virtual void Draw() { throw new NotSupportedException(); } //默认抛出异常，避免叶对象或不合理的操作。 //简单图形（叶对象）Add或Remove方法没有任何意义 //如果客户端调用了将会抛出异常 public virtual void Add(Graphics g) { throw new NotSupportedException(); } public virtual void Remove(Graphics g) { throw new NotSupportedException(); } } public class Line : Graphics { public Line(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class Circle : Graphics { public Circle(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class ComplexGraphics : Graphics { public ComplexGraphics(string name) : base(name) { } private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() { foreach (var item in list) item.Draw(); } public override void Add(Graphics g) { list.Add(g); } public override void Remove(Graphics g) { list.Remove(g); } } class Program { static void Main(string[] args) { Graphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;); complexGraphics.Add(new Line(&quot;线段A&quot;)); Graphics l = new Line(&quot;线段B&quot;); complexGraphics.Add(l); Graphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;); CompositeCG.Add(new Circle(&quot;圆&quot;)); CompositeCG.Add(new Circle(&quot;线段C&quot;)); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine(&quot;复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成\n&quot;); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); } } 安全式的组合模式public abstract class Graphics { protected string Name { get; set; } protected Graphics(string name) { this.Name = name; } public abstract void Draw(); // 移除了Add和Remove方法 // 把管理子对象的方法放到了ComplexGraphics类中进行管理 // 因为这些方法只在复杂图形中才有意义，且符合单一责任原则。 } public class Line : Graphics { public Line(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class Circle : Graphics { public Circle(string name) : base(name) { } public override void Draw() { Console.WriteLine(&quot;画 &quot; + Name); } } public class ComplexGraphics : Graphics { public ComplexGraphics(string name) : base(name) { } private List&lt;Graphics&gt; list = new List&lt;Graphics&gt;(); public override void Draw() { foreach (var item in list) item.Draw(); } public void Add(Graphics g) { list.Add(g); } public void Remove(Graphics g) { list.Remove(g); } } class Program { static void Main(string[] args) { ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;); complexGraphics.Add(new Line(&quot;线段A&quot;)); Line l = new Line(&quot;线段B&quot;); complexGraphics.Add(l); ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;); CompositeCG.Add(new Circle(&quot;圆&quot;)); CompositeCG.Add(new Circle(&quot;线段C&quot;)); complexGraphics.Add(CompositeCG); // 显示复杂图形的画法 Console.WriteLine(&quot;复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); // 移除一个组件再显示复杂图形的画法 complexGraphics.Remove(l); Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;); complexGraphics.Draw(); Console.WriteLine(&quot;复杂图形绘制完成&quot;); } } 状态模式定义允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 类图 代码示例Machine： public class Machine { internal State SoldOutState { get; set; } //内部包装的状态 internal State NoCoinState { get; set; } internal State HasCoinState { get; set; } internal State SoldingState { get; set; } public int Count { get; internal set; } //对外暴露的显示 public int CoinCount { get; internal set; } internal State State { get; set; } public Machine(int count) { SoldOutState = new SoldOutState(this); NoCoinState = new NoCoinState(this); HasCoinState = new HasCoinState(this); SoldingState = new SoldingState(this); Count = count; CoinCount = 0; State = count &gt; 0 ? NoCoinState : SoldOutState; } public void Insert() { State.Insert(); } public void Eject() { State.Eject(); } public void Turn() //对外暴露的接口（按钮） { State.Turn(); //内部执行的动作，由状态类负责 if (CoinCount &gt; 0) State.Give(); } internal void SetState(State state) { State = state; } public void FillBall(int count) { Console.WriteLine(&quot;上货&quot; + count + &quot;个&quot;); Count += count; } internal void ReleaseBall() { Console.WriteLine(&quot;发放商品&quot;); if (Count != 0) Count--; } public override string ToString() { return &quot;\n============================\n自动售货机\n货物个数：&quot; + Count + &quot;\t当前状态：&quot; + State + &quot;\n============================\n&quot;; } } 状态类： internal abstract class State { public abstract void Insert(); public abstract void Eject(); public abstract void Turn(); public abstract void Give(); protected virtual void Error() { Console.WriteLine(&quot;错误操作&quot;); } } internal class NoCoinState : State { private Machine Mac { get; set; } public NoCoinState(Machine mac) { Mac = mac; } public override void Insert() { Console.WriteLine(&quot;投入硬币&quot;); Mac.CoinCount++; Mac.SetState(Mac.HasCoinState); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Error(); } public override string ToString() { return &quot;等待投入硬币...&quot;; } } internal class HasCoinState : State { private Machine Mac { get; set; } public HasCoinState(Machine mac){Mac = mac;} public override void Insert(){Error();} public override void Eject() { Console.WriteLine(&quot;硬币归还&quot;); Mac.CoinCount--; Mac.SetState(Mac.NoCoinState); } public override void Turn() { Console.WriteLine(&quot;转动&quot;); Mac.SetState(Mac.SoldingState); } public override void Give(){Error();} public override string ToString(){return &quot;有硬币，可以转动...&quot;;} } internal class SoldingState : State { private Machine Mac { get; set; } public SoldingState(Machine mac) { Mac = mac; } public override void Insert() { Error(); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Mac.ReleaseBall(); if (Mac.Count &gt; 0) Mac.SetState(Mac.NoCoinState); else { Console.WriteLine(&quot;已售罄&quot;); Mac.SetState(Mac.SoldOutState); } } public override string ToString() { return &quot;正在出货...&quot;; } } internal class SoldOutState : State { private Machine Mac { get; set; } public SoldOutState(Machine mac) { Mac = mac; } public override void Insert() { Error(); } public override void Eject() { Error(); } public override void Turn() { Error(); } public override void Give() { Error(); } public override string ToString() { return &quot;已售罄...&quot;; } } 测试代码： class Program { static void Main(string[] args) { Machine mac = new Machine(5); Console.WriteLine(mac); mac.Eject(); mac.Turn(); mac.FillBall(1); mac.Insert(); Console.WriteLine(mac); mac.Eject(); mac.Insert(); mac.Insert(); mac.Turn(); mac.Turn(); Console.ReadKey(); } } 模式配对 模式分类]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#入门经典_注释笔记]]></title>
    <url>%2F2017%2F02%2F26%2Fc-%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E6%B3%A8%E9%87%8A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[checked关键字：//检查赋值是否数据溢出//或者配置，项目-属性-生成-高级，检查上溢下溢 checked//unchecked 不检查 { destination = (int)source; } 委托：2种写法： 1，Calcul cal=new Calcul(Add); 2, Calcul cal=Add; 或 1,Calcul cal; cal=new Calcul(Add); 2,Calcul cal; cal=Add; ps:情况2自动初始化一个委托 二维数组：int[,] ints = new int[10,4]; ints[2, 2] = 1; ref out关键字ref out 等也可以改变函数的签名(命名+参数），从而实现重载 断点：可以设置中断条件和击中次数。如，a&gt;=100，次数=100 析构函数：class MyClass{ ~MyClass(){ } } ~ 析构函数，垃圾回收器回收时自动调用还将隐式调用基类的析构函数 隐藏基类方法，在子类中定义时加new public void Do(){ ... } 类型比较：myObj.GetType()==typeof(MyObjClass) 对对象类型的比较 myObj is objBasemyObj是objBase的子类，实现类，同类都为true 重载运算符： 例如：+需要再进行+运算的类内部定义ps:1，不能重载+=，-=。但如果重载它们对应的简单运算符，如+，则+=仍能像预期那样执行。2，不能重载=，因为它有基本用途3，不能重载&amp;&amp;和||，但同1理，重载&amp;和|就够了4，&lt;和&gt;，&lt;=和&gt;=必须成对重载 class Person { public int Age { get; set; } public decimal Price { get; set; } public string Name { get; set; } public static Person operator +(Person p1, Person p2) { return new Person { Age = p1.Age + p2.Age }; } public static bool operator &gt;(Person left, Person right) { return left.Age &gt; right.Age; } public static bool operator &lt;(Person left, Person right) { return left.Price &lt; right.Price; } } IComparable接口：定义在要比较的对象的类中实现，类要实现IComparable接口 public int CompareTo(object obj) { var person = obj as Person; if (person == null) throw new ArgumentException(&quot;参数错误&quot;); return Age - person.Age; } 重写隐式(implicit)，显式(explicit)转换：class Person1 { public int Age { get; set; } public static implicit operator Person2(Person1 p1) { Person2 p = new Person2 { Age = p1.Age }; return p; } } class Person2 { public double Age { get; set; } public static explicit operator Person1(Person2 p2) { Person1 p1 = new Person1(); checked { p1.Age = (int)p2.Age; } return p1; } } ps：同样可作用于泛型集合 父子类相互转换： 1会报错，2不会报错。不能把父类实例转换成子类实例，只能把父类变量类型转换成子类变量类型 1 Person p = new Person(); Man m = (Man)p; 2 Person p1 = new Man(); Man m1 = (Man) p1; 如果强转换成as 则都不会报错，1为null，2不为null ??运算符：int? val1 = null; int result = val1*5 ?? 10; int? result2=val1*5 ?? 10; ??等式的结果可以是int或int?，等式会自动进行转换 default关键字：如果T是引用类型，则输出null如果T是值类型，则输出默认值e.g. int -&gt; 0 Class MyClass&lt;T&gt;{ public MyClass(){ Console.WriteLine(default(T)); } } 约束类型class MyClass&lt;T1, T2&gt; : MyClassBase where T1 : class,new () where T2 : T1 { } ps:1，约束类型：struct值类型，class引用类型，base-class任意基类，interface接口，new()有一个公共无参构造函数2，多个约束之间用，分隔3，new()作约束必须是指定的最后一个4，约束必须出现在继承说明符的后面 协变和抗变：应用于泛型接口和委托，继承关系默认支持协变1，协变 List&lt;string&gt; liststr = new List&lt;string&gt;(); List&lt;object&gt; listobj = new List&lt;object&gt;(); listobj.AddRange(liststr); //参数为IEnumerable&lt;object&gt; 定义： public class List&lt;T&gt; : IEnumerable&lt;T&gt;... public interface IEnumerable&lt;out T&gt; : IEnumerable ps：1，使用关键字out，则类型参数T只能作为方法的返回值2，泛型类型参数可以从一个派生类隐式转化为基类，让一个带有协变参数的泛型接口（或委托）可以接收类型更加精细化，具体化的泛型接口（或委托）作为参数，可以看成OO中多态的一个延伸。 2，抗变（逆变） class MyComparer : IComparer&lt;object&gt; { public int Compare(object x, object y) { throw new NotImplementedException(); } } IComparer&lt;object&gt; comobj = new MyComparer(); liststr.Sort(comobj); //参数为IComparer&lt;string&gt; 定义： public interface IComparer&lt;in T&gt; ps：1，使用关键字in，则类型参数T只能作为方法的参数2，泛型类型参数可以从一个基类隐式转化为派生类，让一个带有协变参数的泛型接口（或委托）可以接收粒度更粗的泛型接口或委托作为参数，这个过程实际上是参数类型更加精细化的过程。 总结：协变让一个粗粒度接口（或委托）可以接收一个更加具体的接口（或委托）作为参数（或返回值）；逆变让一个接口（或委托）的参数类型（或返回值）类型更加具体化，也就是参数类型更强，更明确。 引发事件时，会依次调用程序列表中每个处理程序，只要它们满足指定的条件即可。委托的应用：delegate int OperationDelegate(int left,int right); void Function(OperationDelegate del) { int left,right; //... del(left,right); } void int OperationEx(int left,int right) { return left+right; } //Main1,用方法创建委托 void Function(new OperationDelegate(OperationEx)); 2,直接传递方法(默认创建委托) void Function(OperationEx); 3,匿名方法 void Function(delegate(int left,int right){ return left+right; }); 4,Lambda表达式 void Function((left,right) =&gt; left+right); //参数类型不用指定，会通过上下文推断出类型 Function((left,right) =&gt; (left-right)*right); //Lambda表达式本质还是委托//用Func来简化一个委托的定义。代替delegate xx…. Lambda表达式的解释：可以用两种方式解释Lambda表达式，第一，Lambda表达式是一个委托，可以把它表示为如下泛型类型：Action - lambda表达式不带参，返回void，Action&lt;&gt; - lambda表达式最多8个参数，返回void，Func&lt;&gt; - lambda表达式最多8个参数，返回不是void//e.g.Func lamb，前面的是参数，最后的bool是返回值 第二，可以把Lambda表达式解释为表达式树。并不能直接执行。LINQ架构的泛型类 Expression&lt;&gt;，可用于封装Lambda表达式，把它转换为相应的SQL脚本，以便在数据库中直接执行 工作目录：//设置当前工作目录，并不是转移文件！ Directory.SetCurrentDirectory(Directory.GetCurrentDirectory()+&quot;\\demo&quot;); //当前工作目录字符串 Directory.GetCurrentDirectory(); FileStream：FileInfo file = new FileInfo(&quot;test.txt&quot;); //创建一个只读的流 FileStream stream = file.OpenRead(); //创建一个只写的流 FileStream stream1 = File.OpenWrite(&quot;test.txt&quot;); //将文件指针移动到文件的第8个字节，起始位置为第1个字节 stream.Seek(8, SeekOrigin.Begin); //将指针从当前位置向前移动2个字节，则指向8+2=10个字节 stream.Seek(2, SeekOrigin.Begin); //查找文件中倒数第5个字节 stream.Seek(-5, SeekOrigin.End); //FileStream 操作字节或字节数组的流 //Stream(StreamReader或StreamWriter)操作的是字符 FileStream读取数据：//读取本身cs文件 byte[] byData = new byte[200]; char[] charData = new char[200]; try { FileStream stream = new FileStream(&quot;../../Program.cs&quot;, FileMode.Open); stream.Seek(110, SeekOrigin.Begin); stream.Read(byData, 2, 190); } catch (Exception e) { Console.WriteLine(&quot;AN IO Exception throw!&quot;); Console.WriteLine(e.ToString()); Console.ReadKey(); throw; } Decoder d = Encoding.UTF8.GetDecoder(); d.GetChars(byData, 0, byData.Length, charData, 0); Console.WriteLine(charData); FileStream写入：byte[] byData; char[] charData; try { FileStream file = new FileStream(&quot;test1.txt&quot;, FileMode.Create); charData = &quot;This is a charData array!&quot;.ToCharArray(); byData = new byte[charData.Length]; Encoder encoder = Encoding.UTF8.GetEncoder(); encoder.GetBytes(charData, 0, charData.Length, byData, 0, true); file.Seek(0, SeekOrigin.Begin); file.Write(byData, 0, byData.Length); } catch (Exception) { //... throw; } StreamReader/Writer的权限：StreamReader/Writer 总是拥有对文件的读写权限，为了使用高级参数如，FileMode,FileAccess，可以在FileStream构造函数指定这些参数，然后通过FileStream创建StreamReader/Writer 读取数据的选择：1，小文件，StreamReader.ReadToEnd();2，大型文件，StreamReader.ReadLine(); 循环判断是否为空 或者 foreach (var item in File.ReadLines(&quot;test.txt&quot;,Encoding.Default)) { Console.WriteLine(item); } File.ReadLines 一次读取一行，迭代读取。返回IEnumerable&lt;string&gt; File.ReadAllLines 打开一个文件，读取文件的所有行，然后关闭文件。返回string[] 压缩和解压缩类 输入读取类：System.IO.Compression; static void SaveCompressedFile(string fileName, string data) { FileStream file = new FileStream(fileName, FileMode.Create, FileAccess.Write); GZipStream zip = new GZipStream(file, CompressionMode.Compress); StreamWriter sw = new StreamWriter(zip,Encoding.Default); sw.Write(data); sw.Close(); } static string LoadCompressedFile(string fileName) { FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read); GZipStream zip = new GZipStream(file, CompressionMode.Decompress); StreamReader sr = new StreamReader(zip, Encoding.Default); string data = sr.ReadToEnd(); sr.Close(); return data; } C#6.0 新特性1，字符串插值（String Interpolation） 之前： var Name = &quot;Jack&quot;; var results = &quot;Hello&quot; + Name; 或者 var results = string.Format(&quot;Hello {0}&quot;, Name); Now： var results = $&quot;Hello {Name}&quot;; 之前： Person p = new Person {FirstName = &quot;Jack&quot;, LastName = &quot;Wang&quot;, Age = 100}; var results = string.Format(&quot;First Name: {0} LastName: {1} Age: { 2} &quot;, p.FirstName, p.LastName, p.Age); Now： var results = $&quot;First Name:{p.FirstName} LastName:{p.LastName} Age：{p.Age}&quot;; PS:还可以插入代码 - 相当于小脚本或Razor 的@{ }，不过只能作用于string Console.WriteLine($&quot;Jack is saying { new Tools().SayHello() }&quot;); 2，空操作符 ( ?. ) 之前： if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) { Console.WriteLine(user.Project.Tasks.First().Name); } Now： Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 还可用于数组索引器 User[] users = null; Console.WriteLine(users?[1].Name); // 正常 Console.WriteLine(users[1]?.Name); // 报错 PS：以下代码并不会报错，也不会有输出。减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常。那么使用这个特性反而隐藏了Bug User user = null; user?.SayHello(); C#6.0 新特性 2：3， NameOf Console.WriteLine(nameof(User.Name)); // output: Name Console.WriteLine(nameof(System.Linq)); // output: Linq Console.WriteLine(nameof(List&lt;User&gt;)); // output: List PS：NameOf只会返回Member的字符串，如果前面有对象或者命名空间，NameOf只会返回 . 的最后一部分, 另外NameOf有很多情况是不支持的，比如方法，关键字，对象的实例以及字符串和表达式 4，表达式方法体一句话的方法体可以直接写成箭头函数，而不再需要大括号 private static string SayHello() =&gt; &quot;Hello World&quot;; private static string JackSayHello() =&gt; $&quot;Jack {SayHello()}&quot;; Console.WriteLine(SayHello()); Console.WriteLine(JackSayHello()); 序列化对象：using System.IO; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Binary; [Serializable] class Product { public long Id; public string Name; public double Price; [NonSerialized] string Notes; public Product(long id, string name, double price, string notes) { Id = id; Name = name; Price = price; Notes = notes; } public override string ToString() { return $&quot;{Id}：{Name} (${Price:F2}) {Notes}&quot;; } } //Main中 List&lt;Product&gt; list = new List&lt;Product&gt;() { new Product(1,&quot;Pung&quot;,1000.0,&quot;Good stuff.&quot;), new Product(2,&quot;Soup&quot;,25.0,&quot;Tasty.&quot;), new Product(4,&quot;Hat Sauce&quot;,12.0,&quot;One for the kids.&quot;) }; Console.WriteLine(&quot;Products to save:&quot;); list.ForEach(p =&gt; Console.WriteLine(p.ToString())); IFormatter serializer = new BinaryFormatter(); FileStream file = new FileStream(&quot;Products.bin&quot;, FileMode.Create, FileAccess.Write); serializer.Serialize(file, list); file.Close(); FileStream fileLoad = new FileStream(&quot;Products.bin&quot;, FileMode.Open, FileAccess.Read); List&lt;Product&gt; list2 = serializer.Deserialize(fileLoad) as List&lt;Product&gt;; fileLoad.Close(); 监控文件：private FileSystemWatcher watcher; public Form1() { watcher = new FileSystemWatcher(); watcher.Deleted += new FileSystemEventHandler(OnDelete); watcher.Renamed += new RenamedEventHandler(OnRenamed); InitializeComponent(); } public void OnRenamed(object source, RenamedEventArgs e) { StreamWriter sw = new StreamWriter(@&quot;F:\Logs\log.txt&quot;, true); sw.WriteLine($&quot;File renamed from {e.OldName} to {e.FullPath}&quot;); sw.Close(); } public void OnDelete(object source, FileSystemEventArgs e) //... private void btnWatch_Click(object sender, EventArgs e) { watcher.Path = Path.GetDirectoryName(txtLocation.Text); watcher.Filter = Path.GetFileName(txtLocation.Text); watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size; watcher.EnableRaisingEvents = true; } XPath查询xml语言：XmlDocument xml = new XmlDocument(); xml.Load(&quot;../../Demo.xml&quot;); XmlElement e = xml.DocumentElement; var node = e.SelectSingleNode(&quot;Book[Title=&apos;韩寒&apos;]&quot;); Console.WriteLine(node.SelectSingleNode(&quot;Content&quot;).InnerText); xml.Save(&quot;../../Demo.xml&quot;); LINQ查询大数集合：private static int[] GetNumbers(int count) { Random ran = new Random(0); int[] result = new int[count]; for (int i = 0; i &lt; count; i++) { result[i] = ran.Next(); } return result; } static void Main(string[] args) { var nums = GetNumbers(12345678); var query = from n in nums where n &gt; 1000 select n; Console.WriteLine(query.Count()); Console.WriteLine(query.Max()); Console.WriteLine(query.Min()); // 默认版本.Sum()返回的是int，数值太大导致溢出 Console.WriteLine(query.Sum(p=&gt;(long)p)); Console.WriteLine(query.Average()); Console.ReadKey(); } LINQ 2：单值查询 .Distinct()（只选取没有重复的元素）任意符合 .Any()（任意元素符合条件返回true）全部符合 .All()（全部元素符合条件返回true） .First()和.FirstOrDefault()区别：.First()当条件不满足时，抛出异常.FirstOrDefault()当条件不满足时，返回一个null LINQ 3：集运算符：.Intersect() 使用默认的相等比较器得出两个序列的交集.Except() 同上，得出差集.Union() 同上，得出并集 Join查询： var orderIds = from n in list select n; var customers=from n in list join m in orderIds on n.Id equals m.Id //equals 关键词，必须 select n.Amount+m.Amount; LINQ TO XML：//从字符串转换 XDocument d1 = XDocument.Parse(@&quot; &lt;customers ID=&quot;&quot;A&quot;&quot; City=&quot;&quot;NY&quot;&quot; Region=&quot;&quot;North American&quot;&quot;&gt; &lt; order Item = &quot;&quot;Widget&quot;&quot; Price = &quot;&quot;100&quot;&quot; /&gt; &lt; order Item = &quot;&quot;Tire&quot;&quot; Price = &quot;&quot;200&quot;&quot; /&gt; &lt;/ customers &gt; &quot;); XDocument doc = new XDocument( //内部有其他元素，则有闭合标签 new XElement(&quot;customers&quot;, new XAttribute(&quot;ID&quot;, &quot;A&quot;), new XAttribute(&quot;City&quot;, &quot;NY&quot;), new XAttribute(&quot;Region&quot;, &quot;North American&quot;), //内部没有其他元素，则自闭 new XElement(&quot;order&quot;, new XAttribute(&quot;Item&quot;, &quot;Widget&quot;), new XAttribute(&quot;Price&quot;, 100) ), new XElement(&quot;order&quot;, new XAttribute(&quot;Item&quot;, &quot;Tire&quot;), new XAttribute(&quot;Price&quot;, 200) ) ) ); string path = &quot;../../demo.xml&quot;; doc.Save(path); XDocument d = XDocument.Load(path); Console.WriteLine(d); var query = from n in doc.Descendants(&quot;order&quot;) select n.Name; //.Elements()返回第一级子元素 //.Descendants()返回所有子元素 // 重载形式可以指定元素名 //.Attributes()返回当前元素所有特性]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F02%2F26%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git$ git config –global user.name “John Doe” //设置用户名邮箱–global 只针对当前用户$ git config –global user.email johndoe@example.com //去掉–global，针对特定项目使用不同的账号$ git config -l //列出所有设置$ git config –global alias.ci commit //设置别名$ git config –global alias.last ‘log -1 HEAD’ //看最后一次提交$ git config –global alias.visual ‘!gitk’ //外部命令，+!$ git config –global credential.helper cache //缓存验证密码$ git config –global alias.lg “log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative” //改造log显示，推荐 $ git init //在现有目录中初始化仓库$ git add //如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。add *$ git commit -a //跳过暂存，直接提交$ git log [-p] [-2] //提交记录。显示提交的差异。只显示2条。$ git log –oneline –decorate –graph –all //输出提交历史、各个分支的指向以及项目的分支分叉情况$ git status -s //更为紧凑的格式输出 $ git clone https://github.com/libgit2/libgit2 [mylibgit] //克隆现有的仓库，当前目录下创建一个名为 libgit2&#39;&#39; 的目录，并在这个目录下初始化一个.git 文件夹。[自定义文件夹命名]。命令会自动将其添加为远程仓库并默认以origin为简写。设置本地 master分支跟踪克隆的远程仓库的 master 分支。$ git clone -o booyah //自定义远程分支名字。创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master 。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。 $ git diff //查看上次暂存之后的变动$ git diff –staged //查看已经暂存的变动 $ git rm 1.txt //删除文件，跟踪清单和本地$ git rm –cached README //仓库中删除（亦即从暂存区域移除） ，但保留在当前工作目录中$ git mv 1.txt dir/2.txt //移动文件，也可重命名 $ git checkout a.md //还原成上次提交时的样子，只能撤销没add进暂存区的文件$ git reset HEAD 1.txt //取消暂存区中的文件$ git commit –amend //重新提交，覆盖上次提交 $ git remote //查看已经配置的远程仓库$ git remote -v //显示需要读写远程仓库使用的 Git 保存的简写与URL$ git remote add //添加一个新的远程 Git 仓库$ git remote show origin // URL 与跟踪分支的信息$ git remote rename pb paul //修改一个远程仓库的简写名$ git remote rm paul //移除一个远程仓库$ git push origin v1.5 //推送标签到远程$ git push origin –tags //推送远程没有的所有标签$ git push origin –delete serverfix //删除远程分支 $ git fetch origin master[:newb] //拉取pb的仓库中有但你没有的信息[并新建成分支newb]$ git checkout -b master origin/master //新建本地分支映射远程分支$ git pull //自动的抓取然后合并远程分支到当前分支=fetch+checkout$ git push origin master //推送到远程仓库的某一分支。需要：拥有写入权限，且本地与远程数据同步时。 $ git tag //列出已有的标签$ git tag -l ‘v1.8.5*’ //只对 1.8.5 系列$ git tag -a v1.4 -m ‘my version 1.4’ //创建一个附注标签$ git show v1.4 //标签信息$ git tag v1.4-lw //创建轻量标签，没有保存任何其他信息$ git tag //查看$ git tag -a v1.2 9fceb02 //后期打标签$ git checkout -b version2 v2.0.0 //在特定的标签上创建一个新分支 $ git stash //暂存当前所有改动$ git stash list //查看暂存记录$ git stash apply //还原已暂存代码$ git stash drop [stash_id] //删除暂存记录，[删除某条]$ git stash pop //快捷：还原+删除$ git stash clear //清空暂存区记录 $ git branch [–merged/–no-merged] //分支列表,[查看已/未与当前分支合并的分支],如与master合并的分支可以删除，无损失$ git branch -v //查看每个分支最后一次提交$ git branch -a //查看所有分支（远程和本地）$ git branch -r //查看所有远程分支$ git branch testing //分支创建$ git checkout testing //分支切换$ git checkout -b iss53 //新建并切换到新分支$ git checkout -b serverfix origin/serverfix //在某分支之上建立分支$ git checkout master //合并分支①$ git merge iss53 //合并分支②$ git branch -d hotfix //删除分支 $ git rebase master //以master为基底进行变基，重演experiment的提交过程，并清理提交历史。只对尚未推送或分享给别人的本地修改执行变基操作清理历史$ git checkout master //往回切换到master分支$ git merge experiment //master快进到目标点 忽略列表(.gitignore)* //匹配零个或多个任意，.a//支持glob模式(简化正则表达式)[abc] //匹配a或b或c? //只匹配一个任意字符!lib.a //忽略lib.a以外的文件[0-9] //匹配所有 0 到 9 的数/.txt //只忽略当前文件夹下的文件，不包括子目录 a/.txtbuild/ //忽略所有build/目录下的文件doc/**/.pdf //忽略所有.pdf文件在doc/ 目录下** //匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或a/b/c/z 等]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法示例]]></title>
    <url>%2F2017%2F02%2F26%2FMarkdown%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[基础标题123456#一级标题##二级标题###三级标题####四级#####五级######六级 列表123456789无序列表- 1- 2- 3有序列表1. 1 2. 23. 3 1 2 1 2 文本1*斜体* **粗体** 斜体 粗体 1&gt; 这里是引用 这里是引用 链接1[Baidu](http://www.baidu.com &quot;百度&quot;) Baidu 1234I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from Google than fromYahoo or MSN. 1![Logo](http://cdn-qn0.jianshu.io/assets/web/logo-58fd04f6f0de908401aa561cda6a0688.png &quot;简书&quot;) 1See my [Markdown语法示例](/Markdown语法示例) page. See my Markdown语法示例 page. 代码12`public void Add()` //局部代码块 public void Delete() //一个tab或四个空格 public void Add() public void Delete() Html123&lt;div style=&quot;color:red;&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; &copy; 2004 Foo Corporation 反义符号 ‘\’11986\. What a great season. 1986. What a great season. 未转义：11986. What a great season. What a great season. 进阶内容目录1[TOC] *这里不支持 删除线1~~ 表示删除线。 删除的文本 增强代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 12345678910111213141516/*** @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 表格1234|列首1|列首2|列首3|列首4||-:|:-: 右对齐，居中，左对齐(默认)|单元格|单元格|单元格|单元格||单元格|单元格|单元格|单元格| 列首1 列首2 列首3 列首4 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个Todo列表，支持嵌套以及混用Markdown语法 - [ ] **待办** - [ ] *取快递* - [x] 工作安排 - [x] 本季度绩效统计 [Google 表格](https://docs.google.com/spreadsheets/) 对应显示如下待办事宜 Todo 列表： 待办 取快递 工作安排 本季度绩效统计 Google 表格]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>

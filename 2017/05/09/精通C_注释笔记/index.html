<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C#," />










<meta name="description" content="第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言">
<meta name="keywords" content="C#">
<meta property="og:type" content="article">
<meta property="og:title" content="精通C#_注释笔记">
<meta property="og:url" content="http://adieUkid.github.io/2017/05/09/精通C_注释笔记/index.html">
<meta property="og:site_name" content="Alan&#39;s Notes">
<meta property="og:description" content="第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/cts.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/mscoree.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/namespace.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/delegate.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/strong.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/tree.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/relation.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/relation2.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/mapping.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/reflection.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/threading.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/io.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/map.jpg">
<meta property="og:image" content="http://adieukid.github.io/images/CSharp/MasterC/save.jpg">
<meta property="og:updated_time" content="2018-11-29T01:53:50.553Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="精通C#_注释笔记">
<meta name="twitter:description" content="第一部分：C#与.NET平台源码-IL-汇编过程.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言">
<meta name="twitter:image" content="http://adieukid.github.io/images/CSharp/MasterC/cts.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://adieUkid.github.io/2017/05/09/精通C_注释笔记/"/>





  <title>精通C#_注释笔记 | Alan's Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?94a8565d2829b2f9641fe2f93513cd52";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alan's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">笔记分享</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://adieUkid.github.io/2017/05/09/精通C_注释笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alan's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">精通C#_注释笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T19:05:53+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第一部分：C-与-NET平台"><a href="#第一部分：C-与-NET平台" class="headerlink" title="第一部分：C#与.NET平台"></a>第一部分：C#与.NET平台</h2><h3 id="源码-IL-汇编过程"><a href="#源码-IL-汇编过程" class="headerlink" title="源码-IL-汇编过程"></a>源码-IL-汇编过程</h3><p>.NET语言的编译分为两个阶段.首先高级语言被编译成一种称作IL的中间语言，与高级语言相比，IL更像是机器语言<a id="more"></a>，然而，IL却包含一些抽象概念(比如：类、异常)，这也是这种语言被称为中间语言的原因。IL被打包在DLL或EXE文件中，而DLL和EXE在.NET中的主要区别就是：只有EXE可以直接被运行，而二者都可被某个正在执行的进程动态装载。由于机器的CPU只能执行本地汇编语言，而不是IL，进一步将IL编译成汇编语言的工作(也就是第二阶段)需要在运行时进行，这个过程由即时编译器(JIT)完成。 </p>
<p>高级语言在初次被编译时，编译器做两件事：首先把编译得到的IL存储在DLL或EXE中，然后为类的每个方法创建一个stub函数，此函数会调用即时编译器，并将自身的地址作为参数传给编译器。即时编译器则从DLL或EXE中获取相应的IL，编译成机器语言，并将内存中的原零时调用函数替换成机器语言。这个过程的思想，是用已编译的方法调用未编译的方法，实质上被调用的是stub函数；stub函数再调用编译器，将自身编译为本地机器语言；最后，.NET会重新调用该方法，方法此时才被真正地执行。函数被反复调用时，机器指令会被直接执行，而只由编译器对方法进行初次编译需要花费时间。至于那些没有被调用的方法，则不会被编译。 </p>
<p>当编译器生成一个EXE文件后， 该程序的入口函数为Main() 方法。装载器将这个EXE 文件载入，探测到该这是一个托管EXE，于是又载入 .NET运行时库文件(包括即时编译器)， 接着调用了EXE 的Main() 方法。这将触发对Main()方法的即时编译， Main()方法在内存中被替换为本地机器语言，于是 .NET应用程序开始运行。在被编译为本地语言后，应用程序便可以自由调用本地代码了。当程序中止时，本地代码从内存中释放，所以在下次运行时，IL需要被即时编译器重新编译。</p>
<h3 id="CTS"><a href="#CTS" class="headerlink" title="CTS"></a>CTS</h3><p>类型规范，规定了类型必须如何定义才能被CLR承载。內建的CTS数据类型：</p>
<p><img src="/images/CSharp/MasterC/cts.jpg" alt="CTS"></p>
<h3 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h3><p>不同的语言有不同的表示，理想情况是所有支持.NET的语言都有一个可遵循的基准。描述了支持.NET的编译器必须支持的最小的和完全的特征集。以生成可由CLR承载的代码。</p>
<h3 id="mscoree-dll工作流"><a href="#mscoree-dll工作流" class="headerlink" title="mscoree.dll工作流"></a>mscoree.dll工作流</h3><p><img src="/images/CSharp/MasterC/mscoree.jpg" alt="mscoree"></p>
<h3 id="NET命名空间举例"><a href="#NET命名空间举例" class="headerlink" title=".NET命名空间举例"></a>.NET命名空间举例</h3><p><img src="/images/CSharp/MasterC/namespace.jpg" alt="namespace"></p>
<h3 id="Microsoft根命名空间"><a href="#Microsoft根命名空间" class="headerlink" title="Microsoft根命名空间"></a>Microsoft根命名空间</h3><p>包含的类型用于和那些只属于Windows操作系统的服务进行交互。</p>
<h3 id="NET-SKD"><a href="#NET-SKD" class="headerlink" title=".NET SKD"></a>.NET SKD</h3><p>配置Path或者 开始-所有程序-Vs-VS Tools-开发人员命令提示</p>
<pre><code>csc /t:exe[/target:exe] 1.cs
csc 1.cs（默认）
csc /t:library 1.cs（输出dll）
</code></pre><h3 id="响应文件"><a href="#响应文件" class="headerlink" title="响应文件"></a>响应文件</h3><p>外部引用</p>
<pre><code>/r:System.Windows.Forms.dll
</code></pre><p>输出</p>
<pre><code>/target:exe /out:TestApp.exe *cs
</code></pre><p>默认响应文件csc.rsp（与csc.exe同目录），包含大部分常用程序集引用。默认被csc.exe引用。可以简写为：</p>
<pre><code>csc /out:TestApp.exe *.cs
</code></pre><p>##</p>
<hr>
<h2 id="第二-三部分：C-核心编程结构-C-面向对象编程"><a href="#第二-三部分：C-核心编程结构-C-面向对象编程" class="headerlink" title="第二/三部分：C#核心编程结构/C#面向对象编程"></a>第二/三部分：C#核心编程结构/C#面向对象编程</h2><h3 id="char的静态方法"><a href="#char的静态方法" class="headerlink" title="char的静态方法"></a>char的静态方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>.IsDigit;           <span class="comment">//是否为数字 </span></span><br><span class="line"><span class="keyword">char</span>.IsLetter;          <span class="comment">//是否为字母</span></span><br><span class="line"><span class="keyword">char</span>.IsWhiteSpace;      <span class="comment">//是否为空白</span></span><br><span class="line"><span class="keyword">char</span>.IsPunctuation;     <span class="comment">//是否为标点</span></span><br><span class="line"><span class="keyword">char</span>.IsLower;           <span class="comment">//是否为小写</span></span><br><span class="line"><span class="keyword">char</span>.IsUpper;           <span class="comment">//是否为大写</span></span><br></pre></td></tr></table></figure>
<h3 id="改变枚举底层存储类型"><a href="#改变枚举底层存储类型" class="headerlink" title="改变枚举底层存储类型"></a>改变枚举底层存储类型</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EmpType</span><br><span class="line">&#123;</span><br><span class="line">    Manager,</span><br><span class="line">    Grunt,</span><br><span class="line">    Contractor,</span><br><span class="line">    VicePresident</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以节省内存。但小心溢出。可以定义未核心系统类型（byte,short,int或long）。</p>
<p>获取底层存储类型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum.GetUnderlyingType(<span class="keyword">typeof</span>(EmpType))   -&gt;   System.Int32</span><br></pre></td></tr></table></figure>
<p>获取名值对：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = Enum.GetValues(<span class="keyword">typeof</span>(EmpType));</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ret)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;，&#123;0:D&#125;"</span>, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="System-ValueType"><a href="#System-ValueType" class="headerlink" title="System.ValueType"></a>System.ValueType</h3><p>枚举，结构都隐式派生自此类型。分配在栈上运行。</p>
<h3 id="浅-深复制"><a href="#浅-深复制" class="headerlink" title="浅/深复制"></a>浅/深复制</h3><p>当一个值类型中包含一个引用类型。如结构中包含对象引用，直接等号赋值时会有两个独立的结构，内部生成一个引用的副本，指向内存中同一个对象的引用。（浅复制）。</p>
<h3 id="默认访问修饰符"><a href="#默认访问修饰符" class="headerlink" title="默认访问修饰符"></a>默认访问修饰符</h3><p>类型成员（变量，方法），是隐式【私有】的。类型（对象）是隐式【内部】的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Radio</span>   <span class="comment">//内部</span></span><br><span class="line">&#123;</span><br><span class="line">    Radie()&#123;&#125;   <span class="comment">//私有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Const-readonly-static"><a href="#Const-readonly-static" class="headerlink" title="Const,readonly,static"></a>Const,readonly,static</h3><p>const(常量)=readonly(只读)+static(静态)。<br>编译期确定   运行期确定<br>都不可再更改。</p>
<p>##</p>
<hr>
<h2 id="第四部分：高级C-编程结构"><a href="#第四部分：高级C-编程结构" class="headerlink" title="第四部分：高级C#编程结构"></a>第四部分：高级C#编程结构</h2><h3 id="delegate关键字"><a href="#delegate关键字" class="headerlink" title="delegate关键字"></a>delegate关键字</h3><p>使用此关键字创建委托时，就间接声明了一个派生自MulticastDelegate的类。不会直接派生自这些基类，但这个类“是”MulticastDelegate。</p>
<p><img src="/images/CSharp/MasterC/delegate.jpg" alt="delegate"></p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>一个委托对象维护一个可调用方法的列表，而不是一个单独的方法。添加方法，使用+=即可。编译器会将+=转换为Delegate.Combine()方法调用。+=更简洁，-=则转换为Delegate.Remove()。</p>
<h3 id="event事件"><a href="#event事件" class="headerlink" title="event事件"></a>event事件</h3><p>事件会扩展为两个隐藏的公共方法，一个add_xx，一个remove_xx。调用者仅需使用+=和-=操作符（操作符将在后台触发正确的add_xx和remove_xx方法，来对原委托进行操作）。</p>
<h3 id="EventHanlder"><a href="#EventHanlder" class="headerlink" title="EventHanlder"></a>EventHanlder<t></t></h3><p>自定义EventArgs的泛型委托：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">My</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs&gt; Display;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params">MyEventArgs msg</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Display != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Display(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不再需要定义一个自定义委托类型。</p>
<h3 id="操作符重载的思考"><a href="#操作符重载的思考" class="headerlink" title="操作符重载的思考"></a>操作符重载的思考</h3><p>通常仅在构建原子数据类型时才有用。文本，点，举行，分数等都是操作符重载的很好候选。人，经理，汽车，数据库连接等却不是。如果一个重载操作符会使用户更难于理解该类型的功能，那就别用它。</p>
<h3 id="Try-catch的CIL实现"><a href="#Try-catch的CIL实现" class="headerlink" title="Try catch的CIL实现"></a>Try catch的CIL实现</h3><p>对一个实现了IDispose对象的using{}语句块会被CIL解析为一个try{}finally{}块。确保Dispose的执行。</p>
<h3 id="new关键字的CIL实现"><a href="#new关键字的CIL实现" class="headerlink" title="new关键字的CIL实现"></a>new关键字的CIL实现</h3><p>使用new时，等同于CIL指令newobj：</p>
<p>执行：</p>
<ol>
<li>计算分配对象需要总内存数</li>
<li>检查托管堆，如果空间足够，则调用类型构造函数，最终将内存中新对象的应用返回给调用者。它的地址恰好是下一个对象的上一个位置。如果空间不足，则执行一次垃圾回收来尝试是否内存。</li>
<li>返回引用之前，移动下一个对象的指针，指向托管堆上的下一个可用的位置。</li>
</ol>
<h3 id="自动属性的CIL实现"><a href="#自动属性的CIL实现" class="headerlink" title="自动属性的CIL实现"></a>自动属性的CIL实现</h3><p>自动属性的get;set;标记会在元数据中被编译器映射成一个私有字段Name和两个方法get_Name(),set_Name()。</p>
<h3 id="应用程序根"><a href="#应用程序根" class="headerlink" title="应用程序根"></a>应用程序根</h3><p>根(root)就是一个存储位置，保存着对托管堆上对象的引用。垃圾回收时，CLR判读托管堆上的对象，判断应用程序是否仍然可访问它们(是否还有根)。为此，CLR建立一个对象图。不可访问的对象被标记为终结(finalize，垃圾)，它们就会从内测中清除。此时，堆上剩余的空间被压缩调整，引起CLR修改活动应用程序根的集合，指向正确的内存位置。下一个对象的指针被重新调整指向下一个可用位置。</p>
<h3 id="对象的代"><a href="#对象的代" class="headerlink" title="对象的代"></a>对象的代</h3><p>设计思路：对象在堆上存在的时间越长，他就更可能应该保留。(WinForm主窗口)最近才放在堆上的对象可能很快就不可访问了。(一个方法中创建的对象)。</p>
<p>第0代：从没有被标记为回收的新分配对象。<br>第1代：在上一次垃圾回收中没有被回收的对象(曾被标记为回收，但因为已经从其他对象获取了足够的堆空间而没有被删除)。<br>第2代：在一次以上的垃圾回收后仍然没被回收的对象。</p>
<p>通过给对象赋一个表示代的值，尽快的删除一些较新的对象(本地变量)，而不会经常打扰一些旧对象(主窗体)</p>
<h3 id="强制垃圾回收"><a href="#强制垃圾回收" class="headerlink" title="强制垃圾回收"></a>强制垃圾回收</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();   <span class="comment">//强制回收所有代</span></span><br><span class="line"><span class="comment">//GC.Collect(1, GCCollectionMode.Forced);   //回收0-1代</span></span><br><span class="line">GC.WaitForPendingFinalizers();   <span class="comment">//挂起线程，等待回收结束</span></span><br></pre></td></tr></table></figure>
<p>适用：</p>
<ol>
<li>程序将进入一段代码，后者不希望被可能得垃圾回收中断。</li>
<li>刚刚分配分厂多的对象，想尽可能多地删除已获得的内存。</li>
</ol>
<h3 id="GC测试"><a href="#GC测试" class="headerlink" title="GC测试"></a>GC测试</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出堆上估计得字节数</span></span><br><span class="line">Console.WriteLine(GC.GetTotalMemory(<span class="literal">false</span>));</span><br><span class="line"><span class="comment">//目前最高代</span></span><br><span class="line">Console.WriteLine(GC.MaxGeneration);</span><br><span class="line"><span class="comment">//某对象处于多少代</span></span><br><span class="line"><span class="keyword">object</span> obj = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">Console.WriteLine(GC.GetGeneration(obj));</span><br><span class="line"><span class="comment">//测试数组</span></span><br><span class="line"><span class="keyword">object</span>[] objs = <span class="keyword">new</span> <span class="keyword">object</span>[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)</span><br><span class="line">    objs[i] = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="comment">//输出堆上估计得字节数</span></span><br><span class="line">Console.WriteLine(GC.GetTotalMemory(<span class="literal">false</span>));</span><br><span class="line"><span class="comment">//回收第1代</span></span><br><span class="line">GC.Collect(<span class="number">0</span>, GCCollectionMode.Forced);</span><br><span class="line">GC.WaitForPendingFinalizers();</span><br><span class="line">Console.WriteLine(GC.GetGeneration(obj));</span><br><span class="line"><span class="comment">//看一下9000是否还活着</span></span><br><span class="line"><span class="keyword">if</span> (objs[<span class="number">9000</span>] != <span class="literal">null</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">"活着：处于"</span> + GC.GetGeneration(objs[<span class="number">9000</span>]) + <span class="string">"代"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Console.WriteLine(<span class="string">"死了"</span>);</span><br><span class="line"><span class="comment">//某代被回收次数</span></span><br><span class="line">Console.WriteLine(<span class="string">"0代：&#123;0&#125;，1代：&#123;1&#125;，2代：&#123;2&#125;"</span>, GC.CollectionCount(<span class="number">0</span>), GC.CollectionCount(<span class="number">1</span>), GC.CollectionCount(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳过对象的终结阶段，通知CLR不在调用对象的析构函数</span></span><br><span class="line"></span><br><span class="line">GC.SuppressFinalize(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h3 id="资源包装器"><a href="#资源包装器" class="headerlink" title="资源包装器"></a>资源包装器</h3><p>引用托管或非托管宝贵的资源(数据库，文件句柄等)时，希望尽可能快的释放资源。而不能依靠GC的回收。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyResourceWrapper</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断Dispose()是否被调用过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> disposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户忘了Dispose()，垃圾回收器会调用这个方法</span></span><br><span class="line">    ~MyResourceWrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用辅助方法，指定false表示GC触发了清理</span></span><br><span class="line">        CleanUp(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户可以主动调用，来尽快清除资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用辅助方法，指定true表示用户触发了清理</span></span><br><span class="line">        CleanUp(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);                        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanUp</span>(<span class="params"><span class="keyword">bool</span> disposing</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果disposing为true，释放所有托管资源。如果disposing为false，不确定托管资源是否还在内存中，不执行释放。</span></span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//释放托管的资源</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在这里释放非托管的资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">~MyResourceWrapper()</span><br><span class="line">&#123;</span><br><span class="line">    Console.Beep();   <span class="comment">//命令行一声响声</span></span><br><span class="line">    CleanUp(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyResourceWrapper m = <span class="keyword">new</span> MyResourceWrapper();</span><br><span class="line">    m.Dispose();</span><br><span class="line"></span><br><span class="line">    MyResourceWrapper m1 = <span class="keyword">new</span> MyResourceWrapper();</span><br><span class="line">    <span class="comment">//此时会响一声</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lazy-延迟加载"><a href="#Lazy-延迟加载" class="headerlink" title="Lazy 延迟加载"></a>Lazy<t> 延迟加载</t></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MP3 m = <span class="keyword">new</span> MP3();     <span class="comment">//不使用Lazy，此句加载SDCard，然后初始化Song[]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> r = m.Card;             </span><br><span class="line">        <span class="keyword">var</span> v = r.Value;              <span class="comment">//使用Lazy，此句加载SDCard，然后初始化Song[]</span></span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        <span class="keyword">var</span> c = m.GetCard();</span><br><span class="line">        </span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Song</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FileName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FileLength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SDCard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> Song[] allSongs = <span class="keyword">new</span> Song[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;    Console.WriteLine(<span class="string">"装满歌曲"</span>);    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MP3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//public void Play() //播放</span></span><br><span class="line">    <span class="comment">//public void Pause() //暂停</span></span><br><span class="line">    <span class="comment">//public void Stop() //停止</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Lazy&lt;SDCard&gt; Card = <span class="keyword">new</span> Lazy&lt;SDCard&gt;(() =&gt;       <span class="comment">//不传参或传一个Lambda表达式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newCard = <span class="keyword">new</span> SDCard &#123; Price = <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> newCard;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SDCard <span class="title">GetCard</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Card.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第五部分：用-NET程序集编程"><a href="#第五部分：用-NET程序集编程" class="headerlink" title="第五部分：用.NET程序集编程"></a>第五部分：用.NET程序集编程</h2><h3 id="NET程序集的作用"><a href="#NET程序集的作用" class="headerlink" title=".NET程序集的作用"></a>.NET程序集的作用</h3><ol>
<li>促进代码重用。一个代码库(<em>.dll或</em>.exe)被打包后，可以被外部应用程序调用。.NET平台允许我们以语言无关的方式来重用其中的类型，如C#创建，其他.NET语言调用。</li>
<li>确定类型便捷。类型的完全限定名需要加上类型所在程序集。如两个不同程序集中命名空间相同的类，被认为是不同的。</li>
<li>可版本化的单元。每个程序集被分配一个<major>.<minor>.<build>.<revision>的四部分数字版本号(默认1.0.0.0，默认VS项目设置)。版本号加上可选的公钥值(即程序集强名)使一个程序集的不同版本可在同一台机器共存而不冲突 。通过强名，CLR保证客户端调用程序能加载正确版本的程序集。</revision></build></minor></major></li>
<li>自描述。程序集记录了清单数据(自身运行需要的外部程序集)，还包含了一些元数据(程序集包含的每一个类型的组成，成员名称，接口，基类，构造等)。由于信息被详细的记录了，CLR不需要访问注册表来解析程序集的位置(区别于与微软原来的COM编程模型)</li>
<li>可配置的。程序集可“私有”或“共享”。私有：与调用它的客户端应用程序处于同一个目录或子目录下，共享：被部署在全局程序集缓存（GAC）的特定目录中。通过编写XML的配置文件，CLR可以指定位置朝赵，加载指定版本的程序集。查阅本地，网络或URL上的任意目录。</li>
</ol>
<h3 id="程序集和托管模块"><a href="#程序集和托管模块" class="headerlink" title="程序集和托管模块"></a>程序集和托管模块</h3><p>一个团队（程序集），是一个逻辑单位。里面有很多成员（托管模块），成员分2类：</p>
<p>普通成员（托管模块，后缀.netModule。持有元数据和CIL代码）。<br>领导成员（主模块，后缀.exe或.dll。持有程序集清单），了解每个成员。<br>一般与这个团队（程序集）沟通或合作是面向它的领导（主模块），同样以领导名称来称呼这个团队。</p>
<p>C#生成的程序集一般为单模块程序集（只有主模块）。</p>
<h3 id="NET程序集的格式"><a href="#NET程序集的格式" class="headerlink" title=".NET程序集的格式"></a>.NET程序集的格式</h3><p>(<em>.dll或</em>.exe)包含：</p>
<ol>
<li>Windows文件首部<br>可被Windows操作系统加载，标识了应用程序以什么类型（控制台，图形用户界面还是*.dll代码库）驻留于Windows操作系统中。</li>
<li>CLR文件首部<br>使CLR了解托管文件的布局，位置和强名等</li>
<li>CIL代码<br>独立于平台和CPU的中间语言，运行时才被JIT变异成特定平台和CPU的指令。</li>
<li>类型元数据<br>内含类型和外部应用类型的格式。</li>
<li>程序集清单<br>记录了每一个模块，版本和引用的外部程序集。</li>
<li>可选的嵌入资源<br>图标，图像，声音，字符串表。卫星程序集(附属程序集)可构建国际化软件系统。</li>
</ol>
<p>代码中的每个字符串字面量都记录在元数据的User Strings 标记下，所以不能储存敏感信息。</p>
<h3 id="私有程序集"><a href="#私有程序集" class="headerlink" title="私有程序集"></a>私有程序集</h3><p>应用程序添加外部程序集引用的时候，把副本文件放在本地bin文件夹下。调用时，CLR只是加载本地的副本。并不查询系统注册表。</p>
<p>配置私有程序集：<br>Test.exe     //一个Console控制台程序<br>Carlib.dll    //控制台会调用的程序集</p>
<p>以下三种情况会正常运行：</p>
<ol>
<li>把Test.exe和Carlib.dll放在同一个文件夹下</li>
<li>找不到Carlib.dll的文件，会查找同一个文件夹下具有相同友好名称的可执行程序集.exe文件</li>
<li>找与程序集同名的文件夹下是否有此程序集。如Carlib/Carlib.dll</li>
<li>如果有Test.exe.config配置文件，CLR会根据配置的“规则”探测指定文件夹下是否有此程序集</li>
</ol>
<p>例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">runtime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">"urn:schemas-microsoft-com:asm.v1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">probing</span> <span class="attr">privatePath</span>=<span class="string">"CarLibChg/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果还是找不到，会引发FileNotFoundException异常。<br>VS的App.config会在编译的时候，把App.config的数据复制到bin/debug/文件下，并改一个合适的名称。如Test.exe.config，FrontWeb.dll.config。</p>
<h3 id="共享程序集"><a href="#共享程序集" class="headerlink" title="共享程序集"></a>共享程序集</h3><p>例如mscorlib.dll，旨在多个项目中服用的类型的集合，共享程序集的一个副本可供一台机器上的多个应用程序使用，是机器级别的类库（machine wide）。</p>
<p>全局程序集缓存：<br>.NET 3.5以前的位置在，C:\Windows\assembly下。<br>.NET 4.0以上的在C:\Windows\Microsoft.NET\assembly\GAC_MSIL下的v4.0_major.minor.build.revision_publicKeyTokenValue子文件夹下。例如：v4.0_4.0.0.0__b77a5c561934e089。</p>
<h3 id="强名称"><a href="#强名称" class="headerlink" title="强名称"></a>强名称</h3><ol>
<li>需要.NET的sn.exe工具生成公钥/私钥对。生成一个<em>.snk（Strong Name Key）文件。C#编译器确定</em>.snk文件的位置后，会在编译时把公钥值记录在程序集清单的.publickey标记中。</li>
<li>产生一个基于整个程序集内容（CIL代码，元数据等）的散列值（某一固定输入的独一无二的数值输出，如果更改了程序集的内容，就算只一个字符，陈胜的讲师完全不同的散列码）。散列码结合私钥组成数字签名，并把它嵌入到程序集的CLR首部数据中。</li>
</ol>
<p><img src="/images/CSharp/MasterC/strong.jpg" alt="strong"></p>
<p>用命令行生成强名：<br>developer Command Prompt下</p>
<pre><code>sn -k 文件名.snk
</code></pre><p>再在AssemblyInfo.cs文件中指定位置</p>
<pre><code>[assembly: AssemblyKeyFile(@&quot;C:\MyTestKeyPair.snk&quot;)]
</code></pre><p>编译时，公钥被压缩成散列值加入到清单中 .publicKeyToken标记</p>
<p>用VS生成强名：<br>Properties -&gt; 签名 -&gt;新建<br>便会在根目录下生成一个*.snk文件</p>
<h3 id="在GAC中安装强名称的程序集"><a href="#在GAC中安装强名称的程序集" class="headerlink" title="在GAC中安装强名称的程序集"></a>在GAC中安装强名称的程序集</h3><p>使用Developer Command Prompt定位到*.dll所在目录（bin\debug）<br>使用 </p>
<pre><code>gacutil -i test.dll/test.exe  //安装
gacutil -l test  //核实
gacutil -u  test //卸载
</code></pre><p>VS引用程序集时，如果清单中含有.publickey值时，VS会嘉定这个具有强名称的程序集以备部署到GAC中，那么引用的属性窗口中的，复制本地就为false。不会对该程序集进行复制到本地debug文件夹中的工作。</p>
<h3 id="配置共享程序集"><a href="#配置共享程序集" class="headerlink" title="配置共享程序集"></a>配置共享程序集</h3><p>发布了1.0.0.0版本后，添加了一些新的功能，产生了2.0.0.0版本。如果客户端应用程序想要使用2.0.0.0版本的新功能，可以把2.0.0.0版本发布到目标机器，让2和1版本和平共处。需要的时候修改*.config文件，动态的定向到2.0.0.0版本。这一切并不需要重新编译和部署。</p>
<p>动态重定向到共享程序集：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assemblyIdentity</span> <span class="attr">name</span>=<span class="string">"System.Web.Mvc"</span> <span class="attr">publicKeyToken</span>=<span class="string">"31bf3856ad364e35"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bindingRedirect</span> <span class="attr">oldVersion</span>=<span class="string">"0.0.0.0-5.2.3.0"</span> <span class="attr">newVersion</span>=<span class="string">"5.2.3.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependentAssembly</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义了程序清单当前指向的版本(oldVersion)和GAC中的替代版本(newVersion)</p>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><codebase>元素</codebase></h3><p>用于指示CLR探测位于任意位置（网络重点，其他本地目录）的依赖程序集。当指向远程计算机时，相关程序集会下载到GAC的下载缓存中。通过此元素加载的程序集必须具有强名称。</p>
<p>例：</p>
<pre><code>&lt;codeBase version=&quot;2.0.0.0&quot; href=&quot;http://www.MySite.con/Assemblies/CarLibrary.dll&quot; /&gt;
</code></pre><h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Car c = <span class="keyword">new</span> Car();</span><br><span class="line">Type t1 = c.GetType();      <span class="comment">//编译器获得Type实例，需要类型实例</span></span><br><span class="line">Type t2 = <span class="keyword">typeof</span>(Car);      <span class="comment">//同上，不需类型实例</span></span><br><span class="line">Type t3 = Type.GetType(<span class="string">"ConsoleApplication2.Person"</span>, <span class="literal">false</span>, <span class="literal">true</span>);      <span class="comment">//完全限定名（不抛出异常，忽略大小写）</span></span><br><span class="line">Type t4 = Type.GetType(<span class="string">"ConsoleApplication2.Person+Sex"</span>, <span class="literal">false</span>, <span class="literal">true</span>);  <span class="comment">//获得类型中的嵌套类型，加“+”</span></span><br><span class="line">Type t5 = Type.GetType(<span class="string">"CarLib.Car,CarLib"</span>, <span class="literal">false</span>, <span class="literal">true</span>);               <span class="comment">//引用外部程序集类型，加“,”</span></span><br><span class="line">Type t6 = Type.GetType(<span class="string">"System.Collections.Generic.List`1"</span>, <span class="literal">false</span>, <span class="literal">true</span>);       <span class="comment">//对于泛型，加“`”+数字（类型参数的个数）</span></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>
<h3 id="动态加载程序集"><a href="#动态加载程序集" class="headerlink" title="动态加载程序集"></a>动态加载程序集</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly asm = Assembly.Load(<span class="string">"Carlib"</span>);             <span class="comment">//需要保证程序集二进制文件在Debug文件夹下</span></span><br><span class="line">asm = Assembly.LoadFrom(<span class="string">@"C:\Code\Carlib.dll"</span>);     <span class="comment">//绝对路径，以编程的形式提供&lt;codeBase&gt;值</span></span><br><span class="line">asm.GetTypes().ToList().ForEach(Console.WriteLine);</span><br></pre></td></tr></table></figure>
<h3 id="反射共享程序集"><a href="#反射共享程序集" class="headerlink" title="反射共享程序集"></a>反射共享程序集</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> displayName = <span class="string">@"System.Windows.Form.dll,Version=4.0.0.0,PublicKeyToken=b77a5c561934e089,Culture="""</span>;</span><br><span class="line"><span class="comment">//显示名称：标识一个程序集的一组术语</span></span><br><span class="line"><span class="comment">//加载共享程序集必须指定公钥标记值</span></span><br><span class="line"></span><br><span class="line">AssemblyName asmName = <span class="keyword">new</span> AssemblyName();</span><br><span class="line">asmName.Version = <span class="keyword">new</span> Version(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//或者使用面向对象的类来传递Version,PublicKeyToken等参数</span></span><br><span class="line"></span><br><span class="line">Assembly asm = Assembly.Load(displayName);</span><br><span class="line">asm = Assembly.Load(asmName);</span><br></pre></td></tr></table></figure>
<h3 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Assembly asm = Assembly.Load(<span class="string">"CarLib"</span>);     <span class="comment">//无需引用，只需把程序集文件放在Debug文件夹下</span></span><br><span class="line">Type car = asm.GetType(<span class="string">"CarLib.Car"</span>);       </span><br><span class="line"><span class="keyword">object</span> obj = Activator.CreateInstance(car); <span class="comment">//建立一个晚期绑定类型的实例，类型为object。</span></span><br><span class="line"><span class="keyword">object</span> obj1 = Activator.CreateInstance(<span class="string">"CarLib"</span>, <span class="string">"CarLib.Car"</span>).Unwrap();</span><br><span class="line"></span><br><span class="line">MethodInfo mi = car.GetMethod(<span class="string">"Run"</span>);   <span class="comment">//无法转换类型，使用反射调用实例方法。默认搜索公共方法成员</span></span><br><span class="line">mi.Invoke(obj, <span class="literal">null</span>);                   <span class="comment">//调用无参方法</span></span><br><span class="line"></span><br><span class="line">MethodInfo mi2 = car.GetMethod(<span class="string">"Stop"</span>, BindingFlags.Instance | BindingFlags.NonPublic);     <span class="comment">//指定私有成员包含在搜索内</span></span><br><span class="line">mi2.Invoke(obj, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="string">"停车"</span> &#125;); <span class="comment">//指定参数列表</span></span><br></pre></td></tr></table></figure>
<p>关键在于，在没有某个程序集清单数据的情况下，创建程序集的类型实例。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>用于类型，成员，程序集或模块的代码注解。把更多的元数据嵌入到程序集中。</p>
<h3 id="程序集级别特性"><a href="#程序集级别特性" class="headerlink" title="程序集级别特性"></a>程序集级别特性</h3><p>使用[assembly:]标签，给特定程序集所有类型应用特性。例：[assembly: CLSCompliant(true)]，强制所有程序集中的公共类型符合CLS。</p>
<h3 id="构建可扩展的应用程序"><a href="#构建可扩展的应用程序" class="headerlink" title="构建可扩展的应用程序"></a>构建可扩展的应用程序</h3><p>比如VS，开发的时候允许其他软件提供商向IDE开发环境中插入各种“钩子”（自定义模块），一个可能得思路如下：</p>
<ol>
<li>可扩展的应用程序必须提供一些输入手段，允许用户指定被插入的模块。这需要动态加载。</li>
<li>必须要确定模块是否支持正确的功能（一组需要的接口）。这需要反射。</li>
<li><p>必须获取一个需要的基础架构的引用（例如接口类型）并调用成员触发底层功能。这经常需要晚期绑定。</p>
</li>
<li><p>构建每个插件对象需要实现的类型定义</p>
</li>
</ol>
<p>应用于插件对象和承载应用程序，保证功能统一。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CommonSnappableTypes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAppFunctionality</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoIt</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CompanyInfoAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> CompanyName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> CompanyUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>构建C#插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">namespace CSharpSnapIn</span><br><span class="line">&#123;</span><br><span class="line">    [CompanyInfo(CompanyName = &quot;JetBrains&quot;, CompanyUrl = &quot;www.xxx.com&quot;)]</span><br><span class="line">    public class CSharpModule : IAppFunctionality</span><br><span class="line">    &#123;</span><br><span class="line">        void IAppFunctionality.DoIt()       //显示的接口实现，DoIt方法没有在CSharpModule中公开</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;使用了自定义插件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        或</span><br><span class="line"></span><br><span class="line">        public void DoIt()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;使用了自定义插件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>构建承载的应用程序</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">string</span> path = <span class="string">"..."</span>;    <span class="comment">//可以从WinForm等应用程序中选择程序集文件</span></span><br><span class="line">            Assembly asm = Assembly.LoadFrom(path);     <span class="comment">//注意非空判断</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到程序集中所有兼容IAppFunctionality的类</span></span><br><span class="line">            <span class="keyword">var</span> types = asm.GetTypes().Where(m =&gt; m.IsClass &amp;&amp; m.GetInterface(<span class="string">"IAppFunctionality"</span>) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> types)</span><br><span class="line">            &#123;</span><br><span class="line">                IAppFunctionality app = (IAppFunctionality)asm.CreateInstance(item.FullName, <span class="literal">true</span>);   <span class="comment">//用晚期绑定获得实例</span></span><br><span class="line">                或</span><br><span class="line">                IAppFunctionality app1 = (IAppFunctionality)Activator.CreateInstance(item);</span><br><span class="line">                app.DoIt();</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>允许我们在类型安全的强类型世界里使用校本化的行为。可以认为dynamic关键字是一个特殊形式的System.Object。但提供了更多特性，并且动态数据不是强类型的，或者说动态数据不是静态类型。</p>
<p>作用范围：字段，属性，返回值，参数。</p>
<h3 id="调用动态声明的数据成员"><a href="#调用动态声明的数据成员" class="headerlink" title="调用动态声明的数据成员"></a>调用动态声明的数据成员</h3><p>动态数据不属于静态类型，和js一样，直到运行时你才会直到所调用的动态数据是否支持指定的成员，参数以及成员的拼写是否无误等。编译时不能触发智能感知提示。</p>
<h3 id="dynamic实际用途"><a href="#dynamic实际用途" class="headerlink" title="dynamic实际用途"></a>dynamic实际用途</h3><p>构建一个需要大量使用后期绑定（通过反射）的.NET应用程序时。或者构建一个需要与遗留的COM库（如Office）进行交互的.NET应用程序。<br>使用dynamic可以大大减少打字时间，简化代码。但代价是失去了类型的安全性。</p>
<h3 id="DLR-dynamic-language-runtime，动态语言运行时-的特性"><a href="#DLR-dynamic-language-runtime，动态语言运行时-的特性" class="headerlink" title="DLR(dynamic language runtime，动态语言运行时)的特性"></a>DLR(dynamic language runtime，动态语言运行时)的特性</h3><ol>
<li>机器灵活的代码库，重构时不需要频繁修改数据类型。</li>
<li>不同平台和语言所构建的对象类型之间进行互操作非常简便。</li>
<li>可以在运行时为内存中的类型添加或移除成员。</li>
</ol>
<h3 id="使用dynamic简化晚期绑定"><a href="#使用dynamic简化晚期绑定" class="headerlink" title="使用dynamic简化晚期绑定"></a>使用dynamic简化晚期绑定</h3><pre><code>Type type=...;
</code></pre><ol>
<li><p>通过反射</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> obj=Activator.CreateInstance(type);</span><br><span class="line">MethodInfo mi=tpe.GetMethod(<span class="string">"Run"</span>);</span><br><span class="line"><span class="keyword">object</span>[] param=<span class="number">10</span>,<span class="number">20</span>;</span><br><span class="line">mi.Invoke(obj,param);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过dynamic</p>
 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> obj=Activator.CreateInstance(type);</span><br><span class="line">obj.Run(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>简化了查询程序集元数据和打包参数等操作。</p>
<h3 id="互操作程序集"><a href="#互操作程序集" class="headerlink" title="互操作程序集"></a>互操作程序集</h3><p>IDE以COM库为基础生成的全新程序集，包含了COM元数据的.NET描述和一小部分将COM事件转换为.NET事件的代码。封装，避免了内部COM的复杂性。</p>
<p>CLR（如果使用dynamic就是DLR）自动对.NET数据类型和COM类型进行映射，因此可以直接在C#代码中使用互操作程序集。在后台，使用RCW（Runtime Callable Wrapper，一个动态生成的代理）对数据进行封送，使其在.NET和COM应用程序之间交互。</p>
<h3 id="主互操作程序集"><a href="#主互操作程序集" class="headerlink" title="主互操作程序集"></a>主互操作程序集</h3><p>许多COM库供应商提供了一个“官方”的互操作程序集，成为主互操作程序集，简称PIA。PIA是优化的互操作程序集，比通过IDE添加COM库引用生成的代码更整洁，也更具扩展性。<br>PIA存在的情况下，添加应用一个COM库，VS会使用提供的PIA，而不是生成一个新的互操作程序集。</p>
<h3 id="嵌入互操作元数据"><a href="#嵌入互操作元数据" class="headerlink" title="嵌入互操作元数据"></a>嵌入互操作元数据</h3><p>添加COM库（PIA或其他）时，IDE会自动将该库的“嵌入互操作类型”置为true。<br>这样，必要的互操作元数据（你真正使用的那部分，而不是全部）已经硬编码到.NET程序中，我们就不必在.NET应用程序中携带互操作程序集的副本了。减少了安装包的尺寸，客户端计算机也不必包含改互操作程序集的副本。</p>
<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h3><p>当使用DLR进行处理动态数据时，自动创建的“表达式树”将被传递给正确的动态语言帮顶起。帮顶起解析表达式树并传递给正确的对象成员。</p>
<p><img src="/images/CSharp/MasterC/tree.jpg" alt="tree"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个正在运行的应用程序的固定的安全的边界。用来描述一组资源（外部代码库和主线程）和程序运行所必须的内存分配。</p>
<p>应用程序域：对该进程的逻辑细分。一个应用程序域进一步被细分成多个上下文边界，用来分组目的相似的.NET对象。</p>
<p>进程，应用程序域，上下文的关系：</p>
<p><img src="/images/CSharp/MasterC/relation.jpg" alt="relation"></p>
<p>线程：进程中的独立的基本的执行单元。每一个进程都有一个（在可执行入口处创建的）主线程和其他包含以编程方式创建的额外线程。</p>
<p>进程和线程的关系：当一个线程的时间片用完的时候，会被挂起，以便执行其他线程。线程把挂起前的情况写到线程本地存储中（Thread Local Storage，TLS），并且它们还要获得一个独立的调用栈（call stack）。</p>
<p><img src="/images/CSharp/MasterC/relation2.jpg" alt="relation2"></p>
<h3 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> procs = Process.GetProcesses(<span class="string">"."</span>);</span><br><span class="line">procs.OrderBy(m =&gt; m.Id).ToList().ForEach(m =&gt; Console.WriteLine(<span class="string">"&#123;0&#125;：&#123;1&#125;"</span>, m.Id, m.ProcessName));</span><br><span class="line"><span class="keyword">var</span> proc = Process.GetProcessById(<span class="number">4</span>);   <span class="comment">//进程不存在则引发异常</span></span><br><span class="line"><span class="comment">//PID为0的System Idle Prcess，表示系统核心虚拟出来的表示CPU空闲的状态。输入会出错。</span></span><br><span class="line">Console.WriteLine(proc.Id + <span class="string">"："</span> + proc.ProcessName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProcessThread并不用于操作线程，只是用户获取运行进程中线程的诊断信息</span></span><br><span class="line"><span class="keyword">foreach</span> (ProcessThread item <span class="keyword">in</span> proc.Threads)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;：&#123;1&#125;：&#123;2&#125;：&#123;3&#125;"</span>, item.Id, item.PriorityLevel, item.StartTime, item.ThreadState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看进程中的模块"><a href="#查看进程中的模块" class="headerlink" title="查看进程中的模块"></a>查看进程中的模块</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proc = Process.GetProcessById(<span class="number">10284</span>);</span><br><span class="line"><span class="keyword">var</span> modls = proc.Modules;</span><br><span class="line"><span class="keyword">foreach</span> (ProcessModule item <span class="keyword">in</span> modls)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;：&#123;1&#125;"</span>, item.ModuleName, item.ModuleMemorySize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编程方式启动或结束进程"><a href="#编程方式启动或结束进程" class="headerlink" title="编程方式启动或结束进程"></a>编程方式启动或结束进程</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proc = Process.Start(<span class="string">"Chrome"</span>, <span class="string">"www.baidu.com"</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"启动："</span> + proc.ProcessName + <span class="string">"，PID："</span> + proc.Id);</span><br><span class="line">Console.ReadKey();</span><br><span class="line">proc.Kill();    <span class="comment">//如果进程已关闭，或附加到别的进程上。则此处会抛出异常</span></span><br></pre></td></tr></table></figure>
<h3 id="ProcessStartInfo启动进程"><a href="#ProcessStartInfo启动进程" class="headerlink" title="ProcessStartInfo启动进程"></a>ProcessStartInfo启动进程</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProcessStartInfo info = <span class="keyword">new</span> ProcessStartInfo</span><br><span class="line">&#123;</span><br><span class="line">    FileName = <span class="string">"Chrome"</span>,</span><br><span class="line">    Arguments = <span class="string">"www.baidu.com"</span>,</span><br><span class="line">    WindowStyle = ProcessWindowStyle.Hidden</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proc = Process.Start(info);</span><br></pre></td></tr></table></figure>
<h3 id="应用程序域"><a href="#应用程序域" class="headerlink" title="应用程序域"></a>应用程序域</h3><p>传统的非托管程序直接承载在进程上，而.NET可执行程序承载在进程的一个逻辑分区中，即应用程序域（AppDomain）。运行在某个应用程序域中的应用程序将无法访问其他应用程序域中的数据（无论是全局变量还是静态字段），除非使用分布式编程协议（如WCF）。好处在于：</p>
<ol>
<li>应用程序域是.NET平台操作系统独立性的关键特性。将不同操作系统表现加载可执行程序的差异抽象化了。</li>
<li>和一个完整的进程相比，应用程序域的CPU和内存占用都有小的多。因此CLR加载和卸载应用程序域比起来完整的进程来说也快得多，并且可以快速提升服务器应用程序的可扩展性。</li>
<li>应用程序域为承载的应用程序提供了深度的隔离。如果进程中一个应用程序域失败了，剩余的应用程序域也能保持正常。</li>
</ol>
<p>.NET平台不允许从内存中卸载指定的程序集。已编程方式卸载库的唯一方式是使用Unload()方法销毁承载的应用程序域。</p>
<h3 id="默认程序域"><a href="#默认程序域" class="headerlink" title="默认程序域"></a>默认程序域</h3><p>一个.NET可执行文件启动时，CLR会自动将其放置到宿主进程的默认应用程序域中。<br>访问当前线程的应用程序域</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDomain app = AppDomain.CurrentDomain;</span><br><span class="line">Console.WriteLine(<span class="string">"&#123;0&#125;：&#123;1&#125;：&#123;2&#125;：&#123;3&#125;"</span>,app.FriendlyName,app.Id,app.IsDefaultAppDomain(),app.BaseDirectory);</span><br><span class="line"><span class="comment">//BaseDirectory，程序集解约程序用它来探测程序集</span></span><br></pre></td></tr></table></figure>
<h3 id="应用程序域中加载的-NET程序集"><a href="#应用程序域中加载的-NET程序集" class="headerlink" title="应用程序域中加载的.NET程序集"></a>应用程序域中加载的.NET程序集</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AppDomain app = AppDomain.CurrentDomain;</span><br><span class="line"><span class="keyword">var</span> asms = app.GetAssemblies();</span><br><span class="line"><span class="keyword">foreach</span> (Assembly item <span class="keyword">in</span> asms)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.GetName().Name + <span class="string">"："</span> + item.GetName().Version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收程序集加载通知"><a href="#接收程序集加载通知" class="headerlink" title="接收程序集加载通知"></a>接收程序集加载通知</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AppDomain app = AppDomain.CurrentDomain;</span><br><span class="line">app.AssemblyLoad += (o, s) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(s.LoadedAssembly.GetName().Name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="创建新的应用程序域"><a href="#创建新的应用程序域" class="headerlink" title="创建新的应用程序域"></a>创建新的应用程序域</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AppDomain app = AppDomain.CreateDomain(<span class="string">"Second"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Assembly item <span class="keyword">in</span> app.GetAssemblies())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//只加载了mscorlib。如果调试的话还会加载用于调试的额外程序集</span></span><br><span class="line">    Console.WriteLine(item.GetName().Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.Load(<span class="string">"CarLib"</span>);           <span class="comment">//向自定义应用程序域中加载程序集，此时加载的程序集多了一个</span></span><br><span class="line"></span><br><span class="line">AppDomain.Unload(app);  <span class="comment">//卸载自定义应用程序域</span></span><br></pre></td></tr></table></figure>
<h3 id="上下文边界"><a href="#上下文边界" class="headerlink" title="上下文边界"></a>上下文边界</h3><p>给定对象“特定的家”，一个进程定义了默认的应用程序域，每个应用程序域都有一个默认的上下文（总是第一个创建），也成为上下文0（context 0）。用于组合那些对上下文没有具体的或唯一性需求的.NET对象（大多数对象）。</p>
<p>不需要指定特定上下文的.NET类型称为上下文灵活（context-agile）对象，可以从应用程序域的任何位置访问，与对象的运行时需求没有关系。<br>需要指定特定上下文的对象称为上下文绑定（context-bound）对象，只能在其被创建的那个上下文中正常运行。必须派生自System.ContextBoundObject基类。</p>
<h3 id="定义上下文绑定对象"><a href="#定义上下文绑定对象" class="headerlink" title="定义上下文绑定对象"></a>定义上下文绑定对象</h3><p>自动线程安全的类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Contexts;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Synchronization</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContextObject</span> : <span class="title">ContextBoundObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i + <span class="string">"：当前线程-"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ContextObject obj = <span class="keyword">new</span> ContextObject();</span><br><span class="line">    Task.Run(() =&gt; obj.Do());</span><br><span class="line">    Task.Run(() =&gt; obj.Do());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="研究上下文"><a href="#研究上下文" class="headerlink" title="研究上下文"></a>研究上下文</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Contexts;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Synchronization</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContextObjectBound</span> : <span class="title">ContextBoundObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextObjectBound</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context ctx = Thread.CurrentContext;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span> + <span class="string">" 在上下文中： "</span> + ctx.ContextID);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ctx.ContextProperties)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ContextObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context ctx = Thread.CurrentContext;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span> + <span class="string">" 在上下文中： "</span> + ctx.ContextID);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ctx.ContextProperties)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ContextObject obj = <span class="keyword">new</span> ContextObject();     </span><br><span class="line">    <span class="comment">//0，LeaseLifeTimeServiceProperty</span></span><br><span class="line">    ContextObject obj1 = <span class="keyword">new</span> ContextObject();    </span><br><span class="line">    <span class="comment">//0，LeaseLifeTimeServiceProperty</span></span><br><span class="line">    ContextObjectBound objTs = <span class="keyword">new</span> ContextObjectBound();     </span><br><span class="line">    <span class="comment">//1，LeaseLifeTimeServiceProperty，Synchronization</span></span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CIL"><a href="#CIL" class="headerlink" title="CIL"></a>CIL</h3><p>.NET平台语言（C#，VB，F#等）的母语，某个语言相关联的编译器会把源代码翻译成CIL</p>
<h3 id="CIL标记分为3类"><a href="#CIL标记分为3类" class="headerlink" title="CIL标记分为3类"></a>CIL标记分为3类</h3><ol>
<li>CIL指令<br>以.前缀，例如：.namespace、.class、.pulickeytoken、.method、.assembly</li>
<li>CIL特性<br>例如：public，extends（指定这个类型的基类），implements（支持的一系列接口）</li>
<li>CIL操作码<br>例如：ldstr（LoadString，定义一个字符串变量），实际上是操作码的助记符。真正的操作码是二进制码，add - 0x58，sub - 0x59，newobj - 0x73。</li>
</ol>
<h3 id="CIL基于栈的本质"><a href="#CIL基于栈的本质" class="headerlink" title="CIL基于栈的本质"></a>CIL基于栈的本质</h3><p>CIL不允许直接访问一个数据（本地变量、参数变量或属性）。而是通过虚拟执行栈来访问。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> myMessage=<span class="string">"Hello"</span>;             <span class="comment">//分为1-3</span></span><br><span class="line">Console.WriteLine(myMessage);    <span class="comment">//分为4-5</span></span><br></pre></td></tr></table></figure>
<ol>
<li>.locals init ([0] string myMessage)<br>定义一个本地字符串变量（在Call Stack本地变量索引0处）</li>
<li>ldstr “Hello”<br>将字符串的引用放在了Envaluation Stack中，而真正的字符串放在了Managed Heap中</li>
<li>stloc.0<br>将Envaluation Stack中的值保存到 Call Stack中索引为0的本地变量中（V0，栈低已存在args[最底]和return address），因为Envaluation Stack中存放的是“hello”字符串的地址，所以变量中存放的也是字符串的地址。</li>
<li>ldloc.0<br>把Call Stack中索引0处变量的的值（引用地址），加载到Envaluation Stack中</li>
<li><p>call void [mscorlib]System.Console::WriteLine(string)<br>从 Evaluation Stack 中取出一个值，此值为 Reference Type，调用方法</p>
</li>
<li><p>Managed Heap（托管堆）：这是动态配置（Dynamic Allocation）的记忆体，由GC在执行时自动管理，整个 Process 共用一个 Managed Heap，可以理解为引用类型的东西都放在这个Managed Heap中。</p>
</li>
<li>Call Stack（调用栈）：CLR在执行时自动管理的记忆体，每个Thread都有自己的Call Stack堆栈。每调用一次method，就会使得Call Stack上多了一个Record Frame；调用完毕之后，此Record Frame会被丢弃。一般来说，Record Frame内记录着method参数（Parameter）、返回位址（Return Address）、以及局部变量（Local Variable）。CLR使用零基索引的方式来识别局部变量。</li>
<li>Evaluation Stack（虚拟执行栈）：这是由 CLR在执行时自动管理的记忆体，每个Thread都有自己的Evaluation Stack。压入的到Evaluation Stack的值，当方法调用结束时必须保持这个堆栈的平衡（清空），这里面存放例如局部变量值，以及引用类型的地址。如果忘记清空，ilasm仍然会编译成功。可以用peverify.exe工具诊断。peverify test.dll</li>
<li>ld，加载，用于压栈到虚拟执行栈</li>
<li>st，存储，用于弹栈虚拟执行栈顶的值到内存调用栈中</li>
</ol>
<h3 id="CIL的代码标签"><a href="#CIL的代码标签" class="headerlink" title="CIL的代码标签"></a>CIL的代码标签</h3><p>例如：IL_0001：，IL_000c。大多数标签是可选的，完全可以移除。只有编写有多个分支和循环结构的CIL代码时，通过这些标签指定逻辑流转到哪里的时候，才是必需的。</p>
<h3 id="使用ilasm-exe编译CIL代码"><a href="#使用ilasm-exe编译CIL代码" class="headerlink" title="使用ilasm.exe编译CIL代码"></a>使用ilasm.exe编译CIL代码</h3><pre><code>ilasm /exe Hello.il /output=NewAssembly.exe
</code></pre><p>-?查看选项参数</p>
<h3 id="CIL指令和特性"><a href="#CIL指令和特性" class="headerlink" title="CIL指令和特性"></a>CIL指令和特性</h3><ol>
<li>指定外部应用程序集</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.assembly <span class="keyword">extern</span> mscorlib</span><br><span class="line">&#123;</span><br><span class="line">        .publickeytoken=(B7 <span class="number">7</span>A <span class="number">5</span>C <span class="number">56</span> <span class="number">19</span> <span class="number">34</span> E0 <span class="number">89</span>)</span><br><span class="line">        .ver <span class="number">4</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义当前程序集</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.assembly CILTypes</span><br><span class="line">&#123;</span><br><span class="line">        .ver <span class="number">1</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.module CILTypes.dll            <span class="comment">//单模块程序集</span></span><br></pre></td></tr></table></figure>
<ol>
<li>定义命名空间</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.namespace MyNamespance&#123;&#125;</span><br><span class="line">.namespace Myconpany.MyNamespace&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义类类型</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.namespace MyNamespace</span><br><span class="line">&#123;</span><br><span class="line">        .class <span class="keyword">public</span> MyBaseClass</span><br><span class="line">            extends [BaseEntity]BaseEntity.AuditEntityBase&#123;&#125;</span><br><span class="line">        <span class="comment">//CIL要求使用完整的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义和实现接口</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface</span>&#123;&#125;</span><br><span class="line">.class <span class="keyword">public</span> MyBaseClass&#123;&#125;</span><br><span class="line">.class <span class="keyword">public</span> MyDerivedClass</span><br><span class="line">    extends MyNamespace.MyBaseClass</span><br><span class="line">    implements MyNamespace.IMyInterface&#123;&#125;</span><br><span class="line">    <span class="comment">//同一程序集下可以省略“[]”前缀。</span></span><br><span class="line">    <span class="comment">//extends在前，implements在后，多个接口用“，”分隔</span></span><br><span class="line">    <span class="comment">//接口派生接口使用implements</span></span><br></pre></td></tr></table></figure>
<ol>
<li>定义结构</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">sealed</span> MyStruct extends [mscorlib]System.ValueType&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>简化：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">value</span> MyStruct&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义枚举</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">sealed</span> MyEnum extends [mscorlib]Sytem.Enum&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>简化：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">enum</span> MyEnum&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义泛型</li>
</ol>
<p>C#：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; myIntes=<span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>CIL：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newobj instance void class [mscorlib]Sytem.Collections.Generic.List`1&lt;int32&gt;::.ctor()</span><br></pre></td></tr></table></figure>
<ol>
<li>定义数据字段</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">enum</span> MyEnum</span><br><span class="line">&#123;</span><br><span class="line">        .field <span class="keyword">public</span> <span class="keyword">static</span> literal valuetype</span><br><span class="line">        MyNamespace.MyEnum A=int32(<span class="number">0</span>)</span><br><span class="line">        .field <span class="keyword">public</span> <span class="keyword">static</span> literal valuetype</span><br><span class="line">        MyNamespace.MyEnum B=int32(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有成员</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">        .filed <span class="keyword">private</span> <span class="keyword">string</span> stringField=<span class="string">"hello!"</span></span><br><span class="line">        .filed <span class="keyword">private</span> int32 intField=int32(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义属性</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">        .method <span class="keyword">public</span> hidebysig specialname</span><br><span class="line">        <span class="function">instance <span class="keyword">string</span> <span class="title">get_TheString</span>(<span class="params"></span>) cil managed</span></span><br><span class="line"><span class="function">        </span>&#123;     <span class="comment">//实现     &#125;</span></span><br><span class="line">        .method <span class="keyword">public</span> hidebysig specialname</span><br><span class="line">        <span class="function">instance <span class="keyword">void</span> <span class="title">set_TheString</span>(<span class="params"><span class="keyword">string</span> <span class="string">'value'</span></span>) cil managed</span></span><br><span class="line"><span class="function">        </span>&#123;     <span class="comment">//实现     &#125;</span></span><br><span class="line">        .<span class="function">property instance <span class="keyword">string</span> <span class="title">TheString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            .<span class="keyword">get</span> instance <span class="keyword">string</span></span><br><span class="line">                MyNamespace.MyBaseClass::get_TheString()</span><br><span class="line">            .<span class="keyword">set</span> instance <span class="keyword">void</span></span><br><span class="line">                MyNamespace.MyBaseClass::set_TheString(string)</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义构造函数</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.class <span class="keyword">public</span> MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">        .fileld <span class="keyword">private</span> int32 intField</span><br><span class="line">        .method <span class="keyword">public</span> hidebysig specialname rtsspecialname</span><br><span class="line">        instance <span class="keyword">void</span> .ctor(<span class="keyword">string</span> s,int32 i) cil managed</span><br><span class="line">        &#123;     <span class="comment">//实现     &#125;</span></span><br><span class="line">        <span class="comment">//.ctor指令和instance特性结合使用</span></span><br><span class="line">        <span class="comment">//cil managed标识出这个方法包含的是CIL代码而不是非托管代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义参数</li>
</ol>
<p>C#：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">int</span> inputInt,<span class="keyword">ref</span> <span class="keyword">int</span> refInt,ArrayList ar,<span class="keyword">out</span> outputInt</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    outputInt=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CIL：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> hidebysig <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params">int32 inputInt,</span></span></span><br><span class="line"><span class="function"><span class="params">    int32&amp; refInt,</span></span></span><br><span class="line"><span class="function"><span class="params">    class [mscorlib]System.Collections.ArrayList ar,</span></span></span><br><span class="line"><span class="function"><span class="params">    [<span class="keyword">out</span>] int32&amp; outputInt</span>) cil managed</span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NET-基础类库、C-和CIL数据类型的映射"><a href="#NET-基础类库、C-和CIL数据类型的映射" class="headerlink" title=".NET 基础类库、C#和CIL数据类型的映射"></a>.NET 基础类库、C#和CIL数据类型的映射</h3><p><img src="/images/CSharp/MasterC/mapping.jpg" alt="mapping"></p>
<h3 id="maxstack指令"><a href="#maxstack指令" class="headerlink" title=".maxstack指令"></a>.maxstack指令</h3><p>确定一个在方法执行阶段可以被压入栈中的最大变量数目。默认值是8</p>
<h3 id="在CIL中映射参数到本地变量"><a href="#在CIL中映射参数到本地变量" class="headerlink" title="在CIL中映射参数到本地变量"></a>在CIL中映射参数到本地变量</h3><p>C#：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a,<span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CIL：</p>
<p>//已简化</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> hidebysig <span class="keyword">static</span> int32 <span class="title">Add</span>(<span class="params">int32 a,int32 b</span>) cilmanaged</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .maxstack <span class="number">2</span></span><br><span class="line">    ldarg<span class="number">.0</span>     <span class="comment">//加载'a'到栈中</span></span><br><span class="line">    ldarg<span class="number">.1</span>     <span class="comment">//加载'b'到栈中</span></span><br><span class="line">    <span class="keyword">add</span>          <span class="comment">//从栈中弹出这2个值，并求和，并将计算结果存回栈中</span></span><br><span class="line">    ret            <span class="comment">//将和弹出栈，并通过ret操作码返回到调用者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this隐式引用"><a href="#this隐式引用" class="headerlink" title="this隐式引用"></a>this隐式引用</h3><p>虚拟执行栈索引是从0开始。在使用CIL代码时，任何非静态函数在接收传入参数时都自动隐式地接受了一个附加参数，即当前对象的引用（this）。<br>C#：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a,<span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CIL：//伪代码，this是隐式的接受的</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> hidebysig <span class="keyword">static</span> int32 <span class="title">AddTwoInt</span>(<span class="params">MyClass_HiddenThisPointer <span class="keyword">this</span>,int32 a,int32 b</span>) cil managed</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ldarg<span class="number">.0</span>   <span class="comment">//加载MyClass_HiddenThisPointer到虚拟执行栈上</span></span><br><span class="line">    ldarg<span class="number">.1</span>   <span class="comment">//加载'a'</span></span><br><span class="line">    ldarg<span class="number">.2</span>   <span class="comment">//加载'b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>C#：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountToTen</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CIL：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> hidebysig <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">COuntToTen</span>(<span class="params"></span>) cil managed</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .maxstack <span class="number">2</span></span><br><span class="line">    .<span class="function">locals <span class="title">init</span> (<span class="params">[<span class="number">0</span>] int32 i</span>)   <span class="comment">//初始化本地变量'i'</span></span></span><br><span class="line"><span class="function">    IL_0000:   loc.i4.0        <span class="comment">//压栈'0'到栈中</span></span></span><br><span class="line"><span class="function">    IL_0001:   stloc.0         <span class="comment">//弹栈'0'，并存储这个值到调用栈变量索引'0'</span></span></span><br><span class="line"><span class="function">    IL_0002:   br.s IL_0008<span class="comment">//跳转到IL_0008</span></span></span><br><span class="line"><span class="function">    IL_0004:   ldloc.0          <span class="comment">//压栈索引0的值</span></span></span><br><span class="line"><span class="function">    IL_0005:   ldc.i4.1         <span class="comment">//压栈'1'</span></span></span><br><span class="line"><span class="function">    IL_0006:   <span class="keyword">add</span>               <span class="comment">//两值弹栈，相加，结果压栈</span></span></span><br><span class="line"><span class="function">    IL_0007:   stloc.0</span></span><br><span class="line"><span class="function">    IL_0008:   ldloc.0          <span class="comment">//压栈索引0的值</span></span></span><br><span class="line"><span class="function">    IL_0009:   ldc.i4.s  10   <span class="comment">//压栈'10‘</span></span></span><br><span class="line"><span class="function">    IL_000b:   blt.s IL_0004 <span class="comment">//两值弹栈，比较。小于10？如果是，跳转IL_0004</span></span></span><br><span class="line"><span class="function">    IL_oood:   ret                  <span class="comment">//</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态程序集"><a href="#动态程序集" class="headerlink" title="动态程序集"></a>动态程序集</h3><p>静态程序集：存在于磁盘的.NET二进制文件<br>动态程序集：运行中通过使用System.Reflection.Emit命名空间提供的类型在内存中创建程序集及其模块，类型定义以及CIL实现逻辑。并可以保存到磁盘上生成一个新的静态程序集。<br>用处：</p>
<p>构建需要根据用户输入来生成程序集文件的.NET开发工具<br>构建需要在运行时通过元数据来生成远程类型的代理的程序<br>加载静态程序集并能动态插入新类型到二进制图像中。</p>
<h3 id="System-Reflection-Emit命名空间的成员"><a href="#System-Reflection-Emit命名空间的成员" class="headerlink" title="System.Reflection.Emit命名空间的成员"></a>System.Reflection.Emit命名空间的成员</h3><p><img src="/images/CSharp/MasterC/reflection.jpg" alt="reflection"></p>
<h3 id="ILGenerator"><a href="#ILGenerator" class="headerlink" title="ILGenerator"></a>ILGenerator</h3><p>注入CIL操作码到一个给定的类型成员。</p>
<h3 id="产生动态程序集，保存并实现延迟绑定"><a href="#产生动态程序集，保存并实现延迟绑定" class="headerlink" title="产生动态程序集，保存并实现延迟绑定"></a>产生动态程序集，保存并实现延迟绑定</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CreateMyAm(AppDomain.CurrentDomain);</span><br><span class="line"></span><br><span class="line">        Assembly asm = Assembly.Load(<span class="string">"MyAssembly"</span>);</span><br><span class="line">        Type type = asm.GetType(<span class="string">"MyAssembly.HelloWorld"</span>);</span><br><span class="line">        <span class="keyword">var</span> mi = type.GetMethod(<span class="string">"SayHello"</span>);</span><br><span class="line">        <span class="keyword">object</span> obj = Activator.CreateInstance(type, <span class="string">"123"</span>);</span><br><span class="line">        mi.Invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        mi = type.GetMethod(<span class="string">"GetMsg"</span>);</span><br><span class="line">        Console.WriteLine(mi.Invoke(obj, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateMyAm</span>(<span class="params">AppDomain app</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//建立通用程序集特征</span></span><br><span class="line">        AssemblyName asmName = <span class="keyword">new</span> AssemblyName</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">"MyAssembly"</span>,</span><br><span class="line">            Version = <span class="keyword">new</span> Version(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">            KeyPair = <span class="keyword">new</span> StrongNameKeyPair(File.ReadAllBytes(<span class="string">@"C:\test.snk"</span>))     <span class="comment">//产生强名，才可以直接引用，并使用using</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//在当前应用程序域中创建一个新的程序集</span></span><br><span class="line">        AssemblyBuilder asm = app.DefineDynamicAssembly(asmName, AssemblyBuilderAccess.Save);</span><br><span class="line">        <span class="comment">//因为是单文件程序集，模块的名字就是程序集的名字</span></span><br><span class="line">        ModuleBuilder module = asm.DefineDynamicModule(<span class="string">"MyAssembly"</span>, <span class="string">"MyAssembly.dll"</span>);</span><br><span class="line">        <span class="comment">//定义一个公共类</span></span><br><span class="line">        TypeBuilder myClass = module.DefineType(<span class="string">"MyAssembly.HelloWorld"</span>, TypeAttributes.Public);</span><br><span class="line">        <span class="comment">//定义一个私有字符串成员变量</span></span><br><span class="line">        FieldBuilder strField = myClass.DefineField(<span class="string">"theMessage"</span>, <span class="keyword">typeof</span>(<span class="keyword">string</span>), FieldAttributes.Private);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建自定义的构造函数</span></span><br><span class="line">        ConstructorBuilder ctor = myClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>) &#125;);</span><br><span class="line">        ILGenerator ilCtor = ctor.GetILGenerator();</span><br><span class="line">        ilCtor.Emit(OpCodes.Ldarg_0);</span><br><span class="line">        ConstructorInfo superCtor = <span class="keyword">typeof</span>(<span class="keyword">object</span>).GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line">        ilCtor.Emit(OpCodes.Call, superCtor);   <span class="comment">//调用基类构造函数</span></span><br><span class="line">        ilCtor.Emit(OpCodes.Ldarg_0);           <span class="comment">//压栈对象的this指针</span></span><br><span class="line">        ilCtor.Emit(OpCodes.Ldarg_1);           <span class="comment">//压栈参数</span></span><br><span class="line">        ilCtor.Emit(OpCodes.Stfld, strField);   <span class="comment">//存储在this的strField</span></span><br><span class="line">        ilCtor.Emit(OpCodes.Ret);</span><br><span class="line">        <span class="comment">//创建默认构造函数</span></span><br><span class="line">        myClass.DefineDefaultConstructor(MethodAttributes.Public);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建GetMsg()方法</span></span><br><span class="line">        MethodBuilder getMsg = myClass.DefineMethod(<span class="string">"GetMsg"</span>, MethodAttributes.Public, <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="literal">null</span>);</span><br><span class="line">        ILGenerator ilMethod = getMsg.GetILGenerator();</span><br><span class="line">        ilMethod.Emit(OpCodes.Ldarg_0);</span><br><span class="line">        ilMethod.Emit(OpCodes.Ldfld, strField);</span><br><span class="line">        ilMethod.Emit(OpCodes.Ret);</span><br><span class="line">        <span class="comment">//创建SayHello()方法</span></span><br><span class="line">        MethodBuilder sayHello = myClass.DefineMethod(<span class="string">"SayHello"</span>, MethodAttributes.Public);</span><br><span class="line">        ilMethod = sayHello.GetILGenerator();</span><br><span class="line">        ilMethod.EmitWriteLine(<span class="string">"Hello World!"</span>);</span><br><span class="line">        ilMethod.Emit(OpCodes.Ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建类Hello World</span></span><br><span class="line">        myClass.CreateType();</span><br><span class="line">        <span class="comment">//保存程序集</span></span><br><span class="line">        asm.Save(<span class="string">"MyAssembly.dll"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第六部分：-NET基础类库"><a href="#第六部分：-NET基础类库" class="headerlink" title="第六部分：.NET基础类库"></a>第六部分：.NET基础类库</h2><h3 id="应用程序域和线程"><a href="#应用程序域和线程" class="headerlink" title="应用程序域和线程"></a>应用程序域和线程</h3><p>一个应用程序域可以承载多个线程，线程可以跨越不同的应用程序域</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppDomain ad=Thread.GetDomain();</span><br></pre></td></tr></table></figure>
<p>获取正在承载当前线程的应用程序域</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context ctx=Thread.CurrentContext;</span><br></pre></td></tr></table></figure>
<p>获取当前操作线程所处的上下文</p>
<h3 id="委托的异步性"><a href="#委托的异步性" class="headerlink" title="委托的异步性"></a>委托的异步性</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> isDone = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Main，线程ID："</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        MyMethod m = Add;</span><br><span class="line">        IAsyncResult ar = m.BeginInvoke(<span class="number">10</span>, <span class="number">10</span>, AddComplete, <span class="string">"R U Ok?"</span>);    <span class="comment">//开启异步，使用的是线程池的工作者线程（后台线程）</span></span><br><span class="line">        <span class="comment">//轮询方式</span></span><br><span class="line">        <span class="comment">//while (!ar.AsyncWaitHandle.WaitOne(1000,true))</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    Console.WriteLine("Working...");</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调方式</span></span><br><span class="line">        <span class="keyword">while</span> (!isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Working..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Add，线程ID："</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddComplete</span>(<span class="params">IAsyncResult result</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Complete，线程ID："</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">"，Msg"</span> + result.AsyncState);</span><br><span class="line">        AsyncResult ar = (AsyncResult)result;</span><br><span class="line">        MyMethod m = (MyMethod)ar.AsyncDelegate;</span><br><span class="line">        Console.WriteLine(<span class="string">"Result："</span> + m.EndInvoke(result));</span><br><span class="line">        isDone = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Threading命名空间"><a href="#Threading命名空间" class="headerlink" title="Threading命名空间"></a>Threading命名空间</h3><p><img src="/images/CSharp/MasterC/threading.jpg" alt="threading"></p>
<h3 id="AutoResetEvent类"><a href="#AutoResetEvent类" class="headerlink" title="AutoResetEvent类"></a>AutoResetEvent类</h3><p>线程同步的通知类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AutoResetEvent waitHandle = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞一个线程，直到收到通知</span></span><br><span class="line"></span><br><span class="line">waitHandle.WaitOne();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知一个或多个线程事件终止，允许继续</span></span><br><span class="line"></span><br><span class="line">waitHandle.Set();</span><br></pre></td></tr></table></figure>
<h3 id="TimerCallBack"><a href="#TimerCallBack" class="headerlink" title="TimerCallBack"></a>TimerCallBack</h3><p>定时任务</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(Print, <span class="string">"时间："</span>, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.Clear();</span><br><span class="line">    Console.WriteLine(state + DateTime.Now.ToLongTimeString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPool的好处"><a href="#ThreadPool的好处" class="headerlink" title="ThreadPool的好处"></a>ThreadPool的好处</h3><p>1，减少了线程创建、开始和停止的次数，这提高了效率<br>2，能够使我们将注意力放到业务逻辑上而不是多线程架构上</p>
<p>某些情况仍应优先使用手工线程管理：<br>1，需要前台线程或设置优先级别，线程池中的线程总是后台线程，优先级是默认的。无法修改<br>2，需要一个带有固定标识的线程便于退出、挂起或通过名字发现它。</p>
<h3 id="Parallel类"><a href="#Parallel类" class="headerlink" title="Parallel类"></a>Parallel类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> filePath = <span class="string">@"C:\Pictures"</span>;</span><br><span class="line">        <span class="keyword">string</span>[] files = Directory.GetFiles(filePath, <span class="string">"*.jpg"</span>, SearchOption.TopDirectoryOnly);</span><br><span class="line">        <span class="keyword">string</span> newPath = <span class="string">@"C:\Pictures\new"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(newPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(newPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并行方式</span></span><br><span class="line">        ParallelOptions option = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">        &#123;</span><br><span class="line">            CancellationToken = cts.Token,</span><br><span class="line">            MaxDegreeOfParallelism = System.Environment.ProcessorCount</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//主线程仍然被阻塞，等待其他线程完成工作</span></span><br><span class="line">            Parallel.ForEach(files, option, m =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                option.CancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">                <span class="keyword">string</span> fileName = Path.GetFileName(m);</span><br><span class="line">                <span class="keyword">using</span> (Bitmap map = <span class="keyword">new</span> Bitmap(m))</span><br><span class="line">                &#123;</span><br><span class="line">                    map.RotateFlip(RotateFlipType.RotateNoneFlipX); <span class="comment">//左右翻转</span></span><br><span class="line">                    map.Save(Path.Combine(newPath, fileName));</span><br><span class="line">                    Console.WriteLine(<span class="string">"Id："</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"等待中...（最后才显示）"</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parallel.Invoke(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = DoSomething();</span><br><span class="line">&#125;, () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = DoAnthor();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="次线程访问UI线程的控件"><a href="#次线程访问UI线程的控件" class="headerlink" title="次线程访问UI线程的控件"></a>次线程访问UI线程的控件</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.Invoke((Action)<span class="keyword">delegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Text=....;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>WinForm中，线程创建的控件具有“线程相关性”。次线程不能直接访问主线程（UI线程）创建的控件，可以通过此方法传递异步委托执行。</p>
<h3 id="async-await关键字"><a href="#async-await关键字" class="headerlink" title="async await关键字"></a>async await关键字</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Main Id:"</span> + Thread.CurrentThread.ManagedThreadId);   <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">new</span> Program().Entry();</span><br><span class="line">        Console.WriteLine(<span class="string">"等待中..."</span>);    <span class="comment">//先出现</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Main Id:"</span> + Thread.CurrentThread.ManagedThreadId);   <span class="comment">//主线程</span></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">DoItAsync</span>(<span class="params"></span>)   <span class="comment">//约定以Asynv后缀</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"DoIt Id:"</span> + Thread.CurrentThread.ManagedThreadId);  <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="keyword">await</span> Task.Run(() =&gt;        <span class="comment">//开启新线程，主线程在执行完await标记的代码（Task.Run创建新线程部分，不包含内部的委托部分）后跳出</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"DoIt Id:"</span> + Thread.CurrentThread.ManagedThreadId); <span class="comment">//新线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"haha"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine(<span class="string">"DoIt Id:"</span> + Thread.CurrentThread.ManagedThreadId);  <span class="comment">//新线程</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Entry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);   <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">string</span> ret = <span class="keyword">await</span> DoItAsync();     <span class="comment">//await 负责提取包含在Task对象中的内在返回值。</span></span><br><span class="line">        <span class="comment">//主线程把具有await标记的DoIt() 执行完毕之后，跳出此方法到调用处继续执行。</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);   <span class="comment">//新线程</span></span><br><span class="line">        Console.WriteLine(ret); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回void的异步方法"><a href="#返回void的异步方法" class="headerlink" title="返回void的异步方法"></a>返回void的异步方法</h3><p>返回非泛型的Task类，并忽略return</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> asynv Task <span class="title">MethodVoidAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个await的异步方法"><a href="#多个await的异步方法" class="headerlink" title="多个await的异步方法"></a>多个await的异步方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Entry</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用者线程</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="comment">//调用者跳出返回，开启新线程1</span></span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; Thread.Sleep(<span class="number">3000</span>));</span><br><span class="line">    <span class="comment">//新线程1</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="comment">//新线程1销毁，开启新线程2</span></span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; Thread.Sleep(<span class="number">3000</span>));</span><br><span class="line">    <span class="comment">//下同</span></span><br><span class="line">    Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; Thread.Sleep(<span class="number">3000</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">"Entry Id:"</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="System-IO"><a href="#System-IO" class="headerlink" title="System.IO"></a>System.IO</h3><p><img src="/images/CSharp/MasterC/io.jpg" alt="io"></p>
<h3 id="获取计算机上驱动器的细节"><a href="#获取计算机上驱动器的细节" class="headerlink" title="获取计算机上驱动器的细节"></a>获取计算机上驱动器的细节</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriveInfo[] drives = DriveInfo.GetDrives();</span><br></pre></td></tr></table></figure>
<h3 id="StreamWriter和StreamReader"><a href="#StreamWriter和StreamReader" class="headerlink" title="StreamWriter和StreamReader"></a>StreamWriter和StreamReader</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamWriter writer = File.CreateText(<span class="string">"1.txt"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    writer.WriteLine(<span class="string">"hahaha"</span>);</span><br><span class="line">    writer.WriteLine(<span class="string">"hahaha"</span>);</span><br><span class="line">    writer.Write(writer.NewLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamWriter writer=<span class="keyword">new</span> StreamWriter(<span class="string">"1.txt"</span>))</span><br><span class="line">&#123;            </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamReader reader = File.OpenText(<span class="string">"1.txt"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span> buffer;</span><br><span class="line">    <span class="keyword">while</span> ((buffer = reader.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamReader reader=<span class="keyword">new</span> StreamReader(<span class="string">"1.txt"</span>))</span><br><span class="line">&#123;            </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinaryWriter类"><a href="#BinaryWriter类" class="headerlink" title="BinaryWriter类"></a>BinaryWriter类</h3><p>允许我们从基层流中以简洁的二进制格式读取或写入离散数据类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (BinaryWriter bw=<span class="keyword">new</span> BinaryWriter(File.OpenWrite(<span class="string">"1.txt"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Type："</span>+bw.BaseStream);</span><br><span class="line">    bw.Write(<span class="string">'1'</span>);</span><br><span class="line">    bw.Write(<span class="string">"123"</span>);</span><br><span class="line">    bw.Write(<span class="number">123</span>);</span><br><span class="line">    bw.Write(<span class="number">12.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (BinaryReader br=<span class="keyword">new</span> BinaryReader(File.OpenRead(<span class="string">"1.txt"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(br.ReadString()); <span class="comment">//只有"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileSystemWatcher watcher = <span class="keyword">new</span> FileSystemWatcher</span><br><span class="line">&#123;</span><br><span class="line">    Path = Directory.GetCurrentDirectory(),</span><br><span class="line">    Filter = <span class="string">"*.txt"</span>,</span><br><span class="line">    NotifyFilter =</span><br><span class="line">        NotifyFilters.LastAccess</span><br><span class="line">        | NotifyFilters.LastWrite</span><br><span class="line">        | NotifyFilters.FileName</span><br><span class="line">        | NotifyFilters.DirectoryName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">watcher.Changed += (o, e) =&gt; Console.WriteLine(e.FullPath + <span class="string">"\t"</span> + e.ChangeType);</span><br><span class="line">watcher.Created += (o, e) =&gt; Console.WriteLine(e.FullPath + <span class="string">"\t"</span> + e.ChangeType);</span><br><span class="line">watcher.Deleted += (o, e) =&gt; Console.WriteLine(e.FullPath + <span class="string">"\t"</span> + e.ChangeType);</span><br><span class="line">watcher.Renamed += (o, e) =&gt; Console.WriteLine(e.OldFullPath + <span class="string">"\t"</span> + e.FullPath);</span><br><span class="line">watcher.EnableRaisingEvents = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Program p = <span class="keyword">new</span> Program &#123; Name = <span class="string">"Main"</span> &#125;;</span><br><span class="line">        BinaryFormatter format = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenWrite(<span class="string">"1.txt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            format.Serialize(stream, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">"1.txt"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Program p1 = (Program)format.Deserialize(stream);</span><br><span class="line">            Console.WriteLine(p1.Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3><p><img src="/images/CSharp/MasterC/map.jpg" alt="map"></p>
<h3 id="持久化对象的格式"><a href="#持久化对象的格式" class="headerlink" title="持久化对象的格式"></a>持久化对象的格式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Formatters.Soap;</span><br></pre></td></tr></table></figure>
<p><img src="/images/CSharp/MasterC/save.jpg" alt="save"></p>
<h3 id="XmlSerializer和SoapFormatter"><a href="#XmlSerializer和SoapFormatter" class="headerlink" title="XmlSerializer和SoapFormatter"></a>XmlSerializer和SoapFormatter</h3><p>XmlSerializer:持久化为XML文档，只会保存公有已赋值字段或公共属性。可以保存偏好设置（颜色，文字大小等）。<br>SoapFormatter:持久化为一个SOAP消息（传递消息到Web服务或从Web服务传递消息的标准XML格式）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;Picture&gt; list = <span class="keyword">new</span> List&lt;Picture&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Picture&#123; Id=<span class="number">0</span>,Url=<span class="string">"1.jpg"</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Picture&#123; Id=<span class="number">1</span>,Url=<span class="string">"2.jpg"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    XmlSerializer format = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(List&lt;Picture&gt;), <span class="string">"Carousels"</span>);</span><br><span class="line">    或</span><br><span class="line">    SoapFormatter format = <span class="keyword">new</span> SoapFormatter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenWrite(<span class="string">"config.xml"</span>))     <span class="comment">//从头覆盖内容，不会重建文件</span></span><br><span class="line">    或</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(<span class="string">"config.xml"</span>, FileMode.Create, FileAccess.Write, FileShare.None))   <span class="comment">//重建文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        format.Serialize(stream, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">"config.xml"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Picture&gt; p1 = (List&lt;Picture&gt;)format.Deserialize(stream);</span><br><span class="line">        p1.ForEach(m =&gt; Console.WriteLine(<span class="string">"/images/CSharp/"</span> + m.Url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Picture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">//XmlSerializer不会包含</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name = <span class="string">"轮播图"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格式化程序中的类型保真"><a href="#格式化程序中的类型保真" class="headerlink" title="格式化程序中的类型保真"></a>格式化程序中的类型保真</h3><p>BinaryFormatter，持久化对象图中对象的字段数据，和每个类型的完全限定名城和定义程序集的完整名称（强名）。这些数据使跨越.NET应用程序机器边界传递对象成为理想的选择。<br>SoapFormatter，XmsSerializer，没有序列化完整的.NET类型元数据（完全限定名称或程序集），可用于标准的.NETWeb服务，可被任何平台中的客户端调用（Windows、MAC OS X和Linux）。</p>
<h3 id="控制生成的XML数据"><a href="#控制生成的XML数据" class="headerlink" title="控制生成的XML数据"></a>控制生成的XML数据</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Picture pic = <span class="keyword">new</span> Picture</span><br><span class="line">    &#123;</span><br><span class="line">        Id = <span class="number">1</span>,</span><br><span class="line">        Url = <span class="string">"2.jpg"</span>,</span><br><span class="line">        Date = DateTime.Now.ToShortDateString(),</span><br><span class="line">        Details = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123;<span class="string">"遍"</span>, <span class="string">"历"</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    XmlSerializer format = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Picture));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(<span class="string">"config.xml"</span>, FileMode.Create, FileAccess.Write, FileShare.None))</span><br><span class="line">    &#123;</span><br><span class="line">        format.Serialize(stream, pic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">"config.xml"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Picture p1 = (Picture)format.Deserialize(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable, XmlType(TypeName = <span class="meta-string">"SinglePicture"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Picture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">XmlEnum</span>]</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; Details;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">XmlAttribute</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的XML部分如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">SinglePicture</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">Date</span>=<span class="string">"2017/4/15"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Details</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>遍<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>历<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">Id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Url</span>&gt;</span>2.jpg<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">SinglePicture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用特性定制序列化"><a href="#使用特性定制序列化" class="headerlink" title="使用特性定制序列化"></a>使用特性定制序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Picture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OnSerializing</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSerializing</span>(<span class="params">StreamingContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Name += <span class="string">" Date:"</span> + DateTime.Now.ToShortDateString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">OnDeserialized</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDeserialized</span>(<span class="params">StreamingContext context</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Url = Url.ToLower();</span><br><span class="line">        Name = Name.ToUpper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>欢迎打赏</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Alan 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Alan 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Alan
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://adieUkid.github.io/2017/05/09/精通C_注释笔记/" title="精通C#_注释笔记">http://adieUkid.github.io/2017/05/09/精通C_注释笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C#</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/04/C-高级编程_注释笔记/" rel="next" title="C#高级编程_注释笔记">
                <i class="fa fa-chevron-left"></i> C#高级编程_注释笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/04/JavaScript高级程序设计_注释笔记/" rel="prev" title="JavaScript高级程序设计_注释笔记">
                JavaScript高级程序设计_注释笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MDUyOC8xNzA1NQ"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Alan" />
            
              <p class="site-author-name" itemprop="name">Alan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分：C-与-NET平台"><span class="nav-number">1.</span> <span class="nav-text">第一部分：C#与.NET平台</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码-IL-汇编过程"><span class="nav-number">1.1.</span> <span class="nav-text">源码-IL-汇编过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CTS"><span class="nav-number">1.2.</span> <span class="nav-text">CTS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLS"><span class="nav-number">1.3.</span> <span class="nav-text">CLS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mscoree-dll工作流"><span class="nav-number">1.4.</span> <span class="nav-text">mscoree.dll工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NET命名空间举例"><span class="nav-number">1.5.</span> <span class="nav-text">.NET命名空间举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Microsoft根命名空间"><span class="nav-number">1.6.</span> <span class="nav-text">Microsoft根命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NET-SKD"><span class="nav-number">1.7.</span> <span class="nav-text">.NET SKD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应文件"><span class="nav-number">1.8.</span> <span class="nav-text">响应文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二-三部分：C-核心编程结构-C-面向对象编程"><span class="nav-number">2.</span> <span class="nav-text">第二/三部分：C#核心编程结构/C#面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#char的静态方法"><span class="nav-number">2.1.</span> <span class="nav-text">char的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变枚举底层存储类型"><span class="nav-number">2.2.</span> <span class="nav-text">改变枚举底层存储类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-ValueType"><span class="nav-number">2.3.</span> <span class="nav-text">System.ValueType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅-深复制"><span class="nav-number">2.4.</span> <span class="nav-text">浅/深复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认访问修饰符"><span class="nav-number">2.5.</span> <span class="nav-text">默认访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Const-readonly-static"><span class="nav-number">2.6.</span> <span class="nav-text">Const,readonly,static</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四部分：高级C-编程结构"><span class="nav-number">3.</span> <span class="nav-text">第四部分：高级C#编程结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#delegate关键字"><span class="nav-number">3.1.</span> <span class="nav-text">delegate关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托"><span class="nav-number">3.2.</span> <span class="nav-text">委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event事件"><span class="nav-number">3.3.</span> <span class="nav-text">event事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventHanlder"><span class="nav-number">3.4.</span> <span class="nav-text">EventHanlder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符重载的思考"><span class="nav-number">3.5.</span> <span class="nav-text">操作符重载的思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Try-catch的CIL实现"><span class="nav-number">3.6.</span> <span class="nav-text">Try catch的CIL实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new关键字的CIL实现"><span class="nav-number">3.7.</span> <span class="nav-text">new关键字的CIL实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动属性的CIL实现"><span class="nav-number">3.8.</span> <span class="nav-text">自动属性的CIL实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用程序根"><span class="nav-number">3.9.</span> <span class="nav-text">应用程序根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的代"><span class="nav-number">3.10.</span> <span class="nav-text">对象的代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制垃圾回收"><span class="nav-number">3.11.</span> <span class="nav-text">强制垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC测试"><span class="nav-number">3.12.</span> <span class="nav-text">GC测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源包装器"><span class="nav-number">3.13.</span> <span class="nav-text">资源包装器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lazy-延迟加载"><span class="nav-number">3.14.</span> <span class="nav-text">Lazy 延迟加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五部分：用-NET程序集编程"><span class="nav-number">4.</span> <span class="nav-text">第五部分：用.NET程序集编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NET程序集的作用"><span class="nav-number">4.1.</span> <span class="nav-text">.NET程序集的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序集和托管模块"><span class="nav-number">4.2.</span> <span class="nav-text">程序集和托管模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NET程序集的格式"><span class="nav-number">4.3.</span> <span class="nav-text">.NET程序集的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有程序集"><span class="nav-number">4.4.</span> <span class="nav-text">私有程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享程序集"><span class="nav-number">4.5.</span> <span class="nav-text">共享程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强名称"><span class="nav-number">4.6.</span> <span class="nav-text">强名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在GAC中安装强名称的程序集"><span class="nav-number">4.7.</span> <span class="nav-text">在GAC中安装强名称的程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置共享程序集"><span class="nav-number">4.8.</span> <span class="nav-text">配置共享程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素"><span class="nav-number">4.9.</span> <span class="nav-text">元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type类型"><span class="nav-number">4.10.</span> <span class="nav-text">Type类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态加载程序集"><span class="nav-number">4.11.</span> <span class="nav-text">动态加载程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射共享程序集"><span class="nav-number">4.12.</span> <span class="nav-text">反射共享程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#晚期绑定"><span class="nav-number">4.13.</span> <span class="nav-text">晚期绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特性"><span class="nav-number">4.14.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序集级别特性"><span class="nav-number">4.15.</span> <span class="nav-text">程序集级别特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建可扩展的应用程序"><span class="nav-number">4.16.</span> <span class="nav-text">构建可扩展的应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic"><span class="nav-number">4.17.</span> <span class="nav-text">dynamic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用动态声明的数据成员"><span class="nav-number">4.18.</span> <span class="nav-text">调用动态声明的数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic实际用途"><span class="nav-number">4.19.</span> <span class="nav-text">dynamic实际用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLR-dynamic-language-runtime，动态语言运行时-的特性"><span class="nav-number">4.20.</span> <span class="nav-text">DLR(dynamic language runtime，动态语言运行时)的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用dynamic简化晚期绑定"><span class="nav-number">4.21.</span> <span class="nav-text">使用dynamic简化晚期绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互操作程序集"><span class="nav-number">4.22.</span> <span class="nav-text">互操作程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主互操作程序集"><span class="nav-number">4.23.</span> <span class="nav-text">主互操作程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌入互操作元数据"><span class="nav-number">4.24.</span> <span class="nav-text">嵌入互操作元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式树"><span class="nav-number">4.25.</span> <span class="nav-text">表达式树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">4.26.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Process类"><span class="nav-number">4.27.</span> <span class="nav-text">Process类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看进程中的模块"><span class="nav-number">4.28.</span> <span class="nav-text">查看进程中的模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程方式启动或结束进程"><span class="nav-number">4.29.</span> <span class="nav-text">编程方式启动或结束进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessStartInfo启动进程"><span class="nav-number">4.30.</span> <span class="nav-text">ProcessStartInfo启动进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用程序域"><span class="nav-number">4.31.</span> <span class="nav-text">应用程序域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认程序域"><span class="nav-number">4.32.</span> <span class="nav-text">默认程序域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用程序域中加载的-NET程序集"><span class="nav-number">4.33.</span> <span class="nav-text">应用程序域中加载的.NET程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收程序集加载通知"><span class="nav-number">4.34.</span> <span class="nav-text">接收程序集加载通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建新的应用程序域"><span class="nav-number">4.35.</span> <span class="nav-text">创建新的应用程序域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文边界"><span class="nav-number">4.36.</span> <span class="nav-text">上下文边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义上下文绑定对象"><span class="nav-number">4.37.</span> <span class="nav-text">定义上下文绑定对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#研究上下文"><span class="nav-number">4.38.</span> <span class="nav-text">研究上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIL"><span class="nav-number">4.39.</span> <span class="nav-text">CIL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIL标记分为3类"><span class="nav-number">4.40.</span> <span class="nav-text">CIL标记分为3类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIL基于栈的本质"><span class="nav-number">4.41.</span> <span class="nav-text">CIL基于栈的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIL的代码标签"><span class="nav-number">4.42.</span> <span class="nav-text">CIL的代码标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ilasm-exe编译CIL代码"><span class="nav-number">4.43.</span> <span class="nav-text">使用ilasm.exe编译CIL代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIL指令和特性"><span class="nav-number">4.44.</span> <span class="nav-text">CIL指令和特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NET-基础类库、C-和CIL数据类型的映射"><span class="nav-number">4.45.</span> <span class="nav-text">.NET 基础类库、C#和CIL数据类型的映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxstack指令"><span class="nav-number">4.46.</span> <span class="nav-text">.maxstack指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在CIL中映射参数到本地变量"><span class="nav-number">4.47.</span> <span class="nav-text">在CIL中映射参数到本地变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this隐式引用"><span class="nav-number">4.48.</span> <span class="nav-text">this隐式引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环结构"><span class="nav-number">4.49.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态程序集"><span class="nav-number">4.50.</span> <span class="nav-text">动态程序集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Reflection-Emit命名空间的成员"><span class="nav-number">4.51.</span> <span class="nav-text">System.Reflection.Emit命名空间的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ILGenerator"><span class="nav-number">4.52.</span> <span class="nav-text">ILGenerator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生动态程序集，保存并实现延迟绑定"><span class="nav-number">4.53.</span> <span class="nav-text">产生动态程序集，保存并实现延迟绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六部分：-NET基础类库"><span class="nav-number">5.</span> <span class="nav-text">第六部分：.NET基础类库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用程序域和线程"><span class="nav-number">5.1.</span> <span class="nav-text">应用程序域和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托的异步性"><span class="nav-number">5.2.</span> <span class="nav-text">委托的异步性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threading命名空间"><span class="nav-number">5.3.</span> <span class="nav-text">Threading命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutoResetEvent类"><span class="nav-number">5.4.</span> <span class="nav-text">AutoResetEvent类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TimerCallBack"><span class="nav-number">5.5.</span> <span class="nav-text">TimerCallBack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPool的好处"><span class="nav-number">5.6.</span> <span class="nav-text">ThreadPool的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel类"><span class="nav-number">5.7.</span> <span class="nav-text">Parallel类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#次线程访问UI线程的控件"><span class="nav-number">5.8.</span> <span class="nav-text">次线程访问UI线程的控件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-await关键字"><span class="nav-number">5.9.</span> <span class="nav-text">async await关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回void的异步方法"><span class="nav-number">5.10.</span> <span class="nav-text">返回void的异步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个await的异步方法"><span class="nav-number">5.11.</span> <span class="nav-text">多个await的异步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-IO"><span class="nav-number">5.12.</span> <span class="nav-text">System.IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取计算机上驱动器的细节"><span class="nav-number">5.13.</span> <span class="nav-text">获取计算机上驱动器的细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StreamWriter和StreamReader"><span class="nav-number">5.14.</span> <span class="nav-text">StreamWriter和StreamReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinaryWriter类"><span class="nav-number">5.15.</span> <span class="nav-text">BinaryWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件监视"><span class="nav-number">5.16.</span> <span class="nav-text">文件监视</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象序列化"><span class="nav-number">5.17.</span> <span class="nav-text">对象序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象图"><span class="nav-number">5.18.</span> <span class="nav-text">对象图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化对象的格式"><span class="nav-number">5.19.</span> <span class="nav-text">持久化对象的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XmlSerializer和SoapFormatter"><span class="nav-number">5.20.</span> <span class="nav-text">XmlSerializer和SoapFormatter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化程序中的类型保真"><span class="nav-number">5.21.</span> <span class="nav-text">格式化程序中的类型保真</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制生成的XML数据"><span class="nav-number">5.22.</span> <span class="nav-text">控制生成的XML数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用特性定制序列化"><span class="nav-number">5.23.</span> <span class="nav-text">使用特性定制序列化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>

  
</div>








  <div class="footer-custom">Hosted by <a target="_blank" href="https://pages.github.com">GitHub Pages</a></div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="250" alpha="0.6"  zIndex="0" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
